
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Person
 * Generic person object
 */
export type Person = {
  id: string
  firstName: string
  lastName: string
  email: string
  emailConfirmed: boolean | null
  phone: string | null
  company: string | null
  createdAt: Date
  updatedAt: Date | null
  newsletter: boolean | null
  address: string | null
  birthday: Date | null
  /**
   * Uniform Civil Number (NCN, EGN)
   * https://en.wikipedia.org/wiki/National_identification_number#Bulgaria
   */
  personalNumber: string | null
  keycloakId: string | null
  stripeCustomerId: string | null
}

/**
 * Model Company
 *
 */
export type Company = {
  id: string
  companyName: string
  /**
   * BULSTAT Unified Identification Code (UIC)
   * https://psc.egov.bg/en/psc-starting-a-business-bulstat
   */
  companyNumber: string
  legalPersonName: string | null
  countryCode: string | null
  cityId: string | null
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Coordinator
 * Coordinator is the person who manages the campaign on behalf of the Beneficiary
 * Alias: Organizer
 */
export type Coordinator = {
  id: string
  personId: string
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Benefactor
 * Benefactor is the person who gives money
 */
export type Benefactor = {
  id: string
  personId: string
  /**
   * Payment provider customer id
   */
  extCustomerId: string | null
  /**
   *
   */
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Beneficiary
 * Beneficiary is the person who receives the benefit
 */
export type Beneficiary = {
  id: string
  type: BeneficiaryType
  /**
   * Person in need when type is `individual`
   */
  personId: string | null
  /**
   * Company in need when type is `company`
   */
  companyId: string | null
  /**
   * Coordinator for this beneficiary
   */
  coordinatorId: string
  countryCode: string
  cityId: string
  description: string | null
  publicData: Prisma.JsonValue | null
  privateData: Prisma.JsonValue | null
  createdAt: Date
  updatedAt: Date | null
  coordinatorRelation: PersonRelation
}

/**
 * Model CampaignType
 *
 */
export type CampaignType = {
  id: string
  name: string
  slug: string
  description: string | null
  parentId: string | null
}

/**
 * Model Campaign
 *
 */
export type Campaign = {
  id: string
  state: CampaignState
  slug: string
  title: string
  essence: string
  coordinatorId: string
  beneficiaryId: string
  campaignTypeId: string
  approvedById: string | null
  description: string | null
  targetAmount: number | null
  currency: Currency
  startDate: Date | null
  endDate: Date | null
  createdAt: Date
  updatedAt: Date | null
  deletedAt: Date | null
}

/**
 * Model InfoRequest
 *
 */
export type InfoRequest = {
  id: string
  personId: string
  message: string
  createdAt: Date
  updatedAt: Date | null
  deletedAt: Date | null
}

/**
 * Model Supporter
 *
 */
export type Supporter = {
  id: string
  personId: string
  createdAt: Date
  updatedAt: Date | null
  deletedAt: Date | null
  comment: string | null
  associationMember: boolean
  benefactorCampaign: boolean
  benefactorPlatform: boolean
  companyOtherText: string | null
  companySponsor: boolean
  companyVolunteer: boolean
  partnerBussiness: boolean
  partnerNpo: boolean
  partnerOtherText: string | null
  roleAssociationMember: boolean
  roleBenefactor: boolean
  roleCompany: boolean
  rolePartner: boolean
  roleVolunteer: boolean
  volunteerBackend: boolean
  volunteerDesigner: boolean
  volunteerDevOps: boolean
  volunteerFinancesAndAccounts: boolean
  volunteerFrontend: boolean
  volunteerLawyer: boolean
  volunteerMarketing: boolean
  volunteerProjectManager: boolean
  volunteerQa: boolean
  volunteerSecurity: boolean
}

/**
 * Model City
 *
 */
export type City = {
  id: string
  name: string
  postalCode: number
  countryId: string
}

/**
 * Model Country
 *
 */
export type Country = {
  id: string
  name: string
  countryCode: string
}

/**
 * Model Vault
 *
 */
export type Vault = {
  id: string
  currency: Currency
  amount: number
  campaignId: string
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Donation
 *
 */
export type Donation = {
  id: string
  type: DonationType
  status: DonationStatus
  provider: PaymentProvider
  personId: string | null
  currency: Currency
  amount: number
  /**
   * Vault where the funds are going
   */
  targetVaultId: string
  /**
   * Payment provider attributes
   */
  extCustomerId: string
  extPaymentIntentId: string
  extPaymentMethodId: string
  /**
   *
   */
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model RecurringDonation
 * Donate on monthly basis
 */
export type RecurringDonation = {
  id: string
  status: RecurringDonationStatus
  vaultId: string
  personId: string
  currency: Currency
  amount: number
  /**
   * Payment provider Subscription id
   */
  extSubscriptionId: string
  extCustomerId: string | null
  /**
   *
   */
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Transfer
 * Move funds from one vault to another
 */
export type Transfer = {
  id: string
  status: TransferStatus
  currency: Currency
  amount: number
  reason: string
  /**
   * Source vault
   */
  sourceVaultId: string
  sourceCampaignId: string
  /**
   * Destination vault
   */
  targetVaultId: string
  targetCampaignId: string
  approvedById: string | null
  documentId: string | null
  targetDate: Date | null
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Withdrawal
 * Remove funds from a vault to given bank account
 */
export type Withdrawal = {
  id: string
  status: WithdrawStatus
  currency: Currency
  amount: number
  reason: string
  /**
   * Source vault
   */
  sourceVaultId: string
  sourceCampaignId: string
  /**
   * Destination bank account
   */
  bankAccountId: string
  documentId: string | null
  approvedById: string | null
  targetDate: Date | null
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model BankAccount
 *
 */
export type BankAccount = {
  id: string
  status: BankAccountStatus
  /**
   * IBAN number
   */
  ibanNumber: string
  /**
   * Name of account holder
   */
  accountHolderName: string
  /**
   * Company or individual
   */
  accountHolderType: AccountHolderType
  /**
   * Bank name
   */
  bankName: string | null
  /**
   * Bank Identification Code, BIC/SWIFT code
   */
  bankIdCode: string | null
  fingerprint: string | null
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Expense
 * Pay for something from a given vault
 */
export type Expense = {
  id: string
  type: ExpenseType
  currency: Currency
  amount: number
  description: string | null
  vaultId: string
  documentId: string | null
  approvedById: string | null
}

/**
 * Model Document
 *
 */
export type Document = {
  id: string
  type: DocumentType
  name: string
  filename: string
  filetype: string | null
  description: string | null
  /**
   * Data storage source url
   */
  sourceUrl: string
  /**
   * Person who uploaded the document
   */
  ownerId: string
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const BeneficiaryType: {
  individual: 'individual',
  company: 'company'
};

export type BeneficiaryType = (typeof BeneficiaryType)[keyof typeof BeneficiaryType]


export const PersonRelation: {
  none: 'none',
  myself: 'myself',
  myorg: 'myorg',
  parent: 'parent',
  spouse: 'spouse',
  child: 'child',
  mother: 'mother',
  father: 'father',
  brother: 'brother',
  sister: 'sister',
  friend: 'friend',
  relative: 'relative',
  partner: 'partner',
  domesticPartner: 'domesticPartner',
  manager: 'manager',
  assistant: 'assistant',
  colleague: 'colleague'
};

export type PersonRelation = (typeof PersonRelation)[keyof typeof PersonRelation]


export const CampaignState: {
  initial: 'initial',
  draft: 'draft',
  pending_validation: 'pending_validation',
  approved: 'approved',
  rejected: 'rejected',
  active: 'active',
  active_pending_validation: 'active_pending_validation',
  suspended: 'suspended',
  complete: 'complete',
  disabled: 'disabled',
  error: 'error',
  deleted: 'deleted'
};

export type CampaignState = (typeof CampaignState)[keyof typeof CampaignState]


export const Currency: {
  BGN: 'BGN',
  EUR: 'EUR',
  USD: 'USD'
};

export type Currency = (typeof Currency)[keyof typeof Currency]


export const DonationType: {
  donation: 'donation'
};

export type DonationType = (typeof DonationType)[keyof typeof DonationType]


export const DonationStatus: {
  initial: 'initial',
  invalid: 'invalid',
  incomplete: 'incomplete',
  declined: 'declined',
  waiting: 'waiting',
  cancelled: 'cancelled',
  succeeded: 'succeeded',
  deleted: 'deleted',
  refund: 'refund',
  paymentRequested: 'paymentRequested'
};

export type DonationStatus = (typeof DonationStatus)[keyof typeof DonationStatus]


export const PaymentProvider: {
  none: 'none',
  stripe: 'stripe',
  paypal: 'paypal',
  epay: 'epay',
  bank: 'bank',
  cash: 'cash'
};

export type PaymentProvider = (typeof PaymentProvider)[keyof typeof PaymentProvider]


export const RecurringDonationStatus: {
  trialing: 'trialing',
  active: 'active',
  canceled: 'canceled',
  incomplete: 'incomplete',
  incompleteExpired: 'incompleteExpired',
  pastDue: 'pastDue',
  unpaid: 'unpaid'
};

export type RecurringDonationStatus = (typeof RecurringDonationStatus)[keyof typeof RecurringDonationStatus]


export const TransferStatus: {
  initial: 'initial',
  invalid: 'invalid',
  incomplete: 'incomplete',
  declined: 'declined',
  cancelled: 'cancelled',
  succeeded: 'succeeded'
};

export type TransferStatus = (typeof TransferStatus)[keyof typeof TransferStatus]


export const WithdrawStatus: {
  initial: 'initial',
  invalid: 'invalid',
  incomplete: 'incomplete',
  declined: 'declined',
  cancelled: 'cancelled',
  succeeded: 'succeeded'
};

export type WithdrawStatus = (typeof WithdrawStatus)[keyof typeof WithdrawStatus]


export const BankAccountStatus: {
  new: 'new',
  validated: 'validated',
  verified: 'verified',
  verification_failed: 'verification_failed',
  errored: 'errored'
};

export type BankAccountStatus = (typeof BankAccountStatus)[keyof typeof BankAccountStatus]


export const AccountHolderType: {
  individual: 'individual',
  company: 'company'
};

export type AccountHolderType = (typeof AccountHolderType)[keyof typeof AccountHolderType]


export const ExpenseType: {
  none: 'none',
  internal: 'internal',
  operating: 'operating',
  administrative: 'administrative',
  medical: 'medical',
  services: 'services',
  groceries: 'groceries',
  transport: 'transport',
  accommodation: 'accommodation',
  shipping: 'shipping',
  utility: 'utility',
  rental: 'rental',
  legal: 'legal',
  bank: 'bank',
  advertising: 'advertising',
  other: 'other'
};

export type ExpenseType = (typeof ExpenseType)[keyof typeof ExpenseType]


export const DocumentType: {
  invoice: 'invoice',
  receipt: 'receipt',
  medical_record: 'medical_record',
  other: 'other'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more People
 * const people = await prisma.person.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more People
   * const people = await prisma.person.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


      /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): Prisma.PersonDelegate<GlobalReject>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<GlobalReject>;

  /**
   * `prisma.coordinator`: Exposes CRUD operations for the **Coordinator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coordinators
    * const coordinators = await prisma.coordinator.findMany()
    * ```
    */
  get coordinator(): Prisma.CoordinatorDelegate<GlobalReject>;

  /**
   * `prisma.benefactor`: Exposes CRUD operations for the **Benefactor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Benefactors
    * const benefactors = await prisma.benefactor.findMany()
    * ```
    */
  get benefactor(): Prisma.BenefactorDelegate<GlobalReject>;

  /**
   * `prisma.beneficiary`: Exposes CRUD operations for the **Beneficiary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Beneficiaries
    * const beneficiaries = await prisma.beneficiary.findMany()
    * ```
    */
  get beneficiary(): Prisma.BeneficiaryDelegate<GlobalReject>;

  /**
   * `prisma.campaignType`: Exposes CRUD operations for the **CampaignType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignTypes
    * const campaignTypes = await prisma.campaignType.findMany()
    * ```
    */
  get campaignType(): Prisma.CampaignTypeDelegate<GlobalReject>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<GlobalReject>;

  /**
   * `prisma.infoRequest`: Exposes CRUD operations for the **InfoRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InfoRequests
    * const infoRequests = await prisma.infoRequest.findMany()
    * ```
    */
  get infoRequest(): Prisma.InfoRequestDelegate<GlobalReject>;

  /**
   * `prisma.supporter`: Exposes CRUD operations for the **Supporter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Supporters
    * const supporters = await prisma.supporter.findMany()
    * ```
    */
  get supporter(): Prisma.SupporterDelegate<GlobalReject>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<GlobalReject>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<GlobalReject>;

  /**
   * `prisma.vault`: Exposes CRUD operations for the **Vault** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vaults
    * const vaults = await prisma.vault.findMany()
    * ```
    */
  get vault(): Prisma.VaultDelegate<GlobalReject>;

  /**
   * `prisma.donation`: Exposes CRUD operations for the **Donation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donations
    * const donations = await prisma.donation.findMany()
    * ```
    */
  get donation(): Prisma.DonationDelegate<GlobalReject>;

  /**
   * `prisma.recurringDonation`: Exposes CRUD operations for the **RecurringDonation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringDonations
    * const recurringDonations = await prisma.recurringDonation.findMany()
    * ```
    */
  get recurringDonation(): Prisma.RecurringDonationDelegate<GlobalReject>;

  /**
   * `prisma.transfer`: Exposes CRUD operations for the **Transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfer.findMany()
    * ```
    */
  get transfer(): Prisma.TransferDelegate<GlobalReject>;

  /**
   * `prisma.withdrawal`: Exposes CRUD operations for the **Withdrawal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Withdrawals
    * const withdrawals = await prisma.withdrawal.findMany()
    * ```
    */
  get withdrawal(): Prisma.WithdrawalDelegate<GlobalReject>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<GlobalReject>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<GlobalReject>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.8.1
   * Query Engine version: 34df67547cf5598f5a6cd3eb45f14ee70c3fb86f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> =
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Person: 'Person',
    Company: 'Company',
    Coordinator: 'Coordinator',
    Benefactor: 'Benefactor',
    Beneficiary: 'Beneficiary',
    CampaignType: 'CampaignType',
    Campaign: 'Campaign',
    InfoRequest: 'InfoRequest',
    Supporter: 'Supporter',
    City: 'City',
    Country: 'Country',
    Vault: 'Vault',
    Donation: 'Donation',
    RecurringDonation: 'RecurringDonation',
    Transfer: 'Transfer',
    Withdrawal: 'Withdrawal',
    BankAccount: 'BankAccount',
    Expense: 'Expense',
    Document: 'Document'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound }
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null.
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PersonCountOutputType
   */


  export type PersonCountOutputType = {
    Donation: number
    expenses: number
    documents: number
    transfers: number
    campaigns: number
    supporters: number
    benefactors: number
    withdrawals: number
    beneficiaries: number
    infoRequests: number
    coordinators: number
    recurringDonations: number
  }

  export type PersonCountOutputTypeSelect = {
    Donation?: boolean
    expenses?: boolean
    documents?: boolean
    transfers?: boolean
    campaigns?: boolean
    supporters?: boolean
    benefactors?: boolean
    withdrawals?: boolean
    beneficiaries?: boolean
    infoRequests?: boolean
    coordinators?: boolean
    recurringDonations?: boolean
  }

  export type PersonCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PersonCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PersonCountOutputType
    : S extends undefined
    ? never
    : S extends PersonCountOutputTypeArgs
    ?'include' extends U
    ? PersonCountOutputType
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PersonCountOutputType ?PersonCountOutputType [P]
  :
     never
  }
    : PersonCountOutputType
  : PersonCountOutputType




  // Custom InputTypes

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PersonCountOutputType
     *
    **/
    select?: PersonCountOutputTypeSelect | null
  }



  /**
   * Count Type CompanyCountOutputType
   */


  export type CompanyCountOutputType = {
    beneficiaries: number
  }

  export type CompanyCountOutputTypeSelect = {
    beneficiaries?: boolean
  }

  export type CompanyCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CompanyCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CompanyCountOutputType
    : S extends undefined
    ? never
    : S extends CompanyCountOutputTypeArgs
    ?'include' extends U
    ? CompanyCountOutputType
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CompanyCountOutputType ?CompanyCountOutputType [P]
  :
     never
  }
    : CompanyCountOutputType
  : CompanyCountOutputType




  // Custom InputTypes

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     *
    **/
    select?: CompanyCountOutputTypeSelect | null
  }



  /**
   * Count Type CoordinatorCountOutputType
   */


  export type CoordinatorCountOutputType = {
    beneficiaries: number
  }

  export type CoordinatorCountOutputTypeSelect = {
    beneficiaries?: boolean
  }

  export type CoordinatorCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CoordinatorCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CoordinatorCountOutputType
    : S extends undefined
    ? never
    : S extends CoordinatorCountOutputTypeArgs
    ?'include' extends U
    ? CoordinatorCountOutputType
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CoordinatorCountOutputType ?CoordinatorCountOutputType [P]
  :
     never
  }
    : CoordinatorCountOutputType
  : CoordinatorCountOutputType




  // Custom InputTypes

  /**
   * CoordinatorCountOutputType without action
   */
  export type CoordinatorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CoordinatorCountOutputType
     *
    **/
    select?: CoordinatorCountOutputTypeSelect | null
  }



  /**
   * Count Type BeneficiaryCountOutputType
   */


  export type BeneficiaryCountOutputType = {
    campaigns: number
  }

  export type BeneficiaryCountOutputTypeSelect = {
    campaigns?: boolean
  }

  export type BeneficiaryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | BeneficiaryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? BeneficiaryCountOutputType
    : S extends undefined
    ? never
    : S extends BeneficiaryCountOutputTypeArgs
    ?'include' extends U
    ? BeneficiaryCountOutputType
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof BeneficiaryCountOutputType ?BeneficiaryCountOutputType [P]
  :
     never
  }
    : BeneficiaryCountOutputType
  : BeneficiaryCountOutputType




  // Custom InputTypes

  /**
   * BeneficiaryCountOutputType without action
   */
  export type BeneficiaryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BeneficiaryCountOutputType
     *
    **/
    select?: BeneficiaryCountOutputTypeSelect | null
  }



  /**
   * Count Type CampaignTypeCountOutputType
   */


  export type CampaignTypeCountOutputType = {
    children: number
    campaigns: number
  }

  export type CampaignTypeCountOutputTypeSelect = {
    children?: boolean
    campaigns?: boolean
  }

  export type CampaignTypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CampaignTypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CampaignTypeCountOutputType
    : S extends undefined
    ? never
    : S extends CampaignTypeCountOutputTypeArgs
    ?'include' extends U
    ? CampaignTypeCountOutputType
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CampaignTypeCountOutputType ?CampaignTypeCountOutputType [P]
  :
     never
  }
    : CampaignTypeCountOutputType
  : CampaignTypeCountOutputType




  // Custom InputTypes

  /**
   * CampaignTypeCountOutputType without action
   */
  export type CampaignTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CampaignTypeCountOutputType
     *
    **/
    select?: CampaignTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type CampaignCountOutputType
   */


  export type CampaignCountOutputType = {
    vaults: number
    incomingTransfers: number
    outgoingTransfers: number
    withdrawals: number
  }

  export type CampaignCountOutputTypeSelect = {
    vaults?: boolean
    incomingTransfers?: boolean
    outgoingTransfers?: boolean
    withdrawals?: boolean
  }

  export type CampaignCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CampaignCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CampaignCountOutputType
    : S extends undefined
    ? never
    : S extends CampaignCountOutputTypeArgs
    ?'include' extends U
    ? CampaignCountOutputType
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CampaignCountOutputType ?CampaignCountOutputType [P]
  :
     never
  }
    : CampaignCountOutputType
  : CampaignCountOutputType




  // Custom InputTypes

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     *
    **/
    select?: CampaignCountOutputTypeSelect | null
  }



  /**
   * Count Type CityCountOutputType
   */


  export type CityCountOutputType = {
    beneficiaries: number
  }

  export type CityCountOutputTypeSelect = {
    beneficiaries?: boolean
  }

  export type CityCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CityCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CityCountOutputType
    : S extends undefined
    ? never
    : S extends CityCountOutputTypeArgs
    ?'include' extends U
    ? CityCountOutputType
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CityCountOutputType ?CityCountOutputType [P]
  :
     never
  }
    : CityCountOutputType
  : CityCountOutputType




  // Custom InputTypes

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     *
    **/
    select?: CityCountOutputTypeSelect | null
  }



  /**
   * Count Type CountryCountOutputType
   */


  export type CountryCountOutputType = {
    cities: number
  }

  export type CountryCountOutputTypeSelect = {
    cities?: boolean
  }

  export type CountryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CountryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CountryCountOutputType
    : S extends undefined
    ? never
    : S extends CountryCountOutputTypeArgs
    ?'include' extends U
    ? CountryCountOutputType
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CountryCountOutputType ?CountryCountOutputType [P]
  :
     never
  }
    : CountryCountOutputType
  : CountryCountOutputType




  // Custom InputTypes

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     *
    **/
    select?: CountryCountOutputTypeSelect | null
  }



  /**
   * Count Type VaultCountOutputType
   */


  export type VaultCountOutputType = {
    expenses: number
    sourceTransfers: number
    targetTransfers: number
    donations: number
    withdraws: number
    recurringDonations: number
  }

  export type VaultCountOutputTypeSelect = {
    expenses?: boolean
    sourceTransfers?: boolean
    targetTransfers?: boolean
    donations?: boolean
    withdraws?: boolean
    recurringDonations?: boolean
  }

  export type VaultCountOutputTypeGetPayload<
    S extends boolean | null | undefined | VaultCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? VaultCountOutputType
    : S extends undefined
    ? never
    : S extends VaultCountOutputTypeArgs
    ?'include' extends U
    ? VaultCountOutputType
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof VaultCountOutputType ?VaultCountOutputType [P]
  :
     never
  }
    : VaultCountOutputType
  : VaultCountOutputType




  // Custom InputTypes

  /**
   * VaultCountOutputType without action
   */
  export type VaultCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VaultCountOutputType
     *
    **/
    select?: VaultCountOutputTypeSelect | null
  }



  /**
   * Count Type BankAccountCountOutputType
   */


  export type BankAccountCountOutputType = {
    withdraws: number
  }

  export type BankAccountCountOutputTypeSelect = {
    withdraws?: boolean
  }

  export type BankAccountCountOutputTypeGetPayload<
    S extends boolean | null | undefined | BankAccountCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? BankAccountCountOutputType
    : S extends undefined
    ? never
    : S extends BankAccountCountOutputTypeArgs
    ?'include' extends U
    ? BankAccountCountOutputType
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof BankAccountCountOutputType ?BankAccountCountOutputType [P]
  :
     never
  }
    : BankAccountCountOutputType
  : BankAccountCountOutputType




  // Custom InputTypes

  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BankAccountCountOutputType
     *
    **/
    select?: BankAccountCountOutputTypeSelect | null
  }



  /**
   * Count Type DocumentCountOutputType
   */


  export type DocumentCountOutputType = {
    expenses: number
  }

  export type DocumentCountOutputTypeSelect = {
    expenses?: boolean
  }

  export type DocumentCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DocumentCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DocumentCountOutputType
    : S extends undefined
    ? never
    : S extends DocumentCountOutputTypeArgs
    ?'include' extends U
    ? DocumentCountOutputType
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DocumentCountOutputType ?DocumentCountOutputType [P]
  :
     never
  }
    : DocumentCountOutputType
  : DocumentCountOutputType




  // Custom InputTypes

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     *
    **/
    select?: DocumentCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Person
   */


  export type AggregatePerson = {
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  export type PersonMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    emailConfirmed: boolean | null
    phone: string | null
    company: string | null
    createdAt: Date | null
    updatedAt: Date | null
    newsletter: boolean | null
    address: string | null
    birthday: Date | null
    personalNumber: string | null
    keycloakId: string | null
    stripeCustomerId: string | null
  }

  export type PersonMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    emailConfirmed: boolean | null
    phone: string | null
    company: string | null
    createdAt: Date | null
    updatedAt: Date | null
    newsletter: boolean | null
    address: string | null
    birthday: Date | null
    personalNumber: string | null
    keycloakId: string | null
    stripeCustomerId: string | null
  }

  export type PersonCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    emailConfirmed: number
    phone: number
    company: number
    createdAt: number
    updatedAt: number
    newsletter: number
    address: number
    birthday: number
    personalNumber: number
    keycloakId: number
    stripeCustomerId: number
    _all: number
  }


  export type PersonMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    emailConfirmed?: true
    phone?: true
    company?: true
    createdAt?: true
    updatedAt?: true
    newsletter?: true
    address?: true
    birthday?: true
    personalNumber?: true
    keycloakId?: true
    stripeCustomerId?: true
  }

  export type PersonMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    emailConfirmed?: true
    phone?: true
    company?: true
    createdAt?: true
    updatedAt?: true
    newsletter?: true
    address?: true
    birthday?: true
    personalNumber?: true
    keycloakId?: true
    stripeCustomerId?: true
  }

  export type PersonCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    emailConfirmed?: true
    phone?: true
    company?: true
    createdAt?: true
    updatedAt?: true
    newsletter?: true
    address?: true
    birthday?: true
    personalNumber?: true
    keycloakId?: true
    stripeCustomerId?: true
    _all?: true
  }

  export type PersonAggregateArgs = {
    /**
     * Filter which Person to aggregate.
     *
    **/
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of People to fetch.
     *
    **/
    orderBy?: Enumerable<PersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` People from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` People.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned People
    **/
    _count?: true | PersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: PersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: PersonMaxAggregateInputType
  }

  export type GetPersonAggregateType<T extends PersonAggregateArgs> = {
        [P in keyof T & keyof AggregatePerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerson[P]>
      : GetScalarType<T[P], AggregatePerson[P]>
  }




  export type PersonGroupByArgs = {
    where?: PersonWhereInput
    orderBy?: Enumerable<PersonOrderByWithAggregationInput>
    by: Array<PersonScalarFieldEnum>
    having?: PersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonCountAggregateInputType | true
    _min?: PersonMinAggregateInputType
    _max?: PersonMaxAggregateInputType
  }


  export type PersonGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed: boolean | null
    phone: string | null
    company: string | null
    createdAt: Date
    updatedAt: Date | null
    newsletter: boolean | null
    address: string | null
    birthday: Date | null
    personalNumber: string | null
    keycloakId: string | null
    stripeCustomerId: string | null
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  type GetPersonGroupByPayload<T extends PersonGroupByArgs> = Promise<
    Array<
      PickArray<PersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonGroupByOutputType[P]>
            : GetScalarType<T[P], PersonGroupByOutputType[P]>
        }
      >
    >


  export type PersonSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailConfirmed?: boolean
    phone?: boolean
    company?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    newsletter?: boolean
    address?: boolean
    birthday?: boolean
    personalNumber?: boolean
    keycloakId?: boolean
    stripeCustomerId?: boolean
    Donation?: boolean | DonationFindManyArgs
    expenses?: boolean | ExpenseFindManyArgs
    documents?: boolean | DocumentFindManyArgs
    transfers?: boolean | TransferFindManyArgs
    campaigns?: boolean | CampaignFindManyArgs
    supporters?: boolean | SupporterFindManyArgs
    benefactors?: boolean | BenefactorFindManyArgs
    withdrawals?: boolean | WithdrawalFindManyArgs
    beneficiaries?: boolean | BeneficiaryFindManyArgs
    infoRequests?: boolean | InfoRequestFindManyArgs
    coordinators?: boolean | CoordinatorFindManyArgs
    recurringDonations?: boolean | RecurringDonationFindManyArgs
    _count?: boolean | PersonCountOutputTypeArgs
  }

  export type PersonInclude = {
    Donation?: boolean | DonationFindManyArgs
    expenses?: boolean | ExpenseFindManyArgs
    documents?: boolean | DocumentFindManyArgs
    transfers?: boolean | TransferFindManyArgs
    campaigns?: boolean | CampaignFindManyArgs
    supporters?: boolean | SupporterFindManyArgs
    benefactors?: boolean | BenefactorFindManyArgs
    withdrawals?: boolean | WithdrawalFindManyArgs
    beneficiaries?: boolean | BeneficiaryFindManyArgs
    infoRequests?: boolean | InfoRequestFindManyArgs
    coordinators?: boolean | CoordinatorFindManyArgs
    recurringDonations?: boolean | RecurringDonationFindManyArgs
    _count?: boolean | PersonCountOutputTypeArgs
  }

  export type PersonGetPayload<
    S extends boolean | null | undefined | PersonArgs,
    U = keyof S
      > = S extends true
        ? Person
    : S extends undefined
    ? never
    : S extends PersonArgs | PersonFindManyArgs
    ?'include' extends U
    ? Person  & {
    [P in TrueKeys<S['include']>]:
          P extends 'Donation'
        ? Array < DonationGetPayload<S['include'][P]>>  :
        P extends 'expenses'
        ? Array < ExpenseGetPayload<S['include'][P]>>  :
        P extends 'documents'
        ? Array < DocumentGetPayload<S['include'][P]>>  :
        P extends 'transfers'
        ? Array < TransferGetPayload<S['include'][P]>>  :
        P extends 'campaigns'
        ? Array < CampaignGetPayload<S['include'][P]>>  :
        P extends 'supporters'
        ? Array < SupporterGetPayload<S['include'][P]>>  :
        P extends 'benefactors'
        ? Array < BenefactorGetPayload<S['include'][P]>>  :
        P extends 'withdrawals'
        ? Array < WithdrawalGetPayload<S['include'][P]>>  :
        P extends 'beneficiaries'
        ? Array < BeneficiaryGetPayload<S['include'][P]>>  :
        P extends 'infoRequests'
        ? Array < InfoRequestGetPayload<S['include'][P]>>  :
        P extends 'coordinators'
        ? Array < CoordinatorGetPayload<S['include'][P]>>  :
        P extends 'recurringDonations'
        ? Array < RecurringDonationGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? PersonCountOutputTypeGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Person ?Person [P]
  :
          P extends 'Donation'
        ? Array < DonationGetPayload<S['select'][P]>>  :
        P extends 'expenses'
        ? Array < ExpenseGetPayload<S['select'][P]>>  :
        P extends 'documents'
        ? Array < DocumentGetPayload<S['select'][P]>>  :
        P extends 'transfers'
        ? Array < TransferGetPayload<S['select'][P]>>  :
        P extends 'campaigns'
        ? Array < CampaignGetPayload<S['select'][P]>>  :
        P extends 'supporters'
        ? Array < SupporterGetPayload<S['select'][P]>>  :
        P extends 'benefactors'
        ? Array < BenefactorGetPayload<S['select'][P]>>  :
        P extends 'withdrawals'
        ? Array < WithdrawalGetPayload<S['select'][P]>>  :
        P extends 'beneficiaries'
        ? Array < BeneficiaryGetPayload<S['select'][P]>>  :
        P extends 'infoRequests'
        ? Array < InfoRequestGetPayload<S['select'][P]>>  :
        P extends 'coordinators'
        ? Array < CoordinatorGetPayload<S['select'][P]>>  :
        P extends 'recurringDonations'
        ? Array < RecurringDonationGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? PersonCountOutputTypeGetPayload<S['select'][P]> : never
  }
    : Person
  : Person


  type PersonCountArgs = Merge<
    Omit<PersonFindManyArgs, 'select' | 'include'> & {
      select?: PersonCountAggregateInputType | true
    }
  >

  export interface PersonDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Person that matches the filter.
     * @param {PersonFindUniqueArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PersonFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PersonFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Person'> extends True ? CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>> : CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>

    /**
     * Find the first Person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PersonFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PersonFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Person'> extends True ? CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>> : CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>

    /**
     * Find zero or more People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all People
     * const people = await prisma.person.findMany()
     *
     * // Get first 10 People
     * const people = await prisma.person.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const personWithIdOnly = await prisma.person.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends PersonFindManyArgs>(
      args?: SelectSubset<T, PersonFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Person>>, PrismaPromise<Array<PersonGetPayload<T>>>>

    /**
     * Create a Person.
     * @param {PersonCreateArgs} args - Arguments to create a Person.
     * @example
     * // Create one Person
     * const Person = await prisma.person.create({
     *   data: {
     *     // ... data to create a Person
     *   }
     * })
     *
    **/
    create<T extends PersonCreateArgs>(
      args: SelectSubset<T, PersonCreateArgs>
    ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>

    /**
     * Create many People.
     *     @param {PersonCreateManyArgs} args - Arguments to create many People.
     *     @example
     *     // Create many People
     *     const person = await prisma.person.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends PersonCreateManyArgs>(
      args?: SelectSubset<T, PersonCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Person.
     * @param {PersonDeleteArgs} args - Arguments to delete one Person.
     * @example
     * // Delete one Person
     * const Person = await prisma.person.delete({
     *   where: {
     *     // ... filter to delete one Person
     *   }
     * })
     *
    **/
    delete<T extends PersonDeleteArgs>(
      args: SelectSubset<T, PersonDeleteArgs>
    ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>

    /**
     * Update one Person.
     * @param {PersonUpdateArgs} args - Arguments to update one Person.
     * @example
     * // Update one Person
     * const person = await prisma.person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends PersonUpdateArgs>(
      args: SelectSubset<T, PersonUpdateArgs>
    ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>

    /**
     * Delete zero or more People.
     * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
     * @example
     * // Delete a few People
     * const { count } = await prisma.person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends PersonDeleteManyArgs>(
      args?: SelectSubset<T, PersonDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many People
     * const person = await prisma.person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends PersonUpdateManyArgs>(
      args: SelectSubset<T, PersonUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Person.
     * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
     * @example
     * // Update or create a Person
     * const person = await prisma.person.upsert({
     *   create: {
     *     // ... data to create a Person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Person we want to update
     *   }
     * })
    **/
    upsert<T extends PersonUpsertArgs>(
      args: SelectSubset<T, PersonUpsertArgs>
    ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>

    /**
     * Count the number of People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonCountArgs} args - Arguments to filter People to count.
     * @example
     * // Count the number of People
     * const count = await prisma.person.count({
     *   where: {
     *     // ... the filter for the People we want to count
     *   }
     * })
    **/
    count<T extends PersonCountArgs>(
      args?: Subset<T, PersonCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonAggregateArgs>(args: Subset<T, PersonAggregateArgs>): PrismaPromise<GetPersonAggregateType<T>>

    /**
     * Group by Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends PersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonGroupByArgs['orderBy'] }
        : { orderBy?: PersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PersonClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Donation<T extends DonationFindManyArgs = {}>(args?: Subset<T, DonationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Donation>>, PrismaPromise<Array<DonationGetPayload<T>>>>;

    expenses<T extends ExpenseFindManyArgs = {}>(args?: Subset<T, ExpenseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Expense>>, PrismaPromise<Array<ExpenseGetPayload<T>>>>;

    documents<T extends DocumentFindManyArgs = {}>(args?: Subset<T, DocumentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Document>>, PrismaPromise<Array<DocumentGetPayload<T>>>>;

    transfers<T extends TransferFindManyArgs = {}>(args?: Subset<T, TransferFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Transfer>>, PrismaPromise<Array<TransferGetPayload<T>>>>;

    campaigns<T extends CampaignFindManyArgs = {}>(args?: Subset<T, CampaignFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Campaign>>, PrismaPromise<Array<CampaignGetPayload<T>>>>;

    supporters<T extends SupporterFindManyArgs = {}>(args?: Subset<T, SupporterFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Supporter>>, PrismaPromise<Array<SupporterGetPayload<T>>>>;

    benefactors<T extends BenefactorFindManyArgs = {}>(args?: Subset<T, BenefactorFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Benefactor>>, PrismaPromise<Array<BenefactorGetPayload<T>>>>;

    withdrawals<T extends WithdrawalFindManyArgs = {}>(args?: Subset<T, WithdrawalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Withdrawal>>, PrismaPromise<Array<WithdrawalGetPayload<T>>>>;

    beneficiaries<T extends BeneficiaryFindManyArgs = {}>(args?: Subset<T, BeneficiaryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Beneficiary>>, PrismaPromise<Array<BeneficiaryGetPayload<T>>>>;

    infoRequests<T extends InfoRequestFindManyArgs = {}>(args?: Subset<T, InfoRequestFindManyArgs>): CheckSelect<T, PrismaPromise<Array<InfoRequest>>, PrismaPromise<Array<InfoRequestGetPayload<T>>>>;

    coordinators<T extends CoordinatorFindManyArgs = {}>(args?: Subset<T, CoordinatorFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Coordinator>>, PrismaPromise<Array<CoordinatorGetPayload<T>>>>;

    recurringDonations<T extends RecurringDonationFindManyArgs = {}>(args?: Subset<T, RecurringDonationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecurringDonation>>, PrismaPromise<Array<RecurringDonationGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Person findUnique
   */
  export type PersonFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Person
     *
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: PersonInclude | null
    /**
     * Throw an Error if a Person can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Person to fetch.
     *
    **/
    where: PersonWhereUniqueInput
  }


  /**
   * Person findFirst
   */
  export type PersonFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Person
     *
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: PersonInclude | null
    /**
     * Throw an Error if a Person can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Person to fetch.
     *
    **/
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of People to fetch.
     *
    **/
    orderBy?: Enumerable<PersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for People.
     *
    **/
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` People from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` People.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of People.
     *
    **/
    distinct?: Enumerable<PersonScalarFieldEnum>
  }


  /**
   * Person findMany
   */
  export type PersonFindManyArgs = {
    /**
     * Select specific fields to fetch from the Person
     *
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: PersonInclude | null
    /**
     * Filter, which People to fetch.
     *
    **/
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of People to fetch.
     *
    **/
    orderBy?: Enumerable<PersonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing People.
     *
    **/
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` People from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` People.
     *
    **/
    skip?: number
    distinct?: Enumerable<PersonScalarFieldEnum>
  }


  /**
   * Person create
   */
  export type PersonCreateArgs = {
    /**
     * Select specific fields to fetch from the Person
     *
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: PersonInclude | null
    /**
     * The data needed to create a Person.
     *
    **/
    data: XOR<PersonCreateInput, PersonUncheckedCreateInput>
  }


  /**
   * Person createMany
   */
  export type PersonCreateManyArgs = {
    data: Enumerable<PersonCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Person update
   */
  export type PersonUpdateArgs = {
    /**
     * Select specific fields to fetch from the Person
     *
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: PersonInclude | null
    /**
     * The data needed to update a Person.
     *
    **/
    data: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
    /**
     * Choose, which Person to update.
     *
    **/
    where: PersonWhereUniqueInput
  }


  /**
   * Person updateMany
   */
  export type PersonUpdateManyArgs = {
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    where?: PersonWhereInput
  }


  /**
   * Person upsert
   */
  export type PersonUpsertArgs = {
    /**
     * Select specific fields to fetch from the Person
     *
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: PersonInclude | null
    /**
     * The filter to search for the Person to update in case it exists.
     *
    **/
    where: PersonWhereUniqueInput
    /**
     * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
     *
    **/
    create: XOR<PersonCreateInput, PersonUncheckedCreateInput>
    /**
     * In case the Person was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
  }


  /**
   * Person delete
   */
  export type PersonDeleteArgs = {
    /**
     * Select specific fields to fetch from the Person
     *
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: PersonInclude | null
    /**
     * Filter which Person to delete.
     *
    **/
    where: PersonWhereUniqueInput
  }


  /**
   * Person deleteMany
   */
  export type PersonDeleteManyArgs = {
    where?: PersonWhereInput
  }


  /**
   * Person without action
   */
  export type PersonArgs = {
    /**
     * Select specific fields to fetch from the Person
     *
    **/
    select?: PersonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: PersonInclude | null
  }



  /**
   * Model Company
   */


  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    companyName: string | null
    companyNumber: string | null
    legalPersonName: string | null
    countryCode: string | null
    cityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    companyName: string | null
    companyNumber: string | null
    legalPersonName: string | null
    countryCode: string | null
    cityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    companyName: number
    companyNumber: number
    legalPersonName: number
    countryCode: number
    cityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    companyName?: true
    companyNumber?: true
    legalPersonName?: true
    countryCode?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    companyName?: true
    companyNumber?: true
    legalPersonName?: true
    countryCode?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    companyName?: true
    companyNumber?: true
    legalPersonName?: true
    countryCode?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs = {
    /**
     * Filter which Company to aggregate.
     *
    **/
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Companies to fetch.
     *
    **/
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Companies from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Companies.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs = {
    where?: CompanyWhereInput
    orderBy?: Enumerable<CompanyOrderByWithAggregationInput>
    by: Array<CompanyScalarFieldEnum>
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }


  export type CompanyGroupByOutputType = {
    id: string
    companyName: string
    companyNumber: string
    legalPersonName: string | null
    countryCode: string | null
    cityId: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Promise<
    Array<
      PickArray<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect = {
    id?: boolean
    companyName?: boolean
    companyNumber?: boolean
    legalPersonName?: boolean
    countryCode?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    beneficiaries?: boolean | BeneficiaryFindManyArgs
    _count?: boolean | CompanyCountOutputTypeArgs
  }

  export type CompanyInclude = {
    beneficiaries?: boolean | BeneficiaryFindManyArgs
    _count?: boolean | CompanyCountOutputTypeArgs
  }

  export type CompanyGetPayload<
    S extends boolean | null | undefined | CompanyArgs,
    U = keyof S
      > = S extends true
        ? Company
    : S extends undefined
    ? never
    : S extends CompanyArgs | CompanyFindManyArgs
    ?'include' extends U
    ? Company  & {
    [P in TrueKeys<S['include']>]:
          P extends 'beneficiaries'
        ? Array < BeneficiaryGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CompanyCountOutputTypeGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Company ?Company [P]
  :
          P extends 'beneficiaries'
        ? Array < BeneficiaryGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CompanyCountOutputTypeGetPayload<S['select'][P]> : never
  }
    : Company
  : Company


  type CompanyCountArgs = Merge<
    Omit<CompanyFindManyArgs, 'select' | 'include'> & {
      select?: CompanyCountAggregateInputType | true
    }
  >

  export interface CompanyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CompanyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Company'> extends True ? CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>> : CheckSelect<T, Prisma__CompanyClient<Company | null >, Prisma__CompanyClient<CompanyGetPayload<T> | null >>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CompanyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Company'> extends True ? CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>> : CheckSelect<T, Prisma__CompanyClient<Company | null >, Prisma__CompanyClient<CompanyGetPayload<T> | null >>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     *
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends CompanyFindManyArgs>(
      args?: SelectSubset<T, CompanyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Company>>, PrismaPromise<Array<CompanyGetPayload<T>>>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     *
    **/
    create<T extends CompanyCreateArgs>(
      args: SelectSubset<T, CompanyCreateArgs>
    ): CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>>

    /**
     * Create many Companies.
     *     @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     *     @example
     *     // Create many Companies
     *     const company = await prisma.company.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends CompanyCreateManyArgs>(
      args?: SelectSubset<T, CompanyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     *
    **/
    delete<T extends CompanyDeleteArgs>(
      args: SelectSubset<T, CompanyDeleteArgs>
    ): CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends CompanyUpdateArgs>(
      args: SelectSubset<T, CompanyUpdateArgs>
    ): CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends CompanyDeleteManyArgs>(
      args?: SelectSubset<T, CompanyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends CompanyUpdateManyArgs>(
      args: SelectSubset<T, CompanyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyUpsertArgs>(
      args: SelectSubset<T, CompanyUpsertArgs>
    ): CheckSelect<T, Prisma__CompanyClient<Company>, Prisma__CompanyClient<CompanyGetPayload<T>>>

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CompanyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    beneficiaries<T extends BeneficiaryFindManyArgs = {}>(args?: Subset<T, BeneficiaryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Beneficiary>>, PrismaPromise<Array<BeneficiaryGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Company
     *
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CompanyInclude | null
    /**
     * Throw an Error if a Company can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Company to fetch.
     *
    **/
    where: CompanyWhereUniqueInput
  }


  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Company
     *
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CompanyInclude | null
    /**
     * Throw an Error if a Company can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Company to fetch.
     *
    **/
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Companies to fetch.
     *
    **/
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Companies.
     *
    **/
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Companies from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Companies.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Companies.
     *
    **/
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * Company findMany
   */
  export type CompanyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Company
     *
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CompanyInclude | null
    /**
     * Filter, which Companies to fetch.
     *
    **/
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Companies to fetch.
     *
    **/
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Companies.
     *
    **/
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Companies from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Companies.
     *
    **/
    skip?: number
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * Company create
   */
  export type CompanyCreateArgs = {
    /**
     * Select specific fields to fetch from the Company
     *
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CompanyInclude | null
    /**
     * The data needed to create a Company.
     *
    **/
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }


  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs = {
    data: Enumerable<CompanyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Company update
   */
  export type CompanyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Company
     *
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CompanyInclude | null
    /**
     * The data needed to update a Company.
     *
    **/
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     *
    **/
    where: CompanyWhereUniqueInput
  }


  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs = {
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    where?: CompanyWhereInput
  }


  /**
   * Company upsert
   */
  export type CompanyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Company
     *
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CompanyInclude | null
    /**
     * The filter to search for the Company to update in case it exists.
     *
    **/
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     *
    **/
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }


  /**
   * Company delete
   */
  export type CompanyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Company
     *
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CompanyInclude | null
    /**
     * Filter which Company to delete.
     *
    **/
    where: CompanyWhereUniqueInput
  }


  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs = {
    where?: CompanyWhereInput
  }


  /**
   * Company without action
   */
  export type CompanyArgs = {
    /**
     * Select specific fields to fetch from the Company
     *
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CompanyInclude | null
  }



  /**
   * Model Coordinator
   */


  export type AggregateCoordinator = {
    _count: CoordinatorCountAggregateOutputType | null
    _min: CoordinatorMinAggregateOutputType | null
    _max: CoordinatorMaxAggregateOutputType | null
  }

  export type CoordinatorMinAggregateOutputType = {
    id: string | null
    personId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoordinatorMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoordinatorCountAggregateOutputType = {
    id: number
    personId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoordinatorMinAggregateInputType = {
    id?: true
    personId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoordinatorMaxAggregateInputType = {
    id?: true
    personId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoordinatorCountAggregateInputType = {
    id?: true
    personId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoordinatorAggregateArgs = {
    /**
     * Filter which Coordinator to aggregate.
     *
    **/
    where?: CoordinatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Coordinators to fetch.
     *
    **/
    orderBy?: Enumerable<CoordinatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: CoordinatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Coordinators from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Coordinators.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Coordinators
    **/
    _count?: true | CoordinatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CoordinatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CoordinatorMaxAggregateInputType
  }

  export type GetCoordinatorAggregateType<T extends CoordinatorAggregateArgs> = {
        [P in keyof T & keyof AggregateCoordinator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoordinator[P]>
      : GetScalarType<T[P], AggregateCoordinator[P]>
  }




  export type CoordinatorGroupByArgs = {
    where?: CoordinatorWhereInput
    orderBy?: Enumerable<CoordinatorOrderByWithAggregationInput>
    by: Array<CoordinatorScalarFieldEnum>
    having?: CoordinatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoordinatorCountAggregateInputType | true
    _min?: CoordinatorMinAggregateInputType
    _max?: CoordinatorMaxAggregateInputType
  }


  export type CoordinatorGroupByOutputType = {
    id: string
    personId: string
    createdAt: Date
    updatedAt: Date | null
    _count: CoordinatorCountAggregateOutputType | null
    _min: CoordinatorMinAggregateOutputType | null
    _max: CoordinatorMaxAggregateOutputType | null
  }

  type GetCoordinatorGroupByPayload<T extends CoordinatorGroupByArgs> = Promise<
    Array<
      PickArray<CoordinatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoordinatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoordinatorGroupByOutputType[P]>
            : GetScalarType<T[P], CoordinatorGroupByOutputType[P]>
        }
      >
    >


  export type CoordinatorSelect = {
    id?: boolean
    personId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonArgs
    beneficiaries?: boolean | BeneficiaryFindManyArgs
    _count?: boolean | CoordinatorCountOutputTypeArgs
  }

  export type CoordinatorInclude = {
    person?: boolean | PersonArgs
    beneficiaries?: boolean | BeneficiaryFindManyArgs
    _count?: boolean | CoordinatorCountOutputTypeArgs
  }

  export type CoordinatorGetPayload<
    S extends boolean | null | undefined | CoordinatorArgs,
    U = keyof S
      > = S extends true
        ? Coordinator
    : S extends undefined
    ? never
    : S extends CoordinatorArgs | CoordinatorFindManyArgs
    ?'include' extends U
    ? Coordinator  & {
    [P in TrueKeys<S['include']>]:
          P extends 'person'
        ? PersonGetPayload<S['include'][P]> :
        P extends 'beneficiaries'
        ? Array < BeneficiaryGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CoordinatorCountOutputTypeGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Coordinator ?Coordinator [P]
  :
          P extends 'person'
        ? PersonGetPayload<S['select'][P]> :
        P extends 'beneficiaries'
        ? Array < BeneficiaryGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CoordinatorCountOutputTypeGetPayload<S['select'][P]> : never
  }
    : Coordinator
  : Coordinator


  type CoordinatorCountArgs = Merge<
    Omit<CoordinatorFindManyArgs, 'select' | 'include'> & {
      select?: CoordinatorCountAggregateInputType | true
    }
  >

  export interface CoordinatorDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Coordinator that matches the filter.
     * @param {CoordinatorFindUniqueArgs} args - Arguments to find a Coordinator
     * @example
     * // Get one Coordinator
     * const coordinator = await prisma.coordinator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CoordinatorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CoordinatorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Coordinator'> extends True ? CheckSelect<T, Prisma__CoordinatorClient<Coordinator>, Prisma__CoordinatorClient<CoordinatorGetPayload<T>>> : CheckSelect<T, Prisma__CoordinatorClient<Coordinator | null >, Prisma__CoordinatorClient<CoordinatorGetPayload<T> | null >>

    /**
     * Find the first Coordinator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordinatorFindFirstArgs} args - Arguments to find a Coordinator
     * @example
     * // Get one Coordinator
     * const coordinator = await prisma.coordinator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CoordinatorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CoordinatorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Coordinator'> extends True ? CheckSelect<T, Prisma__CoordinatorClient<Coordinator>, Prisma__CoordinatorClient<CoordinatorGetPayload<T>>> : CheckSelect<T, Prisma__CoordinatorClient<Coordinator | null >, Prisma__CoordinatorClient<CoordinatorGetPayload<T> | null >>

    /**
     * Find zero or more Coordinators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordinatorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coordinators
     * const coordinators = await prisma.coordinator.findMany()
     *
     * // Get first 10 Coordinators
     * const coordinators = await prisma.coordinator.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const coordinatorWithIdOnly = await prisma.coordinator.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends CoordinatorFindManyArgs>(
      args?: SelectSubset<T, CoordinatorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Coordinator>>, PrismaPromise<Array<CoordinatorGetPayload<T>>>>

    /**
     * Create a Coordinator.
     * @param {CoordinatorCreateArgs} args - Arguments to create a Coordinator.
     * @example
     * // Create one Coordinator
     * const Coordinator = await prisma.coordinator.create({
     *   data: {
     *     // ... data to create a Coordinator
     *   }
     * })
     *
    **/
    create<T extends CoordinatorCreateArgs>(
      args: SelectSubset<T, CoordinatorCreateArgs>
    ): CheckSelect<T, Prisma__CoordinatorClient<Coordinator>, Prisma__CoordinatorClient<CoordinatorGetPayload<T>>>

    /**
     * Create many Coordinators.
     *     @param {CoordinatorCreateManyArgs} args - Arguments to create many Coordinators.
     *     @example
     *     // Create many Coordinators
     *     const coordinator = await prisma.coordinator.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends CoordinatorCreateManyArgs>(
      args?: SelectSubset<T, CoordinatorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Coordinator.
     * @param {CoordinatorDeleteArgs} args - Arguments to delete one Coordinator.
     * @example
     * // Delete one Coordinator
     * const Coordinator = await prisma.coordinator.delete({
     *   where: {
     *     // ... filter to delete one Coordinator
     *   }
     * })
     *
    **/
    delete<T extends CoordinatorDeleteArgs>(
      args: SelectSubset<T, CoordinatorDeleteArgs>
    ): CheckSelect<T, Prisma__CoordinatorClient<Coordinator>, Prisma__CoordinatorClient<CoordinatorGetPayload<T>>>

    /**
     * Update one Coordinator.
     * @param {CoordinatorUpdateArgs} args - Arguments to update one Coordinator.
     * @example
     * // Update one Coordinator
     * const coordinator = await prisma.coordinator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends CoordinatorUpdateArgs>(
      args: SelectSubset<T, CoordinatorUpdateArgs>
    ): CheckSelect<T, Prisma__CoordinatorClient<Coordinator>, Prisma__CoordinatorClient<CoordinatorGetPayload<T>>>

    /**
     * Delete zero or more Coordinators.
     * @param {CoordinatorDeleteManyArgs} args - Arguments to filter Coordinators to delete.
     * @example
     * // Delete a few Coordinators
     * const { count } = await prisma.coordinator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends CoordinatorDeleteManyArgs>(
      args?: SelectSubset<T, CoordinatorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coordinators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordinatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coordinators
     * const coordinator = await prisma.coordinator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends CoordinatorUpdateManyArgs>(
      args: SelectSubset<T, CoordinatorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Coordinator.
     * @param {CoordinatorUpsertArgs} args - Arguments to update or create a Coordinator.
     * @example
     * // Update or create a Coordinator
     * const coordinator = await prisma.coordinator.upsert({
     *   create: {
     *     // ... data to create a Coordinator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coordinator we want to update
     *   }
     * })
    **/
    upsert<T extends CoordinatorUpsertArgs>(
      args: SelectSubset<T, CoordinatorUpsertArgs>
    ): CheckSelect<T, Prisma__CoordinatorClient<Coordinator>, Prisma__CoordinatorClient<CoordinatorGetPayload<T>>>

    /**
     * Count the number of Coordinators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordinatorCountArgs} args - Arguments to filter Coordinators to count.
     * @example
     * // Count the number of Coordinators
     * const count = await prisma.coordinator.count({
     *   where: {
     *     // ... the filter for the Coordinators we want to count
     *   }
     * })
    **/
    count<T extends CoordinatorCountArgs>(
      args?: Subset<T, CoordinatorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoordinatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coordinator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordinatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoordinatorAggregateArgs>(args: Subset<T, CoordinatorAggregateArgs>): PrismaPromise<GetCoordinatorAggregateType<T>>

    /**
     * Group by Coordinator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoordinatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CoordinatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoordinatorGroupByArgs['orderBy'] }
        : { orderBy?: CoordinatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoordinatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoordinatorGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coordinator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CoordinatorClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    beneficiaries<T extends BeneficiaryFindManyArgs = {}>(args?: Subset<T, BeneficiaryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Beneficiary>>, PrismaPromise<Array<BeneficiaryGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Coordinator findUnique
   */
  export type CoordinatorFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Coordinator
     *
    **/
    select?: CoordinatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CoordinatorInclude | null
    /**
     * Throw an Error if a Coordinator can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Coordinator to fetch.
     *
    **/
    where: CoordinatorWhereUniqueInput
  }


  /**
   * Coordinator findFirst
   */
  export type CoordinatorFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Coordinator
     *
    **/
    select?: CoordinatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CoordinatorInclude | null
    /**
     * Throw an Error if a Coordinator can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Coordinator to fetch.
     *
    **/
    where?: CoordinatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Coordinators to fetch.
     *
    **/
    orderBy?: Enumerable<CoordinatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Coordinators.
     *
    **/
    cursor?: CoordinatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Coordinators from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Coordinators.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Coordinators.
     *
    **/
    distinct?: Enumerable<CoordinatorScalarFieldEnum>
  }


  /**
   * Coordinator findMany
   */
  export type CoordinatorFindManyArgs = {
    /**
     * Select specific fields to fetch from the Coordinator
     *
    **/
    select?: CoordinatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CoordinatorInclude | null
    /**
     * Filter, which Coordinators to fetch.
     *
    **/
    where?: CoordinatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Coordinators to fetch.
     *
    **/
    orderBy?: Enumerable<CoordinatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Coordinators.
     *
    **/
    cursor?: CoordinatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Coordinators from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Coordinators.
     *
    **/
    skip?: number
    distinct?: Enumerable<CoordinatorScalarFieldEnum>
  }


  /**
   * Coordinator create
   */
  export type CoordinatorCreateArgs = {
    /**
     * Select specific fields to fetch from the Coordinator
     *
    **/
    select?: CoordinatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CoordinatorInclude | null
    /**
     * The data needed to create a Coordinator.
     *
    **/
    data: XOR<CoordinatorCreateInput, CoordinatorUncheckedCreateInput>
  }


  /**
   * Coordinator createMany
   */
  export type CoordinatorCreateManyArgs = {
    data: Enumerable<CoordinatorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Coordinator update
   */
  export type CoordinatorUpdateArgs = {
    /**
     * Select specific fields to fetch from the Coordinator
     *
    **/
    select?: CoordinatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CoordinatorInclude | null
    /**
     * The data needed to update a Coordinator.
     *
    **/
    data: XOR<CoordinatorUpdateInput, CoordinatorUncheckedUpdateInput>
    /**
     * Choose, which Coordinator to update.
     *
    **/
    where: CoordinatorWhereUniqueInput
  }


  /**
   * Coordinator updateMany
   */
  export type CoordinatorUpdateManyArgs = {
    data: XOR<CoordinatorUpdateManyMutationInput, CoordinatorUncheckedUpdateManyInput>
    where?: CoordinatorWhereInput
  }


  /**
   * Coordinator upsert
   */
  export type CoordinatorUpsertArgs = {
    /**
     * Select specific fields to fetch from the Coordinator
     *
    **/
    select?: CoordinatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CoordinatorInclude | null
    /**
     * The filter to search for the Coordinator to update in case it exists.
     *
    **/
    where: CoordinatorWhereUniqueInput
    /**
     * In case the Coordinator found by the `where` argument doesn't exist, create a new Coordinator with this data.
     *
    **/
    create: XOR<CoordinatorCreateInput, CoordinatorUncheckedCreateInput>
    /**
     * In case the Coordinator was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<CoordinatorUpdateInput, CoordinatorUncheckedUpdateInput>
  }


  /**
   * Coordinator delete
   */
  export type CoordinatorDeleteArgs = {
    /**
     * Select specific fields to fetch from the Coordinator
     *
    **/
    select?: CoordinatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CoordinatorInclude | null
    /**
     * Filter which Coordinator to delete.
     *
    **/
    where: CoordinatorWhereUniqueInput
  }


  /**
   * Coordinator deleteMany
   */
  export type CoordinatorDeleteManyArgs = {
    where?: CoordinatorWhereInput
  }


  /**
   * Coordinator without action
   */
  export type CoordinatorArgs = {
    /**
     * Select specific fields to fetch from the Coordinator
     *
    **/
    select?: CoordinatorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CoordinatorInclude | null
  }



  /**
   * Model Benefactor
   */


  export type AggregateBenefactor = {
    _count: BenefactorCountAggregateOutputType | null
    _min: BenefactorMinAggregateOutputType | null
    _max: BenefactorMaxAggregateOutputType | null
  }

  export type BenefactorMinAggregateOutputType = {
    id: string | null
    personId: string | null
    extCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BenefactorMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    extCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BenefactorCountAggregateOutputType = {
    id: number
    personId: number
    extCustomerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BenefactorMinAggregateInputType = {
    id?: true
    personId?: true
    extCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BenefactorMaxAggregateInputType = {
    id?: true
    personId?: true
    extCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BenefactorCountAggregateInputType = {
    id?: true
    personId?: true
    extCustomerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BenefactorAggregateArgs = {
    /**
     * Filter which Benefactor to aggregate.
     *
    **/
    where?: BenefactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Benefactors to fetch.
     *
    **/
    orderBy?: Enumerable<BenefactorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: BenefactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Benefactors from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Benefactors.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Benefactors
    **/
    _count?: true | BenefactorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: BenefactorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: BenefactorMaxAggregateInputType
  }

  export type GetBenefactorAggregateType<T extends BenefactorAggregateArgs> = {
        [P in keyof T & keyof AggregateBenefactor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBenefactor[P]>
      : GetScalarType<T[P], AggregateBenefactor[P]>
  }




  export type BenefactorGroupByArgs = {
    where?: BenefactorWhereInput
    orderBy?: Enumerable<BenefactorOrderByWithAggregationInput>
    by: Array<BenefactorScalarFieldEnum>
    having?: BenefactorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BenefactorCountAggregateInputType | true
    _min?: BenefactorMinAggregateInputType
    _max?: BenefactorMaxAggregateInputType
  }


  export type BenefactorGroupByOutputType = {
    id: string
    personId: string
    extCustomerId: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: BenefactorCountAggregateOutputType | null
    _min: BenefactorMinAggregateOutputType | null
    _max: BenefactorMaxAggregateOutputType | null
  }

  type GetBenefactorGroupByPayload<T extends BenefactorGroupByArgs> = Promise<
    Array<
      PickArray<BenefactorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BenefactorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BenefactorGroupByOutputType[P]>
            : GetScalarType<T[P], BenefactorGroupByOutputType[P]>
        }
      >
    >


  export type BenefactorSelect = {
    id?: boolean
    personId?: boolean
    extCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    person?: boolean | PersonArgs
  }

  export type BenefactorInclude = {
    person?: boolean | PersonArgs
  }

  export type BenefactorGetPayload<
    S extends boolean | null | undefined | BenefactorArgs,
    U = keyof S
      > = S extends true
        ? Benefactor
    : S extends undefined
    ? never
    : S extends BenefactorArgs | BenefactorFindManyArgs
    ?'include' extends U
    ? Benefactor  & {
    [P in TrueKeys<S['include']>]:
          P extends 'person'
        ? PersonGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Benefactor ?Benefactor [P]
  :
          P extends 'person'
        ? PersonGetPayload<S['select'][P]> : never
  }
    : Benefactor
  : Benefactor


  type BenefactorCountArgs = Merge<
    Omit<BenefactorFindManyArgs, 'select' | 'include'> & {
      select?: BenefactorCountAggregateInputType | true
    }
  >

  export interface BenefactorDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Benefactor that matches the filter.
     * @param {BenefactorFindUniqueArgs} args - Arguments to find a Benefactor
     * @example
     * // Get one Benefactor
     * const benefactor = await prisma.benefactor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BenefactorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BenefactorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Benefactor'> extends True ? CheckSelect<T, Prisma__BenefactorClient<Benefactor>, Prisma__BenefactorClient<BenefactorGetPayload<T>>> : CheckSelect<T, Prisma__BenefactorClient<Benefactor | null >, Prisma__BenefactorClient<BenefactorGetPayload<T> | null >>

    /**
     * Find the first Benefactor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefactorFindFirstArgs} args - Arguments to find a Benefactor
     * @example
     * // Get one Benefactor
     * const benefactor = await prisma.benefactor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BenefactorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BenefactorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Benefactor'> extends True ? CheckSelect<T, Prisma__BenefactorClient<Benefactor>, Prisma__BenefactorClient<BenefactorGetPayload<T>>> : CheckSelect<T, Prisma__BenefactorClient<Benefactor | null >, Prisma__BenefactorClient<BenefactorGetPayload<T> | null >>

    /**
     * Find zero or more Benefactors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefactorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Benefactors
     * const benefactors = await prisma.benefactor.findMany()
     *
     * // Get first 10 Benefactors
     * const benefactors = await prisma.benefactor.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const benefactorWithIdOnly = await prisma.benefactor.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends BenefactorFindManyArgs>(
      args?: SelectSubset<T, BenefactorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Benefactor>>, PrismaPromise<Array<BenefactorGetPayload<T>>>>

    /**
     * Create a Benefactor.
     * @param {BenefactorCreateArgs} args - Arguments to create a Benefactor.
     * @example
     * // Create one Benefactor
     * const Benefactor = await prisma.benefactor.create({
     *   data: {
     *     // ... data to create a Benefactor
     *   }
     * })
     *
    **/
    create<T extends BenefactorCreateArgs>(
      args: SelectSubset<T, BenefactorCreateArgs>
    ): CheckSelect<T, Prisma__BenefactorClient<Benefactor>, Prisma__BenefactorClient<BenefactorGetPayload<T>>>

    /**
     * Create many Benefactors.
     *     @param {BenefactorCreateManyArgs} args - Arguments to create many Benefactors.
     *     @example
     *     // Create many Benefactors
     *     const benefactor = await prisma.benefactor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends BenefactorCreateManyArgs>(
      args?: SelectSubset<T, BenefactorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Benefactor.
     * @param {BenefactorDeleteArgs} args - Arguments to delete one Benefactor.
     * @example
     * // Delete one Benefactor
     * const Benefactor = await prisma.benefactor.delete({
     *   where: {
     *     // ... filter to delete one Benefactor
     *   }
     * })
     *
    **/
    delete<T extends BenefactorDeleteArgs>(
      args: SelectSubset<T, BenefactorDeleteArgs>
    ): CheckSelect<T, Prisma__BenefactorClient<Benefactor>, Prisma__BenefactorClient<BenefactorGetPayload<T>>>

    /**
     * Update one Benefactor.
     * @param {BenefactorUpdateArgs} args - Arguments to update one Benefactor.
     * @example
     * // Update one Benefactor
     * const benefactor = await prisma.benefactor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends BenefactorUpdateArgs>(
      args: SelectSubset<T, BenefactorUpdateArgs>
    ): CheckSelect<T, Prisma__BenefactorClient<Benefactor>, Prisma__BenefactorClient<BenefactorGetPayload<T>>>

    /**
     * Delete zero or more Benefactors.
     * @param {BenefactorDeleteManyArgs} args - Arguments to filter Benefactors to delete.
     * @example
     * // Delete a few Benefactors
     * const { count } = await prisma.benefactor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends BenefactorDeleteManyArgs>(
      args?: SelectSubset<T, BenefactorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Benefactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefactorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Benefactors
     * const benefactor = await prisma.benefactor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends BenefactorUpdateManyArgs>(
      args: SelectSubset<T, BenefactorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Benefactor.
     * @param {BenefactorUpsertArgs} args - Arguments to update or create a Benefactor.
     * @example
     * // Update or create a Benefactor
     * const benefactor = await prisma.benefactor.upsert({
     *   create: {
     *     // ... data to create a Benefactor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Benefactor we want to update
     *   }
     * })
    **/
    upsert<T extends BenefactorUpsertArgs>(
      args: SelectSubset<T, BenefactorUpsertArgs>
    ): CheckSelect<T, Prisma__BenefactorClient<Benefactor>, Prisma__BenefactorClient<BenefactorGetPayload<T>>>

    /**
     * Count the number of Benefactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefactorCountArgs} args - Arguments to filter Benefactors to count.
     * @example
     * // Count the number of Benefactors
     * const count = await prisma.benefactor.count({
     *   where: {
     *     // ... the filter for the Benefactors we want to count
     *   }
     * })
    **/
    count<T extends BenefactorCountArgs>(
      args?: Subset<T, BenefactorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BenefactorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Benefactor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefactorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BenefactorAggregateArgs>(args: Subset<T, BenefactorAggregateArgs>): PrismaPromise<GetBenefactorAggregateType<T>>

    /**
     * Group by Benefactor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefactorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends BenefactorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BenefactorGroupByArgs['orderBy'] }
        : { orderBy?: BenefactorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BenefactorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBenefactorGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Benefactor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BenefactorClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Benefactor findUnique
   */
  export type BenefactorFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Benefactor
     *
    **/
    select?: BenefactorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BenefactorInclude | null
    /**
     * Throw an Error if a Benefactor can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Benefactor to fetch.
     *
    **/
    where: BenefactorWhereUniqueInput
  }


  /**
   * Benefactor findFirst
   */
  export type BenefactorFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Benefactor
     *
    **/
    select?: BenefactorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BenefactorInclude | null
    /**
     * Throw an Error if a Benefactor can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Benefactor to fetch.
     *
    **/
    where?: BenefactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Benefactors to fetch.
     *
    **/
    orderBy?: Enumerable<BenefactorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Benefactors.
     *
    **/
    cursor?: BenefactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Benefactors from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Benefactors.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Benefactors.
     *
    **/
    distinct?: Enumerable<BenefactorScalarFieldEnum>
  }


  /**
   * Benefactor findMany
   */
  export type BenefactorFindManyArgs = {
    /**
     * Select specific fields to fetch from the Benefactor
     *
    **/
    select?: BenefactorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BenefactorInclude | null
    /**
     * Filter, which Benefactors to fetch.
     *
    **/
    where?: BenefactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Benefactors to fetch.
     *
    **/
    orderBy?: Enumerable<BenefactorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Benefactors.
     *
    **/
    cursor?: BenefactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Benefactors from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Benefactors.
     *
    **/
    skip?: number
    distinct?: Enumerable<BenefactorScalarFieldEnum>
  }


  /**
   * Benefactor create
   */
  export type BenefactorCreateArgs = {
    /**
     * Select specific fields to fetch from the Benefactor
     *
    **/
    select?: BenefactorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BenefactorInclude | null
    /**
     * The data needed to create a Benefactor.
     *
    **/
    data: XOR<BenefactorCreateInput, BenefactorUncheckedCreateInput>
  }


  /**
   * Benefactor createMany
   */
  export type BenefactorCreateManyArgs = {
    data: Enumerable<BenefactorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Benefactor update
   */
  export type BenefactorUpdateArgs = {
    /**
     * Select specific fields to fetch from the Benefactor
     *
    **/
    select?: BenefactorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BenefactorInclude | null
    /**
     * The data needed to update a Benefactor.
     *
    **/
    data: XOR<BenefactorUpdateInput, BenefactorUncheckedUpdateInput>
    /**
     * Choose, which Benefactor to update.
     *
    **/
    where: BenefactorWhereUniqueInput
  }


  /**
   * Benefactor updateMany
   */
  export type BenefactorUpdateManyArgs = {
    data: XOR<BenefactorUpdateManyMutationInput, BenefactorUncheckedUpdateManyInput>
    where?: BenefactorWhereInput
  }


  /**
   * Benefactor upsert
   */
  export type BenefactorUpsertArgs = {
    /**
     * Select specific fields to fetch from the Benefactor
     *
    **/
    select?: BenefactorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BenefactorInclude | null
    /**
     * The filter to search for the Benefactor to update in case it exists.
     *
    **/
    where: BenefactorWhereUniqueInput
    /**
     * In case the Benefactor found by the `where` argument doesn't exist, create a new Benefactor with this data.
     *
    **/
    create: XOR<BenefactorCreateInput, BenefactorUncheckedCreateInput>
    /**
     * In case the Benefactor was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<BenefactorUpdateInput, BenefactorUncheckedUpdateInput>
  }


  /**
   * Benefactor delete
   */
  export type BenefactorDeleteArgs = {
    /**
     * Select specific fields to fetch from the Benefactor
     *
    **/
    select?: BenefactorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BenefactorInclude | null
    /**
     * Filter which Benefactor to delete.
     *
    **/
    where: BenefactorWhereUniqueInput
  }


  /**
   * Benefactor deleteMany
   */
  export type BenefactorDeleteManyArgs = {
    where?: BenefactorWhereInput
  }


  /**
   * Benefactor without action
   */
  export type BenefactorArgs = {
    /**
     * Select specific fields to fetch from the Benefactor
     *
    **/
    select?: BenefactorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BenefactorInclude | null
  }



  /**
   * Model Beneficiary
   */


  export type AggregateBeneficiary = {
    _count: BeneficiaryCountAggregateOutputType | null
    _min: BeneficiaryMinAggregateOutputType | null
    _max: BeneficiaryMaxAggregateOutputType | null
  }

  export type BeneficiaryMinAggregateOutputType = {
    id: string | null
    type: BeneficiaryType | null
    personId: string | null
    companyId: string | null
    coordinatorId: string | null
    countryCode: string | null
    cityId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    coordinatorRelation: PersonRelation | null
  }

  export type BeneficiaryMaxAggregateOutputType = {
    id: string | null
    type: BeneficiaryType | null
    personId: string | null
    companyId: string | null
    coordinatorId: string | null
    countryCode: string | null
    cityId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    coordinatorRelation: PersonRelation | null
  }

  export type BeneficiaryCountAggregateOutputType = {
    id: number
    type: number
    personId: number
    companyId: number
    coordinatorId: number
    countryCode: number
    cityId: number
    description: number
    publicData: number
    privateData: number
    createdAt: number
    updatedAt: number
    coordinatorRelation: number
    _all: number
  }


  export type BeneficiaryMinAggregateInputType = {
    id?: true
    type?: true
    personId?: true
    companyId?: true
    coordinatorId?: true
    countryCode?: true
    cityId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    coordinatorRelation?: true
  }

  export type BeneficiaryMaxAggregateInputType = {
    id?: true
    type?: true
    personId?: true
    companyId?: true
    coordinatorId?: true
    countryCode?: true
    cityId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    coordinatorRelation?: true
  }

  export type BeneficiaryCountAggregateInputType = {
    id?: true
    type?: true
    personId?: true
    companyId?: true
    coordinatorId?: true
    countryCode?: true
    cityId?: true
    description?: true
    publicData?: true
    privateData?: true
    createdAt?: true
    updatedAt?: true
    coordinatorRelation?: true
    _all?: true
  }

  export type BeneficiaryAggregateArgs = {
    /**
     * Filter which Beneficiary to aggregate.
     *
    **/
    where?: BeneficiaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Beneficiaries to fetch.
     *
    **/
    orderBy?: Enumerable<BeneficiaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: BeneficiaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Beneficiaries from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Beneficiaries.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Beneficiaries
    **/
    _count?: true | BeneficiaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: BeneficiaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: BeneficiaryMaxAggregateInputType
  }

  export type GetBeneficiaryAggregateType<T extends BeneficiaryAggregateArgs> = {
        [P in keyof T & keyof AggregateBeneficiary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBeneficiary[P]>
      : GetScalarType<T[P], AggregateBeneficiary[P]>
  }




  export type BeneficiaryGroupByArgs = {
    where?: BeneficiaryWhereInput
    orderBy?: Enumerable<BeneficiaryOrderByWithAggregationInput>
    by: Array<BeneficiaryScalarFieldEnum>
    having?: BeneficiaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BeneficiaryCountAggregateInputType | true
    _min?: BeneficiaryMinAggregateInputType
    _max?: BeneficiaryMaxAggregateInputType
  }


  export type BeneficiaryGroupByOutputType = {
    id: string
    type: BeneficiaryType
    personId: string | null
    companyId: string | null
    coordinatorId: string
    countryCode: string
    cityId: string
    description: string | null
    publicData: JsonValue | null
    privateData: JsonValue | null
    createdAt: Date
    updatedAt: Date | null
    coordinatorRelation: PersonRelation
    _count: BeneficiaryCountAggregateOutputType | null
    _min: BeneficiaryMinAggregateOutputType | null
    _max: BeneficiaryMaxAggregateOutputType | null
  }

  type GetBeneficiaryGroupByPayload<T extends BeneficiaryGroupByArgs> = Promise<
    Array<
      PickArray<BeneficiaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BeneficiaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BeneficiaryGroupByOutputType[P]>
            : GetScalarType<T[P], BeneficiaryGroupByOutputType[P]>
        }
      >
    >


  export type BeneficiarySelect = {
    id?: boolean
    type?: boolean
    personId?: boolean
    companyId?: boolean
    coordinatorId?: boolean
    countryCode?: boolean
    cityId?: boolean
    description?: boolean
    publicData?: boolean
    privateData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coordinatorRelation?: boolean
    city?: boolean | CityArgs
    coordinator?: boolean | CoordinatorArgs
    person?: boolean | PersonArgs
    company?: boolean | CompanyArgs
    campaigns?: boolean | CampaignFindManyArgs
    _count?: boolean | BeneficiaryCountOutputTypeArgs
  }

  export type BeneficiaryInclude = {
    city?: boolean | CityArgs
    coordinator?: boolean | CoordinatorArgs
    person?: boolean | PersonArgs
    company?: boolean | CompanyArgs
    campaigns?: boolean | CampaignFindManyArgs
    _count?: boolean | BeneficiaryCountOutputTypeArgs
  }

  export type BeneficiaryGetPayload<
    S extends boolean | null | undefined | BeneficiaryArgs,
    U = keyof S
      > = S extends true
        ? Beneficiary
    : S extends undefined
    ? never
    : S extends BeneficiaryArgs | BeneficiaryFindManyArgs
    ?'include' extends U
    ? Beneficiary  & {
    [P in TrueKeys<S['include']>]:
          P extends 'city'
        ? CityGetPayload<S['include'][P]> :
        P extends 'coordinator'
        ? CoordinatorGetPayload<S['include'][P]> :
        P extends 'person'
        ? PersonGetPayload<S['include'][P]> | null :
        P extends 'company'
        ? CompanyGetPayload<S['include'][P]> | null :
        P extends 'campaigns'
        ? Array < CampaignGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? BeneficiaryCountOutputTypeGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Beneficiary ?Beneficiary [P]
  :
          P extends 'city'
        ? CityGetPayload<S['select'][P]> :
        P extends 'coordinator'
        ? CoordinatorGetPayload<S['select'][P]> :
        P extends 'person'
        ? PersonGetPayload<S['select'][P]> | null :
        P extends 'company'
        ? CompanyGetPayload<S['select'][P]> | null :
        P extends 'campaigns'
        ? Array < CampaignGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? BeneficiaryCountOutputTypeGetPayload<S['select'][P]> : never
  }
    : Beneficiary
  : Beneficiary


  type BeneficiaryCountArgs = Merge<
    Omit<BeneficiaryFindManyArgs, 'select' | 'include'> & {
      select?: BeneficiaryCountAggregateInputType | true
    }
  >

  export interface BeneficiaryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Beneficiary that matches the filter.
     * @param {BeneficiaryFindUniqueArgs} args - Arguments to find a Beneficiary
     * @example
     * // Get one Beneficiary
     * const beneficiary = await prisma.beneficiary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BeneficiaryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BeneficiaryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Beneficiary'> extends True ? CheckSelect<T, Prisma__BeneficiaryClient<Beneficiary>, Prisma__BeneficiaryClient<BeneficiaryGetPayload<T>>> : CheckSelect<T, Prisma__BeneficiaryClient<Beneficiary | null >, Prisma__BeneficiaryClient<BeneficiaryGetPayload<T> | null >>

    /**
     * Find the first Beneficiary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryFindFirstArgs} args - Arguments to find a Beneficiary
     * @example
     * // Get one Beneficiary
     * const beneficiary = await prisma.beneficiary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BeneficiaryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BeneficiaryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Beneficiary'> extends True ? CheckSelect<T, Prisma__BeneficiaryClient<Beneficiary>, Prisma__BeneficiaryClient<BeneficiaryGetPayload<T>>> : CheckSelect<T, Prisma__BeneficiaryClient<Beneficiary | null >, Prisma__BeneficiaryClient<BeneficiaryGetPayload<T> | null >>

    /**
     * Find zero or more Beneficiaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Beneficiaries
     * const beneficiaries = await prisma.beneficiary.findMany()
     *
     * // Get first 10 Beneficiaries
     * const beneficiaries = await prisma.beneficiary.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const beneficiaryWithIdOnly = await prisma.beneficiary.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends BeneficiaryFindManyArgs>(
      args?: SelectSubset<T, BeneficiaryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Beneficiary>>, PrismaPromise<Array<BeneficiaryGetPayload<T>>>>

    /**
     * Create a Beneficiary.
     * @param {BeneficiaryCreateArgs} args - Arguments to create a Beneficiary.
     * @example
     * // Create one Beneficiary
     * const Beneficiary = await prisma.beneficiary.create({
     *   data: {
     *     // ... data to create a Beneficiary
     *   }
     * })
     *
    **/
    create<T extends BeneficiaryCreateArgs>(
      args: SelectSubset<T, BeneficiaryCreateArgs>
    ): CheckSelect<T, Prisma__BeneficiaryClient<Beneficiary>, Prisma__BeneficiaryClient<BeneficiaryGetPayload<T>>>

    /**
     * Create many Beneficiaries.
     *     @param {BeneficiaryCreateManyArgs} args - Arguments to create many Beneficiaries.
     *     @example
     *     // Create many Beneficiaries
     *     const beneficiary = await prisma.beneficiary.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends BeneficiaryCreateManyArgs>(
      args?: SelectSubset<T, BeneficiaryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Beneficiary.
     * @param {BeneficiaryDeleteArgs} args - Arguments to delete one Beneficiary.
     * @example
     * // Delete one Beneficiary
     * const Beneficiary = await prisma.beneficiary.delete({
     *   where: {
     *     // ... filter to delete one Beneficiary
     *   }
     * })
     *
    **/
    delete<T extends BeneficiaryDeleteArgs>(
      args: SelectSubset<T, BeneficiaryDeleteArgs>
    ): CheckSelect<T, Prisma__BeneficiaryClient<Beneficiary>, Prisma__BeneficiaryClient<BeneficiaryGetPayload<T>>>

    /**
     * Update one Beneficiary.
     * @param {BeneficiaryUpdateArgs} args - Arguments to update one Beneficiary.
     * @example
     * // Update one Beneficiary
     * const beneficiary = await prisma.beneficiary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends BeneficiaryUpdateArgs>(
      args: SelectSubset<T, BeneficiaryUpdateArgs>
    ): CheckSelect<T, Prisma__BeneficiaryClient<Beneficiary>, Prisma__BeneficiaryClient<BeneficiaryGetPayload<T>>>

    /**
     * Delete zero or more Beneficiaries.
     * @param {BeneficiaryDeleteManyArgs} args - Arguments to filter Beneficiaries to delete.
     * @example
     * // Delete a few Beneficiaries
     * const { count } = await prisma.beneficiary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends BeneficiaryDeleteManyArgs>(
      args?: SelectSubset<T, BeneficiaryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beneficiaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Beneficiaries
     * const beneficiary = await prisma.beneficiary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends BeneficiaryUpdateManyArgs>(
      args: SelectSubset<T, BeneficiaryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Beneficiary.
     * @param {BeneficiaryUpsertArgs} args - Arguments to update or create a Beneficiary.
     * @example
     * // Update or create a Beneficiary
     * const beneficiary = await prisma.beneficiary.upsert({
     *   create: {
     *     // ... data to create a Beneficiary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Beneficiary we want to update
     *   }
     * })
    **/
    upsert<T extends BeneficiaryUpsertArgs>(
      args: SelectSubset<T, BeneficiaryUpsertArgs>
    ): CheckSelect<T, Prisma__BeneficiaryClient<Beneficiary>, Prisma__BeneficiaryClient<BeneficiaryGetPayload<T>>>

    /**
     * Count the number of Beneficiaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryCountArgs} args - Arguments to filter Beneficiaries to count.
     * @example
     * // Count the number of Beneficiaries
     * const count = await prisma.beneficiary.count({
     *   where: {
     *     // ... the filter for the Beneficiaries we want to count
     *   }
     * })
    **/
    count<T extends BeneficiaryCountArgs>(
      args?: Subset<T, BeneficiaryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BeneficiaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Beneficiary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BeneficiaryAggregateArgs>(args: Subset<T, BeneficiaryAggregateArgs>): PrismaPromise<GetBeneficiaryAggregateType<T>>

    /**
     * Group by Beneficiary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends BeneficiaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BeneficiaryGroupByArgs['orderBy'] }
        : { orderBy?: BeneficiaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BeneficiaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBeneficiaryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Beneficiary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BeneficiaryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    city<T extends CityArgs = {}>(args?: Subset<T, CityArgs>): CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>;

    coordinator<T extends CoordinatorArgs = {}>(args?: Subset<T, CoordinatorArgs>): CheckSelect<T, Prisma__CoordinatorClient<Coordinator | null >, Prisma__CoordinatorClient<CoordinatorGetPayload<T> | null >>;

    person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    company<T extends CompanyArgs = {}>(args?: Subset<T, CompanyArgs>): CheckSelect<T, Prisma__CompanyClient<Company | null >, Prisma__CompanyClient<CompanyGetPayload<T> | null >>;

    campaigns<T extends CampaignFindManyArgs = {}>(args?: Subset<T, CampaignFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Campaign>>, PrismaPromise<Array<CampaignGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Beneficiary findUnique
   */
  export type BeneficiaryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Beneficiary
     *
    **/
    select?: BeneficiarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BeneficiaryInclude | null
    /**
     * Throw an Error if a Beneficiary can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Beneficiary to fetch.
     *
    **/
    where: BeneficiaryWhereUniqueInput
  }


  /**
   * Beneficiary findFirst
   */
  export type BeneficiaryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Beneficiary
     *
    **/
    select?: BeneficiarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BeneficiaryInclude | null
    /**
     * Throw an Error if a Beneficiary can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Beneficiary to fetch.
     *
    **/
    where?: BeneficiaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Beneficiaries to fetch.
     *
    **/
    orderBy?: Enumerable<BeneficiaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Beneficiaries.
     *
    **/
    cursor?: BeneficiaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Beneficiaries from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Beneficiaries.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Beneficiaries.
     *
    **/
    distinct?: Enumerable<BeneficiaryScalarFieldEnum>
  }


  /**
   * Beneficiary findMany
   */
  export type BeneficiaryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Beneficiary
     *
    **/
    select?: BeneficiarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BeneficiaryInclude | null
    /**
     * Filter, which Beneficiaries to fetch.
     *
    **/
    where?: BeneficiaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Beneficiaries to fetch.
     *
    **/
    orderBy?: Enumerable<BeneficiaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Beneficiaries.
     *
    **/
    cursor?: BeneficiaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Beneficiaries from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Beneficiaries.
     *
    **/
    skip?: number
    distinct?: Enumerable<BeneficiaryScalarFieldEnum>
  }


  /**
   * Beneficiary create
   */
  export type BeneficiaryCreateArgs = {
    /**
     * Select specific fields to fetch from the Beneficiary
     *
    **/
    select?: BeneficiarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BeneficiaryInclude | null
    /**
     * The data needed to create a Beneficiary.
     *
    **/
    data: XOR<BeneficiaryCreateInput, BeneficiaryUncheckedCreateInput>
  }


  /**
   * Beneficiary createMany
   */
  export type BeneficiaryCreateManyArgs = {
    data: Enumerable<BeneficiaryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Beneficiary update
   */
  export type BeneficiaryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Beneficiary
     *
    **/
    select?: BeneficiarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BeneficiaryInclude | null
    /**
     * The data needed to update a Beneficiary.
     *
    **/
    data: XOR<BeneficiaryUpdateInput, BeneficiaryUncheckedUpdateInput>
    /**
     * Choose, which Beneficiary to update.
     *
    **/
    where: BeneficiaryWhereUniqueInput
  }


  /**
   * Beneficiary updateMany
   */
  export type BeneficiaryUpdateManyArgs = {
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyInput>
    where?: BeneficiaryWhereInput
  }


  /**
   * Beneficiary upsert
   */
  export type BeneficiaryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Beneficiary
     *
    **/
    select?: BeneficiarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BeneficiaryInclude | null
    /**
     * The filter to search for the Beneficiary to update in case it exists.
     *
    **/
    where: BeneficiaryWhereUniqueInput
    /**
     * In case the Beneficiary found by the `where` argument doesn't exist, create a new Beneficiary with this data.
     *
    **/
    create: XOR<BeneficiaryCreateInput, BeneficiaryUncheckedCreateInput>
    /**
     * In case the Beneficiary was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<BeneficiaryUpdateInput, BeneficiaryUncheckedUpdateInput>
  }


  /**
   * Beneficiary delete
   */
  export type BeneficiaryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Beneficiary
     *
    **/
    select?: BeneficiarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BeneficiaryInclude | null
    /**
     * Filter which Beneficiary to delete.
     *
    **/
    where: BeneficiaryWhereUniqueInput
  }


  /**
   * Beneficiary deleteMany
   */
  export type BeneficiaryDeleteManyArgs = {
    where?: BeneficiaryWhereInput
  }


  /**
   * Beneficiary without action
   */
  export type BeneficiaryArgs = {
    /**
     * Select specific fields to fetch from the Beneficiary
     *
    **/
    select?: BeneficiarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BeneficiaryInclude | null
  }



  /**
   * Model CampaignType
   */


  export type AggregateCampaignType = {
    _count: CampaignTypeCountAggregateOutputType | null
    _min: CampaignTypeMinAggregateOutputType | null
    _max: CampaignTypeMaxAggregateOutputType | null
  }

  export type CampaignTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
  }

  export type CampaignTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
  }

  export type CampaignTypeCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    parentId: number
    _all: number
  }


  export type CampaignTypeMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
  }

  export type CampaignTypeMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
  }

  export type CampaignTypeCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    _all?: true
  }

  export type CampaignTypeAggregateArgs = {
    /**
     * Filter which CampaignType to aggregate.
     *
    **/
    where?: CampaignTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CampaignTypes to fetch.
     *
    **/
    orderBy?: Enumerable<CampaignTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: CampaignTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CampaignTypes from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CampaignTypes.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CampaignTypes
    **/
    _count?: true | CampaignTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CampaignTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CampaignTypeMaxAggregateInputType
  }

  export type GetCampaignTypeAggregateType<T extends CampaignTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignType[P]>
      : GetScalarType<T[P], AggregateCampaignType[P]>
  }




  export type CampaignTypeGroupByArgs = {
    where?: CampaignTypeWhereInput
    orderBy?: Enumerable<CampaignTypeOrderByWithAggregationInput>
    by: Array<CampaignTypeScalarFieldEnum>
    having?: CampaignTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignTypeCountAggregateInputType | true
    _min?: CampaignTypeMinAggregateInputType
    _max?: CampaignTypeMaxAggregateInputType
  }


  export type CampaignTypeGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    parentId: string | null
    _count: CampaignTypeCountAggregateOutputType | null
    _min: CampaignTypeMinAggregateOutputType | null
    _max: CampaignTypeMaxAggregateOutputType | null
  }

  type GetCampaignTypeGroupByPayload<T extends CampaignTypeGroupByArgs> = Promise<
    Array<
      PickArray<CampaignTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignTypeGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignTypeGroupByOutputType[P]>
        }
      >
    >


  export type CampaignTypeSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    parent?: boolean | CampaignTypeArgs
    children?: boolean | CampaignTypeFindManyArgs
    campaigns?: boolean | CampaignFindManyArgs
    _count?: boolean | CampaignTypeCountOutputTypeArgs
  }

  export type CampaignTypeInclude = {
    parent?: boolean | CampaignTypeArgs
    children?: boolean | CampaignTypeFindManyArgs
    campaigns?: boolean | CampaignFindManyArgs
    _count?: boolean | CampaignTypeCountOutputTypeArgs
  }

  export type CampaignTypeGetPayload<
    S extends boolean | null | undefined | CampaignTypeArgs,
    U = keyof S
      > = S extends true
        ? CampaignType
    : S extends undefined
    ? never
    : S extends CampaignTypeArgs | CampaignTypeFindManyArgs
    ?'include' extends U
    ? CampaignType  & {
    [P in TrueKeys<S['include']>]:
          P extends 'parent'
        ? CampaignTypeGetPayload<S['include'][P]> | null :
        P extends 'children'
        ? Array < CampaignTypeGetPayload<S['include'][P]>>  :
        P extends 'campaigns'
        ? Array < CampaignGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CampaignTypeCountOutputTypeGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CampaignType ?CampaignType [P]
  :
          P extends 'parent'
        ? CampaignTypeGetPayload<S['select'][P]> | null :
        P extends 'children'
        ? Array < CampaignTypeGetPayload<S['select'][P]>>  :
        P extends 'campaigns'
        ? Array < CampaignGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CampaignTypeCountOutputTypeGetPayload<S['select'][P]> : never
  }
    : CampaignType
  : CampaignType


  type CampaignTypeCountArgs = Merge<
    Omit<CampaignTypeFindManyArgs, 'select' | 'include'> & {
      select?: CampaignTypeCountAggregateInputType | true
    }
  >

  export interface CampaignTypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CampaignType that matches the filter.
     * @param {CampaignTypeFindUniqueArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CampaignType'> extends True ? CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>> : CheckSelect<T, Prisma__CampaignTypeClient<CampaignType | null >, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T> | null >>

    /**
     * Find the first CampaignType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeFindFirstArgs} args - Arguments to find a CampaignType
     * @example
     * // Get one CampaignType
     * const campaignType = await prisma.campaignType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CampaignType'> extends True ? CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>> : CheckSelect<T, Prisma__CampaignTypeClient<CampaignType | null >, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T> | null >>

    /**
     * Find zero or more CampaignTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignTypes
     * const campaignTypes = await prisma.campaignType.findMany()
     *
     * // Get first 10 CampaignTypes
     * const campaignTypes = await prisma.campaignType.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const campaignTypeWithIdOnly = await prisma.campaignType.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends CampaignTypeFindManyArgs>(
      args?: SelectSubset<T, CampaignTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CampaignType>>, PrismaPromise<Array<CampaignTypeGetPayload<T>>>>

    /**
     * Create a CampaignType.
     * @param {CampaignTypeCreateArgs} args - Arguments to create a CampaignType.
     * @example
     * // Create one CampaignType
     * const CampaignType = await prisma.campaignType.create({
     *   data: {
     *     // ... data to create a CampaignType
     *   }
     * })
     *
    **/
    create<T extends CampaignTypeCreateArgs>(
      args: SelectSubset<T, CampaignTypeCreateArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Create many CampaignTypes.
     *     @param {CampaignTypeCreateManyArgs} args - Arguments to create many CampaignTypes.
     *     @example
     *     // Create many CampaignTypes
     *     const campaignType = await prisma.campaignType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends CampaignTypeCreateManyArgs>(
      args?: SelectSubset<T, CampaignTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CampaignType.
     * @param {CampaignTypeDeleteArgs} args - Arguments to delete one CampaignType.
     * @example
     * // Delete one CampaignType
     * const CampaignType = await prisma.campaignType.delete({
     *   where: {
     *     // ... filter to delete one CampaignType
     *   }
     * })
     *
    **/
    delete<T extends CampaignTypeDeleteArgs>(
      args: SelectSubset<T, CampaignTypeDeleteArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Update one CampaignType.
     * @param {CampaignTypeUpdateArgs} args - Arguments to update one CampaignType.
     * @example
     * // Update one CampaignType
     * const campaignType = await prisma.campaignType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends CampaignTypeUpdateArgs>(
      args: SelectSubset<T, CampaignTypeUpdateArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Delete zero or more CampaignTypes.
     * @param {CampaignTypeDeleteManyArgs} args - Arguments to filter CampaignTypes to delete.
     * @example
     * // Delete a few CampaignTypes
     * const { count } = await prisma.campaignType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends CampaignTypeDeleteManyArgs>(
      args?: SelectSubset<T, CampaignTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignTypes
     * const campaignType = await prisma.campaignType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends CampaignTypeUpdateManyArgs>(
      args: SelectSubset<T, CampaignTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignType.
     * @param {CampaignTypeUpsertArgs} args - Arguments to update or create a CampaignType.
     * @example
     * // Update or create a CampaignType
     * const campaignType = await prisma.campaignType.upsert({
     *   create: {
     *     // ... data to create a CampaignType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignType we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignTypeUpsertArgs>(
      args: SelectSubset<T, CampaignTypeUpsertArgs>
    ): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType>, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T>>>

    /**
     * Count the number of CampaignTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeCountArgs} args - Arguments to filter CampaignTypes to count.
     * @example
     * // Count the number of CampaignTypes
     * const count = await prisma.campaignType.count({
     *   where: {
     *     // ... the filter for the CampaignTypes we want to count
     *   }
     * })
    **/
    count<T extends CampaignTypeCountArgs>(
      args?: Subset<T, CampaignTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignTypeAggregateArgs>(args: Subset<T, CampaignTypeAggregateArgs>): PrismaPromise<GetCampaignTypeAggregateType<T>>

    /**
     * Group by CampaignType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CampaignTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignTypeGroupByArgs['orderBy'] }
        : { orderBy?: CampaignTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignTypeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignTypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parent<T extends CampaignTypeArgs = {}>(args?: Subset<T, CampaignTypeArgs>): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType | null >, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T> | null >>;

    children<T extends CampaignTypeFindManyArgs = {}>(args?: Subset<T, CampaignTypeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CampaignType>>, PrismaPromise<Array<CampaignTypeGetPayload<T>>>>;

    campaigns<T extends CampaignFindManyArgs = {}>(args?: Subset<T, CampaignFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Campaign>>, PrismaPromise<Array<CampaignGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CampaignType findUnique
   */
  export type CampaignTypeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     *
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignTypeInclude | null
    /**
     * Throw an Error if a CampaignType can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CampaignType to fetch.
     *
    **/
    where: CampaignTypeWhereUniqueInput
  }


  /**
   * CampaignType findFirst
   */
  export type CampaignTypeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     *
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignTypeInclude | null
    /**
     * Throw an Error if a CampaignType can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CampaignType to fetch.
     *
    **/
    where?: CampaignTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CampaignTypes to fetch.
     *
    **/
    orderBy?: Enumerable<CampaignTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CampaignTypes.
     *
    **/
    cursor?: CampaignTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CampaignTypes from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CampaignTypes.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CampaignTypes.
     *
    **/
    distinct?: Enumerable<CampaignTypeScalarFieldEnum>
  }


  /**
   * CampaignType findMany
   */
  export type CampaignTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     *
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignTypeInclude | null
    /**
     * Filter, which CampaignTypes to fetch.
     *
    **/
    where?: CampaignTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CampaignTypes to fetch.
     *
    **/
    orderBy?: Enumerable<CampaignTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CampaignTypes.
     *
    **/
    cursor?: CampaignTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CampaignTypes from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CampaignTypes.
     *
    **/
    skip?: number
    distinct?: Enumerable<CampaignTypeScalarFieldEnum>
  }


  /**
   * CampaignType create
   */
  export type CampaignTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     *
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignTypeInclude | null
    /**
     * The data needed to create a CampaignType.
     *
    **/
    data: XOR<CampaignTypeCreateInput, CampaignTypeUncheckedCreateInput>
  }


  /**
   * CampaignType createMany
   */
  export type CampaignTypeCreateManyArgs = {
    data: Enumerable<CampaignTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CampaignType update
   */
  export type CampaignTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     *
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignTypeInclude | null
    /**
     * The data needed to update a CampaignType.
     *
    **/
    data: XOR<CampaignTypeUpdateInput, CampaignTypeUncheckedUpdateInput>
    /**
     * Choose, which CampaignType to update.
     *
    **/
    where: CampaignTypeWhereUniqueInput
  }


  /**
   * CampaignType updateMany
   */
  export type CampaignTypeUpdateManyArgs = {
    data: XOR<CampaignTypeUpdateManyMutationInput, CampaignTypeUncheckedUpdateManyInput>
    where?: CampaignTypeWhereInput
  }


  /**
   * CampaignType upsert
   */
  export type CampaignTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     *
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignTypeInclude | null
    /**
     * The filter to search for the CampaignType to update in case it exists.
     *
    **/
    where: CampaignTypeWhereUniqueInput
    /**
     * In case the CampaignType found by the `where` argument doesn't exist, create a new CampaignType with this data.
     *
    **/
    create: XOR<CampaignTypeCreateInput, CampaignTypeUncheckedCreateInput>
    /**
     * In case the CampaignType was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<CampaignTypeUpdateInput, CampaignTypeUncheckedUpdateInput>
  }


  /**
   * CampaignType delete
   */
  export type CampaignTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     *
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignTypeInclude | null
    /**
     * Filter which CampaignType to delete.
     *
    **/
    where: CampaignTypeWhereUniqueInput
  }


  /**
   * CampaignType deleteMany
   */
  export type CampaignTypeDeleteManyArgs = {
    where?: CampaignTypeWhereInput
  }


  /**
   * CampaignType without action
   */
  export type CampaignTypeArgs = {
    /**
     * Select specific fields to fetch from the CampaignType
     *
    **/
    select?: CampaignTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignTypeInclude | null
  }



  /**
   * Model Campaign
   */


  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    targetAmount: number | null
  }

  export type CampaignSumAggregateOutputType = {
    targetAmount: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    state: CampaignState | null
    slug: string | null
    title: string | null
    essence: string | null
    coordinatorId: string | null
    beneficiaryId: string | null
    campaignTypeId: string | null
    approvedById: string | null
    description: string | null
    targetAmount: number | null
    currency: Currency | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    state: CampaignState | null
    slug: string | null
    title: string | null
    essence: string | null
    coordinatorId: string | null
    beneficiaryId: string | null
    campaignTypeId: string | null
    approvedById: string | null
    description: string | null
    targetAmount: number | null
    currency: Currency | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    state: number
    slug: number
    title: number
    essence: number
    coordinatorId: number
    beneficiaryId: number
    campaignTypeId: number
    approvedById: number
    description: number
    targetAmount: number
    currency: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    targetAmount?: true
  }

  export type CampaignSumAggregateInputType = {
    targetAmount?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    state?: true
    slug?: true
    title?: true
    essence?: true
    coordinatorId?: true
    beneficiaryId?: true
    campaignTypeId?: true
    approvedById?: true
    description?: true
    targetAmount?: true
    currency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    state?: true
    slug?: true
    title?: true
    essence?: true
    coordinatorId?: true
    beneficiaryId?: true
    campaignTypeId?: true
    approvedById?: true
    description?: true
    targetAmount?: true
    currency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    state?: true
    slug?: true
    title?: true
    essence?: true
    coordinatorId?: true
    beneficiaryId?: true
    campaignTypeId?: true
    approvedById?: true
    description?: true
    targetAmount?: true
    currency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs = {
    /**
     * Filter which Campaign to aggregate.
     *
    **/
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Campaigns to fetch.
     *
    **/
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Campaigns from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Campaigns.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs = {
    where?: CampaignWhereInput
    orderBy?: Enumerable<CampaignOrderByWithAggregationInput>
    by: Array<CampaignScalarFieldEnum>
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }


  export type CampaignGroupByOutputType = {
    id: string
    state: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    beneficiaryId: string
    campaignTypeId: string
    approvedById: string | null
    description: string | null
    targetAmount: number | null
    currency: Currency
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date | null
    deletedAt: Date | null
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Promise<
    Array<
      PickArray<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect = {
    id?: boolean
    state?: boolean
    slug?: boolean
    title?: boolean
    essence?: boolean
    coordinatorId?: boolean
    beneficiaryId?: boolean
    campaignTypeId?: boolean
    approvedById?: boolean
    description?: boolean
    targetAmount?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    approvedBy?: boolean | PersonArgs
    beneficiaries?: boolean | BeneficiaryArgs
    campaignTypes?: boolean | CampaignTypeArgs
    vaults?: boolean | VaultFindManyArgs
    incomingTransfers?: boolean | TransferFindManyArgs
    outgoingTransfers?: boolean | TransferFindManyArgs
    withdrawals?: boolean | WithdrawalFindManyArgs
    _count?: boolean | CampaignCountOutputTypeArgs
  }

  export type CampaignInclude = {
    approvedBy?: boolean | PersonArgs
    beneficiaries?: boolean | BeneficiaryArgs
    campaignTypes?: boolean | CampaignTypeArgs
    vaults?: boolean | VaultFindManyArgs
    incomingTransfers?: boolean | TransferFindManyArgs
    outgoingTransfers?: boolean | TransferFindManyArgs
    withdrawals?: boolean | WithdrawalFindManyArgs
    _count?: boolean | CampaignCountOutputTypeArgs
  }

  export type CampaignGetPayload<
    S extends boolean | null | undefined | CampaignArgs,
    U = keyof S
      > = S extends true
        ? Campaign
    : S extends undefined
    ? never
    : S extends CampaignArgs | CampaignFindManyArgs
    ?'include' extends U
    ? Campaign  & {
    [P in TrueKeys<S['include']>]:
          P extends 'approvedBy'
        ? PersonGetPayload<S['include'][P]> | null :
        P extends 'beneficiaries'
        ? BeneficiaryGetPayload<S['include'][P]> :
        P extends 'campaignTypes'
        ? CampaignTypeGetPayload<S['include'][P]> :
        P extends 'vaults'
        ? Array < VaultGetPayload<S['include'][P]>>  :
        P extends 'incomingTransfers'
        ? Array < TransferGetPayload<S['include'][P]>>  :
        P extends 'outgoingTransfers'
        ? Array < TransferGetPayload<S['include'][P]>>  :
        P extends 'withdrawals'
        ? Array < WithdrawalGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CampaignCountOutputTypeGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Campaign ?Campaign [P]
  :
          P extends 'approvedBy'
        ? PersonGetPayload<S['select'][P]> | null :
        P extends 'beneficiaries'
        ? BeneficiaryGetPayload<S['select'][P]> :
        P extends 'campaignTypes'
        ? CampaignTypeGetPayload<S['select'][P]> :
        P extends 'vaults'
        ? Array < VaultGetPayload<S['select'][P]>>  :
        P extends 'incomingTransfers'
        ? Array < TransferGetPayload<S['select'][P]>>  :
        P extends 'outgoingTransfers'
        ? Array < TransferGetPayload<S['select'][P]>>  :
        P extends 'withdrawals'
        ? Array < WithdrawalGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CampaignCountOutputTypeGetPayload<S['select'][P]> : never
  }
    : Campaign
  : Campaign


  type CampaignCountArgs = Merge<
    Omit<CampaignFindManyArgs, 'select' | 'include'> & {
      select?: CampaignCountAggregateInputType | true
    }
  >

  export interface CampaignDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Campaign'> extends True ? CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>> : CheckSelect<T, Prisma__CampaignClient<Campaign | null >, Prisma__CampaignClient<CampaignGetPayload<T> | null >>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Campaign'> extends True ? CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>> : CheckSelect<T, Prisma__CampaignClient<Campaign | null >, Prisma__CampaignClient<CampaignGetPayload<T> | null >>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     *
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends CampaignFindManyArgs>(
      args?: SelectSubset<T, CampaignFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Campaign>>, PrismaPromise<Array<CampaignGetPayload<T>>>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     *
    **/
    create<T extends CampaignCreateArgs>(
      args: SelectSubset<T, CampaignCreateArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Create many Campaigns.
     *     @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     *     @example
     *     // Create many Campaigns
     *     const campaign = await prisma.campaign.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends CampaignCreateManyArgs>(
      args?: SelectSubset<T, CampaignCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     *
    **/
    delete<T extends CampaignDeleteArgs>(
      args: SelectSubset<T, CampaignDeleteArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends CampaignUpdateArgs>(
      args: SelectSubset<T, CampaignUpdateArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends CampaignDeleteManyArgs>(
      args?: SelectSubset<T, CampaignDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends CampaignUpdateManyArgs>(
      args: SelectSubset<T, CampaignUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignUpsertArgs>(
      args: SelectSubset<T, CampaignUpsertArgs>
    ): CheckSelect<T, Prisma__CampaignClient<Campaign>, Prisma__CampaignClient<CampaignGetPayload<T>>>

    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    approvedBy<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    beneficiaries<T extends BeneficiaryArgs = {}>(args?: Subset<T, BeneficiaryArgs>): CheckSelect<T, Prisma__BeneficiaryClient<Beneficiary | null >, Prisma__BeneficiaryClient<BeneficiaryGetPayload<T> | null >>;

    campaignTypes<T extends CampaignTypeArgs = {}>(args?: Subset<T, CampaignTypeArgs>): CheckSelect<T, Prisma__CampaignTypeClient<CampaignType | null >, Prisma__CampaignTypeClient<CampaignTypeGetPayload<T> | null >>;

    vaults<T extends VaultFindManyArgs = {}>(args?: Subset<T, VaultFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Vault>>, PrismaPromise<Array<VaultGetPayload<T>>>>;

    incomingTransfers<T extends TransferFindManyArgs = {}>(args?: Subset<T, TransferFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Transfer>>, PrismaPromise<Array<TransferGetPayload<T>>>>;

    outgoingTransfers<T extends TransferFindManyArgs = {}>(args?: Subset<T, TransferFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Transfer>>, PrismaPromise<Array<TransferGetPayload<T>>>>;

    withdrawals<T extends WithdrawalFindManyArgs = {}>(args?: Subset<T, WithdrawalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Withdrawal>>, PrismaPromise<Array<WithdrawalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     *
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignInclude | null
    /**
     * Throw an Error if a Campaign can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Campaign to fetch.
     *
    **/
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     *
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignInclude | null
    /**
     * Throw an Error if a Campaign can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Campaign to fetch.
     *
    **/
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Campaigns to fetch.
     *
    **/
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Campaigns.
     *
    **/
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Campaigns from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Campaigns.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Campaigns.
     *
    **/
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }


  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     *
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignInclude | null
    /**
     * Filter, which Campaigns to fetch.
     *
    **/
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Campaigns to fetch.
     *
    **/
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Campaigns.
     *
    **/
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Campaigns from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Campaigns.
     *
    **/
    skip?: number
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }


  /**
   * Campaign create
   */
  export type CampaignCreateArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     *
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignInclude | null
    /**
     * The data needed to create a Campaign.
     *
    **/
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }


  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs = {
    data: Enumerable<CampaignCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Campaign update
   */
  export type CampaignUpdateArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     *
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignInclude | null
    /**
     * The data needed to update a Campaign.
     *
    **/
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     *
    **/
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs = {
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    where?: CampaignWhereInput
  }


  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     *
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignInclude | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     *
    **/
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     *
    **/
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }


  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     *
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignInclude | null
    /**
     * Filter which Campaign to delete.
     *
    **/
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs = {
    where?: CampaignWhereInput
  }


  /**
   * Campaign without action
   */
  export type CampaignArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     *
    **/
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CampaignInclude | null
  }



  /**
   * Model InfoRequest
   */


  export type AggregateInfoRequest = {
    _count: InfoRequestCountAggregateOutputType | null
    _min: InfoRequestMinAggregateOutputType | null
    _max: InfoRequestMaxAggregateOutputType | null
  }

  export type InfoRequestMinAggregateOutputType = {
    id: string | null
    personId: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type InfoRequestMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type InfoRequestCountAggregateOutputType = {
    id: number
    personId: number
    message: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type InfoRequestMinAggregateInputType = {
    id?: true
    personId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type InfoRequestMaxAggregateInputType = {
    id?: true
    personId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type InfoRequestCountAggregateInputType = {
    id?: true
    personId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type InfoRequestAggregateArgs = {
    /**
     * Filter which InfoRequest to aggregate.
     *
    **/
    where?: InfoRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of InfoRequests to fetch.
     *
    **/
    orderBy?: Enumerable<InfoRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: InfoRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` InfoRequests from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` InfoRequests.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned InfoRequests
    **/
    _count?: true | InfoRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: InfoRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: InfoRequestMaxAggregateInputType
  }

  export type GetInfoRequestAggregateType<T extends InfoRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateInfoRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfoRequest[P]>
      : GetScalarType<T[P], AggregateInfoRequest[P]>
  }




  export type InfoRequestGroupByArgs = {
    where?: InfoRequestWhereInput
    orderBy?: Enumerable<InfoRequestOrderByWithAggregationInput>
    by: Array<InfoRequestScalarFieldEnum>
    having?: InfoRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfoRequestCountAggregateInputType | true
    _min?: InfoRequestMinAggregateInputType
    _max?: InfoRequestMaxAggregateInputType
  }


  export type InfoRequestGroupByOutputType = {
    id: string
    personId: string
    message: string
    createdAt: Date
    updatedAt: Date | null
    deletedAt: Date | null
    _count: InfoRequestCountAggregateOutputType | null
    _min: InfoRequestMinAggregateOutputType | null
    _max: InfoRequestMaxAggregateOutputType | null
  }

  type GetInfoRequestGroupByPayload<T extends InfoRequestGroupByArgs> = Promise<
    Array<
      PickArray<InfoRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfoRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfoRequestGroupByOutputType[P]>
            : GetScalarType<T[P], InfoRequestGroupByOutputType[P]>
        }
      >
    >


  export type InfoRequestSelect = {
    id?: boolean
    personId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    person?: boolean | PersonArgs
  }

  export type InfoRequestInclude = {
    person?: boolean | PersonArgs
  }

  export type InfoRequestGetPayload<
    S extends boolean | null | undefined | InfoRequestArgs,
    U = keyof S
      > = S extends true
        ? InfoRequest
    : S extends undefined
    ? never
    : S extends InfoRequestArgs | InfoRequestFindManyArgs
    ?'include' extends U
    ? InfoRequest  & {
    [P in TrueKeys<S['include']>]:
          P extends 'person'
        ? PersonGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof InfoRequest ?InfoRequest [P]
  :
          P extends 'person'
        ? PersonGetPayload<S['select'][P]> : never
  }
    : InfoRequest
  : InfoRequest


  type InfoRequestCountArgs = Merge<
    Omit<InfoRequestFindManyArgs, 'select' | 'include'> & {
      select?: InfoRequestCountAggregateInputType | true
    }
  >

  export interface InfoRequestDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one InfoRequest that matches the filter.
     * @param {InfoRequestFindUniqueArgs} args - Arguments to find a InfoRequest
     * @example
     * // Get one InfoRequest
     * const infoRequest = await prisma.infoRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InfoRequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InfoRequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InfoRequest'> extends True ? CheckSelect<T, Prisma__InfoRequestClient<InfoRequest>, Prisma__InfoRequestClient<InfoRequestGetPayload<T>>> : CheckSelect<T, Prisma__InfoRequestClient<InfoRequest | null >, Prisma__InfoRequestClient<InfoRequestGetPayload<T> | null >>

    /**
     * Find the first InfoRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfoRequestFindFirstArgs} args - Arguments to find a InfoRequest
     * @example
     * // Get one InfoRequest
     * const infoRequest = await prisma.infoRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InfoRequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InfoRequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InfoRequest'> extends True ? CheckSelect<T, Prisma__InfoRequestClient<InfoRequest>, Prisma__InfoRequestClient<InfoRequestGetPayload<T>>> : CheckSelect<T, Prisma__InfoRequestClient<InfoRequest | null >, Prisma__InfoRequestClient<InfoRequestGetPayload<T> | null >>

    /**
     * Find zero or more InfoRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfoRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InfoRequests
     * const infoRequests = await prisma.infoRequest.findMany()
     *
     * // Get first 10 InfoRequests
     * const infoRequests = await prisma.infoRequest.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const infoRequestWithIdOnly = await prisma.infoRequest.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends InfoRequestFindManyArgs>(
      args?: SelectSubset<T, InfoRequestFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<InfoRequest>>, PrismaPromise<Array<InfoRequestGetPayload<T>>>>

    /**
     * Create a InfoRequest.
     * @param {InfoRequestCreateArgs} args - Arguments to create a InfoRequest.
     * @example
     * // Create one InfoRequest
     * const InfoRequest = await prisma.infoRequest.create({
     *   data: {
     *     // ... data to create a InfoRequest
     *   }
     * })
     *
    **/
    create<T extends InfoRequestCreateArgs>(
      args: SelectSubset<T, InfoRequestCreateArgs>
    ): CheckSelect<T, Prisma__InfoRequestClient<InfoRequest>, Prisma__InfoRequestClient<InfoRequestGetPayload<T>>>

    /**
     * Create many InfoRequests.
     *     @param {InfoRequestCreateManyArgs} args - Arguments to create many InfoRequests.
     *     @example
     *     // Create many InfoRequests
     *     const infoRequest = await prisma.infoRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends InfoRequestCreateManyArgs>(
      args?: SelectSubset<T, InfoRequestCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InfoRequest.
     * @param {InfoRequestDeleteArgs} args - Arguments to delete one InfoRequest.
     * @example
     * // Delete one InfoRequest
     * const InfoRequest = await prisma.infoRequest.delete({
     *   where: {
     *     // ... filter to delete one InfoRequest
     *   }
     * })
     *
    **/
    delete<T extends InfoRequestDeleteArgs>(
      args: SelectSubset<T, InfoRequestDeleteArgs>
    ): CheckSelect<T, Prisma__InfoRequestClient<InfoRequest>, Prisma__InfoRequestClient<InfoRequestGetPayload<T>>>

    /**
     * Update one InfoRequest.
     * @param {InfoRequestUpdateArgs} args - Arguments to update one InfoRequest.
     * @example
     * // Update one InfoRequest
     * const infoRequest = await prisma.infoRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends InfoRequestUpdateArgs>(
      args: SelectSubset<T, InfoRequestUpdateArgs>
    ): CheckSelect<T, Prisma__InfoRequestClient<InfoRequest>, Prisma__InfoRequestClient<InfoRequestGetPayload<T>>>

    /**
     * Delete zero or more InfoRequests.
     * @param {InfoRequestDeleteManyArgs} args - Arguments to filter InfoRequests to delete.
     * @example
     * // Delete a few InfoRequests
     * const { count } = await prisma.infoRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends InfoRequestDeleteManyArgs>(
      args?: SelectSubset<T, InfoRequestDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InfoRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfoRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InfoRequests
     * const infoRequest = await prisma.infoRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends InfoRequestUpdateManyArgs>(
      args: SelectSubset<T, InfoRequestUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InfoRequest.
     * @param {InfoRequestUpsertArgs} args - Arguments to update or create a InfoRequest.
     * @example
     * // Update or create a InfoRequest
     * const infoRequest = await prisma.infoRequest.upsert({
     *   create: {
     *     // ... data to create a InfoRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InfoRequest we want to update
     *   }
     * })
    **/
    upsert<T extends InfoRequestUpsertArgs>(
      args: SelectSubset<T, InfoRequestUpsertArgs>
    ): CheckSelect<T, Prisma__InfoRequestClient<InfoRequest>, Prisma__InfoRequestClient<InfoRequestGetPayload<T>>>

    /**
     * Count the number of InfoRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfoRequestCountArgs} args - Arguments to filter InfoRequests to count.
     * @example
     * // Count the number of InfoRequests
     * const count = await prisma.infoRequest.count({
     *   where: {
     *     // ... the filter for the InfoRequests we want to count
     *   }
     * })
    **/
    count<T extends InfoRequestCountArgs>(
      args?: Subset<T, InfoRequestCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfoRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InfoRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfoRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfoRequestAggregateArgs>(args: Subset<T, InfoRequestAggregateArgs>): PrismaPromise<GetInfoRequestAggregateType<T>>

    /**
     * Group by InfoRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfoRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends InfoRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfoRequestGroupByArgs['orderBy'] }
        : { orderBy?: InfoRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfoRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfoRequestGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for InfoRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InfoRequestClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * InfoRequest findUnique
   */
  export type InfoRequestFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the InfoRequest
     *
    **/
    select?: InfoRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: InfoRequestInclude | null
    /**
     * Throw an Error if a InfoRequest can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which InfoRequest to fetch.
     *
    **/
    where: InfoRequestWhereUniqueInput
  }


  /**
   * InfoRequest findFirst
   */
  export type InfoRequestFindFirstArgs = {
    /**
     * Select specific fields to fetch from the InfoRequest
     *
    **/
    select?: InfoRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: InfoRequestInclude | null
    /**
     * Throw an Error if a InfoRequest can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which InfoRequest to fetch.
     *
    **/
    where?: InfoRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of InfoRequests to fetch.
     *
    **/
    orderBy?: Enumerable<InfoRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for InfoRequests.
     *
    **/
    cursor?: InfoRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` InfoRequests from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` InfoRequests.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of InfoRequests.
     *
    **/
    distinct?: Enumerable<InfoRequestScalarFieldEnum>
  }


  /**
   * InfoRequest findMany
   */
  export type InfoRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the InfoRequest
     *
    **/
    select?: InfoRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: InfoRequestInclude | null
    /**
     * Filter, which InfoRequests to fetch.
     *
    **/
    where?: InfoRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of InfoRequests to fetch.
     *
    **/
    orderBy?: Enumerable<InfoRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing InfoRequests.
     *
    **/
    cursor?: InfoRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` InfoRequests from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` InfoRequests.
     *
    **/
    skip?: number
    distinct?: Enumerable<InfoRequestScalarFieldEnum>
  }


  /**
   * InfoRequest create
   */
  export type InfoRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the InfoRequest
     *
    **/
    select?: InfoRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: InfoRequestInclude | null
    /**
     * The data needed to create a InfoRequest.
     *
    **/
    data: XOR<InfoRequestCreateInput, InfoRequestUncheckedCreateInput>
  }


  /**
   * InfoRequest createMany
   */
  export type InfoRequestCreateManyArgs = {
    data: Enumerable<InfoRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InfoRequest update
   */
  export type InfoRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the InfoRequest
     *
    **/
    select?: InfoRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: InfoRequestInclude | null
    /**
     * The data needed to update a InfoRequest.
     *
    **/
    data: XOR<InfoRequestUpdateInput, InfoRequestUncheckedUpdateInput>
    /**
     * Choose, which InfoRequest to update.
     *
    **/
    where: InfoRequestWhereUniqueInput
  }


  /**
   * InfoRequest updateMany
   */
  export type InfoRequestUpdateManyArgs = {
    data: XOR<InfoRequestUpdateManyMutationInput, InfoRequestUncheckedUpdateManyInput>
    where?: InfoRequestWhereInput
  }


  /**
   * InfoRequest upsert
   */
  export type InfoRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the InfoRequest
     *
    **/
    select?: InfoRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: InfoRequestInclude | null
    /**
     * The filter to search for the InfoRequest to update in case it exists.
     *
    **/
    where: InfoRequestWhereUniqueInput
    /**
     * In case the InfoRequest found by the `where` argument doesn't exist, create a new InfoRequest with this data.
     *
    **/
    create: XOR<InfoRequestCreateInput, InfoRequestUncheckedCreateInput>
    /**
     * In case the InfoRequest was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<InfoRequestUpdateInput, InfoRequestUncheckedUpdateInput>
  }


  /**
   * InfoRequest delete
   */
  export type InfoRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the InfoRequest
     *
    **/
    select?: InfoRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: InfoRequestInclude | null
    /**
     * Filter which InfoRequest to delete.
     *
    **/
    where: InfoRequestWhereUniqueInput
  }


  /**
   * InfoRequest deleteMany
   */
  export type InfoRequestDeleteManyArgs = {
    where?: InfoRequestWhereInput
  }


  /**
   * InfoRequest without action
   */
  export type InfoRequestArgs = {
    /**
     * Select specific fields to fetch from the InfoRequest
     *
    **/
    select?: InfoRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: InfoRequestInclude | null
  }



  /**
   * Model Supporter
   */


  export type AggregateSupporter = {
    _count: SupporterCountAggregateOutputType | null
    _min: SupporterMinAggregateOutputType | null
    _max: SupporterMaxAggregateOutputType | null
  }

  export type SupporterMinAggregateOutputType = {
    id: string | null
    personId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    comment: string | null
    associationMember: boolean | null
    benefactorCampaign: boolean | null
    benefactorPlatform: boolean | null
    companyOtherText: string | null
    companySponsor: boolean | null
    companyVolunteer: boolean | null
    partnerBussiness: boolean | null
    partnerNpo: boolean | null
    partnerOtherText: string | null
    roleAssociationMember: boolean | null
    roleBenefactor: boolean | null
    roleCompany: boolean | null
    rolePartner: boolean | null
    roleVolunteer: boolean | null
    volunteerBackend: boolean | null
    volunteerDesigner: boolean | null
    volunteerDevOps: boolean | null
    volunteerFinancesAndAccounts: boolean | null
    volunteerFrontend: boolean | null
    volunteerLawyer: boolean | null
    volunteerMarketing: boolean | null
    volunteerProjectManager: boolean | null
    volunteerQa: boolean | null
    volunteerSecurity: boolean | null
  }

  export type SupporterMaxAggregateOutputType = {
    id: string | null
    personId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    comment: string | null
    associationMember: boolean | null
    benefactorCampaign: boolean | null
    benefactorPlatform: boolean | null
    companyOtherText: string | null
    companySponsor: boolean | null
    companyVolunteer: boolean | null
    partnerBussiness: boolean | null
    partnerNpo: boolean | null
    partnerOtherText: string | null
    roleAssociationMember: boolean | null
    roleBenefactor: boolean | null
    roleCompany: boolean | null
    rolePartner: boolean | null
    roleVolunteer: boolean | null
    volunteerBackend: boolean | null
    volunteerDesigner: boolean | null
    volunteerDevOps: boolean | null
    volunteerFinancesAndAccounts: boolean | null
    volunteerFrontend: boolean | null
    volunteerLawyer: boolean | null
    volunteerMarketing: boolean | null
    volunteerProjectManager: boolean | null
    volunteerQa: boolean | null
    volunteerSecurity: boolean | null
  }

  export type SupporterCountAggregateOutputType = {
    id: number
    personId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    comment: number
    associationMember: number
    benefactorCampaign: number
    benefactorPlatform: number
    companyOtherText: number
    companySponsor: number
    companyVolunteer: number
    partnerBussiness: number
    partnerNpo: number
    partnerOtherText: number
    roleAssociationMember: number
    roleBenefactor: number
    roleCompany: number
    rolePartner: number
    roleVolunteer: number
    volunteerBackend: number
    volunteerDesigner: number
    volunteerDevOps: number
    volunteerFinancesAndAccounts: number
    volunteerFrontend: number
    volunteerLawyer: number
    volunteerMarketing: number
    volunteerProjectManager: number
    volunteerQa: number
    volunteerSecurity: number
    _all: number
  }


  export type SupporterMinAggregateInputType = {
    id?: true
    personId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    comment?: true
    associationMember?: true
    benefactorCampaign?: true
    benefactorPlatform?: true
    companyOtherText?: true
    companySponsor?: true
    companyVolunteer?: true
    partnerBussiness?: true
    partnerNpo?: true
    partnerOtherText?: true
    roleAssociationMember?: true
    roleBenefactor?: true
    roleCompany?: true
    rolePartner?: true
    roleVolunteer?: true
    volunteerBackend?: true
    volunteerDesigner?: true
    volunteerDevOps?: true
    volunteerFinancesAndAccounts?: true
    volunteerFrontend?: true
    volunteerLawyer?: true
    volunteerMarketing?: true
    volunteerProjectManager?: true
    volunteerQa?: true
    volunteerSecurity?: true
  }

  export type SupporterMaxAggregateInputType = {
    id?: true
    personId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    comment?: true
    associationMember?: true
    benefactorCampaign?: true
    benefactorPlatform?: true
    companyOtherText?: true
    companySponsor?: true
    companyVolunteer?: true
    partnerBussiness?: true
    partnerNpo?: true
    partnerOtherText?: true
    roleAssociationMember?: true
    roleBenefactor?: true
    roleCompany?: true
    rolePartner?: true
    roleVolunteer?: true
    volunteerBackend?: true
    volunteerDesigner?: true
    volunteerDevOps?: true
    volunteerFinancesAndAccounts?: true
    volunteerFrontend?: true
    volunteerLawyer?: true
    volunteerMarketing?: true
    volunteerProjectManager?: true
    volunteerQa?: true
    volunteerSecurity?: true
  }

  export type SupporterCountAggregateInputType = {
    id?: true
    personId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    comment?: true
    associationMember?: true
    benefactorCampaign?: true
    benefactorPlatform?: true
    companyOtherText?: true
    companySponsor?: true
    companyVolunteer?: true
    partnerBussiness?: true
    partnerNpo?: true
    partnerOtherText?: true
    roleAssociationMember?: true
    roleBenefactor?: true
    roleCompany?: true
    rolePartner?: true
    roleVolunteer?: true
    volunteerBackend?: true
    volunteerDesigner?: true
    volunteerDevOps?: true
    volunteerFinancesAndAccounts?: true
    volunteerFrontend?: true
    volunteerLawyer?: true
    volunteerMarketing?: true
    volunteerProjectManager?: true
    volunteerQa?: true
    volunteerSecurity?: true
    _all?: true
  }

  export type SupporterAggregateArgs = {
    /**
     * Filter which Supporter to aggregate.
     *
    **/
    where?: SupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Supporters to fetch.
     *
    **/
    orderBy?: Enumerable<SupporterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: SupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Supporters from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Supporters.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Supporters
    **/
    _count?: true | SupporterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: SupporterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: SupporterMaxAggregateInputType
  }

  export type GetSupporterAggregateType<T extends SupporterAggregateArgs> = {
        [P in keyof T & keyof AggregateSupporter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupporter[P]>
      : GetScalarType<T[P], AggregateSupporter[P]>
  }




  export type SupporterGroupByArgs = {
    where?: SupporterWhereInput
    orderBy?: Enumerable<SupporterOrderByWithAggregationInput>
    by: Array<SupporterScalarFieldEnum>
    having?: SupporterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupporterCountAggregateInputType | true
    _min?: SupporterMinAggregateInputType
    _max?: SupporterMaxAggregateInputType
  }


  export type SupporterGroupByOutputType = {
    id: string
    personId: string
    createdAt: Date
    updatedAt: Date | null
    deletedAt: Date | null
    comment: string | null
    associationMember: boolean
    benefactorCampaign: boolean
    benefactorPlatform: boolean
    companyOtherText: string | null
    companySponsor: boolean
    companyVolunteer: boolean
    partnerBussiness: boolean
    partnerNpo: boolean
    partnerOtherText: string | null
    roleAssociationMember: boolean
    roleBenefactor: boolean
    roleCompany: boolean
    rolePartner: boolean
    roleVolunteer: boolean
    volunteerBackend: boolean
    volunteerDesigner: boolean
    volunteerDevOps: boolean
    volunteerFinancesAndAccounts: boolean
    volunteerFrontend: boolean
    volunteerLawyer: boolean
    volunteerMarketing: boolean
    volunteerProjectManager: boolean
    volunteerQa: boolean
    volunteerSecurity: boolean
    _count: SupporterCountAggregateOutputType | null
    _min: SupporterMinAggregateOutputType | null
    _max: SupporterMaxAggregateOutputType | null
  }

  type GetSupporterGroupByPayload<T extends SupporterGroupByArgs> = Promise<
    Array<
      PickArray<SupporterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupporterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupporterGroupByOutputType[P]>
            : GetScalarType<T[P], SupporterGroupByOutputType[P]>
        }
      >
    >


  export type SupporterSelect = {
    id?: boolean
    personId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    comment?: boolean
    associationMember?: boolean
    benefactorCampaign?: boolean
    benefactorPlatform?: boolean
    companyOtherText?: boolean
    companySponsor?: boolean
    companyVolunteer?: boolean
    partnerBussiness?: boolean
    partnerNpo?: boolean
    partnerOtherText?: boolean
    roleAssociationMember?: boolean
    roleBenefactor?: boolean
    roleCompany?: boolean
    rolePartner?: boolean
    roleVolunteer?: boolean
    volunteerBackend?: boolean
    volunteerDesigner?: boolean
    volunteerDevOps?: boolean
    volunteerFinancesAndAccounts?: boolean
    volunteerFrontend?: boolean
    volunteerLawyer?: boolean
    volunteerMarketing?: boolean
    volunteerProjectManager?: boolean
    volunteerQa?: boolean
    volunteerSecurity?: boolean
    person?: boolean | PersonArgs
  }

  export type SupporterInclude = {
    person?: boolean | PersonArgs
  }

  export type SupporterGetPayload<
    S extends boolean | null | undefined | SupporterArgs,
    U = keyof S
      > = S extends true
        ? Supporter
    : S extends undefined
    ? never
    : S extends SupporterArgs | SupporterFindManyArgs
    ?'include' extends U
    ? Supporter  & {
    [P in TrueKeys<S['include']>]:
          P extends 'person'
        ? PersonGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Supporter ?Supporter [P]
  :
          P extends 'person'
        ? PersonGetPayload<S['select'][P]> : never
  }
    : Supporter
  : Supporter


  type SupporterCountArgs = Merge<
    Omit<SupporterFindManyArgs, 'select' | 'include'> & {
      select?: SupporterCountAggregateInputType | true
    }
  >

  export interface SupporterDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Supporter that matches the filter.
     * @param {SupporterFindUniqueArgs} args - Arguments to find a Supporter
     * @example
     * // Get one Supporter
     * const supporter = await prisma.supporter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SupporterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SupporterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Supporter'> extends True ? CheckSelect<T, Prisma__SupporterClient<Supporter>, Prisma__SupporterClient<SupporterGetPayload<T>>> : CheckSelect<T, Prisma__SupporterClient<Supporter | null >, Prisma__SupporterClient<SupporterGetPayload<T> | null >>

    /**
     * Find the first Supporter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterFindFirstArgs} args - Arguments to find a Supporter
     * @example
     * // Get one Supporter
     * const supporter = await prisma.supporter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SupporterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SupporterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Supporter'> extends True ? CheckSelect<T, Prisma__SupporterClient<Supporter>, Prisma__SupporterClient<SupporterGetPayload<T>>> : CheckSelect<T, Prisma__SupporterClient<Supporter | null >, Prisma__SupporterClient<SupporterGetPayload<T> | null >>

    /**
     * Find zero or more Supporters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Supporters
     * const supporters = await prisma.supporter.findMany()
     *
     * // Get first 10 Supporters
     * const supporters = await prisma.supporter.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const supporterWithIdOnly = await prisma.supporter.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends SupporterFindManyArgs>(
      args?: SelectSubset<T, SupporterFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Supporter>>, PrismaPromise<Array<SupporterGetPayload<T>>>>

    /**
     * Create a Supporter.
     * @param {SupporterCreateArgs} args - Arguments to create a Supporter.
     * @example
     * // Create one Supporter
     * const Supporter = await prisma.supporter.create({
     *   data: {
     *     // ... data to create a Supporter
     *   }
     * })
     *
    **/
    create<T extends SupporterCreateArgs>(
      args: SelectSubset<T, SupporterCreateArgs>
    ): CheckSelect<T, Prisma__SupporterClient<Supporter>, Prisma__SupporterClient<SupporterGetPayload<T>>>

    /**
     * Create many Supporters.
     *     @param {SupporterCreateManyArgs} args - Arguments to create many Supporters.
     *     @example
     *     // Create many Supporters
     *     const supporter = await prisma.supporter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends SupporterCreateManyArgs>(
      args?: SelectSubset<T, SupporterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Supporter.
     * @param {SupporterDeleteArgs} args - Arguments to delete one Supporter.
     * @example
     * // Delete one Supporter
     * const Supporter = await prisma.supporter.delete({
     *   where: {
     *     // ... filter to delete one Supporter
     *   }
     * })
     *
    **/
    delete<T extends SupporterDeleteArgs>(
      args: SelectSubset<T, SupporterDeleteArgs>
    ): CheckSelect<T, Prisma__SupporterClient<Supporter>, Prisma__SupporterClient<SupporterGetPayload<T>>>

    /**
     * Update one Supporter.
     * @param {SupporterUpdateArgs} args - Arguments to update one Supporter.
     * @example
     * // Update one Supporter
     * const supporter = await prisma.supporter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends SupporterUpdateArgs>(
      args: SelectSubset<T, SupporterUpdateArgs>
    ): CheckSelect<T, Prisma__SupporterClient<Supporter>, Prisma__SupporterClient<SupporterGetPayload<T>>>

    /**
     * Delete zero or more Supporters.
     * @param {SupporterDeleteManyArgs} args - Arguments to filter Supporters to delete.
     * @example
     * // Delete a few Supporters
     * const { count } = await prisma.supporter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends SupporterDeleteManyArgs>(
      args?: SelectSubset<T, SupporterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supporters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Supporters
     * const supporter = await prisma.supporter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends SupporterUpdateManyArgs>(
      args: SelectSubset<T, SupporterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Supporter.
     * @param {SupporterUpsertArgs} args - Arguments to update or create a Supporter.
     * @example
     * // Update or create a Supporter
     * const supporter = await prisma.supporter.upsert({
     *   create: {
     *     // ... data to create a Supporter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supporter we want to update
     *   }
     * })
    **/
    upsert<T extends SupporterUpsertArgs>(
      args: SelectSubset<T, SupporterUpsertArgs>
    ): CheckSelect<T, Prisma__SupporterClient<Supporter>, Prisma__SupporterClient<SupporterGetPayload<T>>>

    /**
     * Count the number of Supporters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterCountArgs} args - Arguments to filter Supporters to count.
     * @example
     * // Count the number of Supporters
     * const count = await prisma.supporter.count({
     *   where: {
     *     // ... the filter for the Supporters we want to count
     *   }
     * })
    **/
    count<T extends SupporterCountArgs>(
      args?: Subset<T, SupporterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupporterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supporter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupporterAggregateArgs>(args: Subset<T, SupporterAggregateArgs>): PrismaPromise<GetSupporterAggregateType<T>>

    /**
     * Group by Supporter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends SupporterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupporterGroupByArgs['orderBy'] }
        : { orderBy?: SupporterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupporterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupporterGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supporter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SupporterClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Supporter findUnique
   */
  export type SupporterFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Supporter
     *
    **/
    select?: SupporterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: SupporterInclude | null
    /**
     * Throw an Error if a Supporter can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Supporter to fetch.
     *
    **/
    where: SupporterWhereUniqueInput
  }


  /**
   * Supporter findFirst
   */
  export type SupporterFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Supporter
     *
    **/
    select?: SupporterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: SupporterInclude | null
    /**
     * Throw an Error if a Supporter can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Supporter to fetch.
     *
    **/
    where?: SupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Supporters to fetch.
     *
    **/
    orderBy?: Enumerable<SupporterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Supporters.
     *
    **/
    cursor?: SupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Supporters from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Supporters.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Supporters.
     *
    **/
    distinct?: Enumerable<SupporterScalarFieldEnum>
  }


  /**
   * Supporter findMany
   */
  export type SupporterFindManyArgs = {
    /**
     * Select specific fields to fetch from the Supporter
     *
    **/
    select?: SupporterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: SupporterInclude | null
    /**
     * Filter, which Supporters to fetch.
     *
    **/
    where?: SupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Supporters to fetch.
     *
    **/
    orderBy?: Enumerable<SupporterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Supporters.
     *
    **/
    cursor?: SupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Supporters from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Supporters.
     *
    **/
    skip?: number
    distinct?: Enumerable<SupporterScalarFieldEnum>
  }


  /**
   * Supporter create
   */
  export type SupporterCreateArgs = {
    /**
     * Select specific fields to fetch from the Supporter
     *
    **/
    select?: SupporterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: SupporterInclude | null
    /**
     * The data needed to create a Supporter.
     *
    **/
    data: XOR<SupporterCreateInput, SupporterUncheckedCreateInput>
  }


  /**
   * Supporter createMany
   */
  export type SupporterCreateManyArgs = {
    data: Enumerable<SupporterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Supporter update
   */
  export type SupporterUpdateArgs = {
    /**
     * Select specific fields to fetch from the Supporter
     *
    **/
    select?: SupporterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: SupporterInclude | null
    /**
     * The data needed to update a Supporter.
     *
    **/
    data: XOR<SupporterUpdateInput, SupporterUncheckedUpdateInput>
    /**
     * Choose, which Supporter to update.
     *
    **/
    where: SupporterWhereUniqueInput
  }


  /**
   * Supporter updateMany
   */
  export type SupporterUpdateManyArgs = {
    data: XOR<SupporterUpdateManyMutationInput, SupporterUncheckedUpdateManyInput>
    where?: SupporterWhereInput
  }


  /**
   * Supporter upsert
   */
  export type SupporterUpsertArgs = {
    /**
     * Select specific fields to fetch from the Supporter
     *
    **/
    select?: SupporterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: SupporterInclude | null
    /**
     * The filter to search for the Supporter to update in case it exists.
     *
    **/
    where: SupporterWhereUniqueInput
    /**
     * In case the Supporter found by the `where` argument doesn't exist, create a new Supporter with this data.
     *
    **/
    create: XOR<SupporterCreateInput, SupporterUncheckedCreateInput>
    /**
     * In case the Supporter was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<SupporterUpdateInput, SupporterUncheckedUpdateInput>
  }


  /**
   * Supporter delete
   */
  export type SupporterDeleteArgs = {
    /**
     * Select specific fields to fetch from the Supporter
     *
    **/
    select?: SupporterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: SupporterInclude | null
    /**
     * Filter which Supporter to delete.
     *
    **/
    where: SupporterWhereUniqueInput
  }


  /**
   * Supporter deleteMany
   */
  export type SupporterDeleteManyArgs = {
    where?: SupporterWhereInput
  }


  /**
   * Supporter without action
   */
  export type SupporterArgs = {
    /**
     * Select specific fields to fetch from the Supporter
     *
    **/
    select?: SupporterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: SupporterInclude | null
  }



  /**
   * Model City
   */


  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    postalCode: number | null
  }

  export type CitySumAggregateOutputType = {
    postalCode: number | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    postalCode: number | null
    countryId: string | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    postalCode: number | null
    countryId: string | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    postalCode: number
    countryId: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    postalCode?: true
  }

  export type CitySumAggregateInputType = {
    postalCode?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    postalCode?: true
    countryId?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    postalCode?: true
    countryId?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    postalCode?: true
    countryId?: true
    _all?: true
  }

  export type CityAggregateArgs = {
    /**
     * Filter which City to aggregate.
     *
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Cities to fetch.
     *
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Cities from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Cities.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs = {
    where?: CityWhereInput
    orderBy?: Enumerable<CityOrderByWithAggregationInput>
    by: Array<CityScalarFieldEnum>
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }


  export type CityGroupByOutputType = {
    id: string
    name: string
    postalCode: number
    countryId: string
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Promise<
    Array<
      PickArray<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect = {
    id?: boolean
    name?: boolean
    postalCode?: boolean
    countryId?: boolean
    countryCode?: boolean | CountryArgs
    beneficiaries?: boolean | BeneficiaryFindManyArgs
    _count?: boolean | CityCountOutputTypeArgs
  }

  export type CityInclude = {
    countryCode?: boolean | CountryArgs
    beneficiaries?: boolean | BeneficiaryFindManyArgs
    _count?: boolean | CityCountOutputTypeArgs
  }

  export type CityGetPayload<
    S extends boolean | null | undefined | CityArgs,
    U = keyof S
      > = S extends true
        ? City
    : S extends undefined
    ? never
    : S extends CityArgs | CityFindManyArgs
    ?'include' extends U
    ? City  & {
    [P in TrueKeys<S['include']>]:
          P extends 'countryCode'
        ? CountryGetPayload<S['include'][P]> :
        P extends 'beneficiaries'
        ? Array < BeneficiaryGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CityCountOutputTypeGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof City ?City [P]
  :
          P extends 'countryCode'
        ? CountryGetPayload<S['select'][P]> :
        P extends 'beneficiaries'
        ? Array < BeneficiaryGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CityCountOutputTypeGetPayload<S['select'][P]> : never
  }
    : City
  : City


  type CityCountArgs = Merge<
    Omit<CityFindManyArgs, 'select' | 'include'> & {
      select?: CityCountAggregateInputType | true
    }
  >

  export interface CityDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     *
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends CityFindManyArgs>(
      args?: SelectSubset<T, CityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<City>>, PrismaPromise<Array<CityGetPayload<T>>>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     *
    **/
    create<T extends CityCreateArgs>(
      args: SelectSubset<T, CityCreateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends CityCreateManyArgs>(
      args?: SelectSubset<T, CityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     *
    **/
    delete<T extends CityDeleteArgs>(
      args: SelectSubset<T, CityDeleteArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends CityUpdateArgs>(
      args: SelectSubset<T, CityUpdateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends CityDeleteManyArgs>(
      args?: SelectSubset<T, CityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends CityUpdateManyArgs>(
      args: SelectSubset<T, CityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs>(
      args: SelectSubset<T, CityUpsertArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CityClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    countryCode<T extends CountryArgs = {}>(args?: Subset<T, CountryArgs>): CheckSelect<T, Prisma__CountryClient<Country | null >, Prisma__CountryClient<CountryGetPayload<T> | null >>;

    beneficiaries<T extends BeneficiaryFindManyArgs = {}>(args?: Subset<T, BeneficiaryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Beneficiary>>, PrismaPromise<Array<BeneficiaryGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * City findUnique
   */
  export type CityFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the City
     *
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CityInclude | null
    /**
     * Throw an Error if a City can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which City to fetch.
     *
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City findFirst
   */
  export type CityFindFirstArgs = {
    /**
     * Select specific fields to fetch from the City
     *
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CityInclude | null
    /**
     * Throw an Error if a City can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which City to fetch.
     *
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Cities to fetch.
     *
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Cities.
     *
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Cities from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Cities.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Cities.
     *
    **/
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City findMany
   */
  export type CityFindManyArgs = {
    /**
     * Select specific fields to fetch from the City
     *
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CityInclude | null
    /**
     * Filter, which Cities to fetch.
     *
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Cities to fetch.
     *
    **/
    orderBy?: Enumerable<CityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Cities.
     *
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Cities from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Cities.
     *
    **/
    skip?: number
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City create
   */
  export type CityCreateArgs = {
    /**
     * Select specific fields to fetch from the City
     *
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CityInclude | null
    /**
     * The data needed to create a City.
     *
    **/
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }


  /**
   * City createMany
   */
  export type CityCreateManyArgs = {
    data: Enumerable<CityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * City update
   */
  export type CityUpdateArgs = {
    /**
     * Select specific fields to fetch from the City
     *
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CityInclude | null
    /**
     * The data needed to update a City.
     *
    **/
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     *
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City updateMany
   */
  export type CityUpdateManyArgs = {
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    where?: CityWhereInput
  }


  /**
   * City upsert
   */
  export type CityUpsertArgs = {
    /**
     * Select specific fields to fetch from the City
     *
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CityInclude | null
    /**
     * The filter to search for the City to update in case it exists.
     *
    **/
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     *
    **/
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }


  /**
   * City delete
   */
  export type CityDeleteArgs = {
    /**
     * Select specific fields to fetch from the City
     *
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CityInclude | null
    /**
     * Filter which City to delete.
     *
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs = {
    where?: CityWhereInput
  }


  /**
   * City without action
   */
  export type CityArgs = {
    /**
     * Select specific fields to fetch from the City
     *
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CityInclude | null
  }



  /**
   * Model Country
   */


  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    name: string | null
    countryCode: string | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    countryCode: string | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    countryCode: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    countryCode?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    countryCode?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    countryCode?: true
    _all?: true
  }

  export type CountryAggregateArgs = {
    /**
     * Filter which Country to aggregate.
     *
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Countries to fetch.
     *
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Countries from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Countries.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs = {
    where?: CountryWhereInput
    orderBy?: Enumerable<CountryOrderByWithAggregationInput>
    by: Array<CountryScalarFieldEnum>
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }


  export type CountryGroupByOutputType = {
    id: string
    name: string
    countryCode: string
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Promise<
    Array<
      PickArray<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect = {
    id?: boolean
    name?: boolean
    countryCode?: boolean
    cities?: boolean | CityFindManyArgs
    _count?: boolean | CountryCountOutputTypeArgs
  }

  export type CountryInclude = {
    cities?: boolean | CityFindManyArgs
    _count?: boolean | CountryCountOutputTypeArgs
  }

  export type CountryGetPayload<
    S extends boolean | null | undefined | CountryArgs,
    U = keyof S
      > = S extends true
        ? Country
    : S extends undefined
    ? never
    : S extends CountryArgs | CountryFindManyArgs
    ?'include' extends U
    ? Country  & {
    [P in TrueKeys<S['include']>]:
          P extends 'cities'
        ? Array < CityGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CountryCountOutputTypeGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Country ?Country [P]
  :
          P extends 'cities'
        ? Array < CityGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CountryCountOutputTypeGetPayload<S['select'][P]> : never
  }
    : Country
  : Country


  type CountryCountArgs = Merge<
    Omit<CountryFindManyArgs, 'select' | 'include'> & {
      select?: CountryCountAggregateInputType | true
    }
  >

  export interface CountryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CountryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Country'> extends True ? CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>> : CheckSelect<T, Prisma__CountryClient<Country | null >, Prisma__CountryClient<CountryGetPayload<T> | null >>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CountryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Country'> extends True ? CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>> : CheckSelect<T, Prisma__CountryClient<Country | null >, Prisma__CountryClient<CountryGetPayload<T> | null >>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     *
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends CountryFindManyArgs>(
      args?: SelectSubset<T, CountryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Country>>, PrismaPromise<Array<CountryGetPayload<T>>>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     *
    **/
    create<T extends CountryCreateArgs>(
      args: SelectSubset<T, CountryCreateArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Create many Countries.
     *     @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends CountryCreateManyArgs>(
      args?: SelectSubset<T, CountryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     *
    **/
    delete<T extends CountryDeleteArgs>(
      args: SelectSubset<T, CountryDeleteArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends CountryUpdateArgs>(
      args: SelectSubset<T, CountryUpdateArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends CountryDeleteManyArgs>(
      args?: SelectSubset<T, CountryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends CountryUpdateManyArgs>(
      args: SelectSubset<T, CountryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends CountryUpsertArgs>(
      args: SelectSubset<T, CountryUpsertArgs>
    ): CheckSelect<T, Prisma__CountryClient<Country>, Prisma__CountryClient<CountryGetPayload<T>>>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CountryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cities<T extends CityFindManyArgs = {}>(args?: Subset<T, CityFindManyArgs>): CheckSelect<T, PrismaPromise<Array<City>>, PrismaPromise<Array<CityGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Country
     *
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CountryInclude | null
    /**
     * Throw an Error if a Country can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Country to fetch.
     *
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Country
     *
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CountryInclude | null
    /**
     * Throw an Error if a Country can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Country to fetch.
     *
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Countries to fetch.
     *
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Countries.
     *
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Countries from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Countries.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Countries.
     *
    **/
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country findMany
   */
  export type CountryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Country
     *
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CountryInclude | null
    /**
     * Filter, which Countries to fetch.
     *
    **/
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Countries to fetch.
     *
    **/
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Countries.
     *
    **/
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Countries from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Countries.
     *
    **/
    skip?: number
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country create
   */
  export type CountryCreateArgs = {
    /**
     * Select specific fields to fetch from the Country
     *
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CountryInclude | null
    /**
     * The data needed to create a Country.
     *
    **/
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }


  /**
   * Country createMany
   */
  export type CountryCreateManyArgs = {
    data: Enumerable<CountryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Country update
   */
  export type CountryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Country
     *
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CountryInclude | null
    /**
     * The data needed to update a Country.
     *
    **/
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     *
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs = {
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    where?: CountryWhereInput
  }


  /**
   * Country upsert
   */
  export type CountryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Country
     *
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CountryInclude | null
    /**
     * The filter to search for the Country to update in case it exists.
     *
    **/
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     *
    **/
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }


  /**
   * Country delete
   */
  export type CountryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Country
     *
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CountryInclude | null
    /**
     * Filter which Country to delete.
     *
    **/
    where: CountryWhereUniqueInput
  }


  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs = {
    where?: CountryWhereInput
  }


  /**
   * Country without action
   */
  export type CountryArgs = {
    /**
     * Select specific fields to fetch from the Country
     *
    **/
    select?: CountrySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: CountryInclude | null
  }



  /**
   * Model Vault
   */


  export type AggregateVault = {
    _count: VaultCountAggregateOutputType | null
    _avg: VaultAvgAggregateOutputType | null
    _sum: VaultSumAggregateOutputType | null
    _min: VaultMinAggregateOutputType | null
    _max: VaultMaxAggregateOutputType | null
  }

  export type VaultAvgAggregateOutputType = {
    amount: number | null
  }

  export type VaultSumAggregateOutputType = {
    amount: number | null
  }

  export type VaultMinAggregateOutputType = {
    id: string | null
    currency: Currency | null
    amount: number | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VaultMaxAggregateOutputType = {
    id: string | null
    currency: Currency | null
    amount: number | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VaultCountAggregateOutputType = {
    id: number
    currency: number
    amount: number
    campaignId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VaultAvgAggregateInputType = {
    amount?: true
  }

  export type VaultSumAggregateInputType = {
    amount?: true
  }

  export type VaultMinAggregateInputType = {
    id?: true
    currency?: true
    amount?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VaultMaxAggregateInputType = {
    id?: true
    currency?: true
    amount?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VaultCountAggregateInputType = {
    id?: true
    currency?: true
    amount?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VaultAggregateArgs = {
    /**
     * Filter which Vault to aggregate.
     *
    **/
    where?: VaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Vaults to fetch.
     *
    **/
    orderBy?: Enumerable<VaultOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: VaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Vaults from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Vaults.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Vaults
    **/
    _count?: true | VaultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: VaultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: VaultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: VaultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: VaultMaxAggregateInputType
  }

  export type GetVaultAggregateType<T extends VaultAggregateArgs> = {
        [P in keyof T & keyof AggregateVault]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVault[P]>
      : GetScalarType<T[P], AggregateVault[P]>
  }




  export type VaultGroupByArgs = {
    where?: VaultWhereInput
    orderBy?: Enumerable<VaultOrderByWithAggregationInput>
    by: Array<VaultScalarFieldEnum>
    having?: VaultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaultCountAggregateInputType | true
    _avg?: VaultAvgAggregateInputType
    _sum?: VaultSumAggregateInputType
    _min?: VaultMinAggregateInputType
    _max?: VaultMaxAggregateInputType
  }


  export type VaultGroupByOutputType = {
    id: string
    currency: Currency
    amount: number
    campaignId: string
    createdAt: Date
    updatedAt: Date | null
    _count: VaultCountAggregateOutputType | null
    _avg: VaultAvgAggregateOutputType | null
    _sum: VaultSumAggregateOutputType | null
    _min: VaultMinAggregateOutputType | null
    _max: VaultMaxAggregateOutputType | null
  }

  type GetVaultGroupByPayload<T extends VaultGroupByArgs> = Promise<
    Array<
      PickArray<VaultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaultGroupByOutputType[P]>
            : GetScalarType<T[P], VaultGroupByOutputType[P]>
        }
      >
    >


  export type VaultSelect = {
    id?: boolean
    currency?: boolean
    amount?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignArgs
    expenses?: boolean | ExpenseFindManyArgs
    sourceTransfers?: boolean | TransferFindManyArgs
    targetTransfers?: boolean | TransferFindManyArgs
    donations?: boolean | DonationFindManyArgs
    withdraws?: boolean | WithdrawalFindManyArgs
    recurringDonations?: boolean | RecurringDonationFindManyArgs
    _count?: boolean | VaultCountOutputTypeArgs
  }

  export type VaultInclude = {
    campaign?: boolean | CampaignArgs
    expenses?: boolean | ExpenseFindManyArgs
    sourceTransfers?: boolean | TransferFindManyArgs
    targetTransfers?: boolean | TransferFindManyArgs
    donations?: boolean | DonationFindManyArgs
    withdraws?: boolean | WithdrawalFindManyArgs
    recurringDonations?: boolean | RecurringDonationFindManyArgs
    _count?: boolean | VaultCountOutputTypeArgs
  }

  export type VaultGetPayload<
    S extends boolean | null | undefined | VaultArgs,
    U = keyof S
      > = S extends true
        ? Vault
    : S extends undefined
    ? never
    : S extends VaultArgs | VaultFindManyArgs
    ?'include' extends U
    ? Vault  & {
    [P in TrueKeys<S['include']>]:
          P extends 'campaign'
        ? CampaignGetPayload<S['include'][P]> :
        P extends 'expenses'
        ? Array < ExpenseGetPayload<S['include'][P]>>  :
        P extends 'sourceTransfers'
        ? Array < TransferGetPayload<S['include'][P]>>  :
        P extends 'targetTransfers'
        ? Array < TransferGetPayload<S['include'][P]>>  :
        P extends 'donations'
        ? Array < DonationGetPayload<S['include'][P]>>  :
        P extends 'withdraws'
        ? Array < WithdrawalGetPayload<S['include'][P]>>  :
        P extends 'recurringDonations'
        ? Array < RecurringDonationGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? VaultCountOutputTypeGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Vault ?Vault [P]
  :
          P extends 'campaign'
        ? CampaignGetPayload<S['select'][P]> :
        P extends 'expenses'
        ? Array < ExpenseGetPayload<S['select'][P]>>  :
        P extends 'sourceTransfers'
        ? Array < TransferGetPayload<S['select'][P]>>  :
        P extends 'targetTransfers'
        ? Array < TransferGetPayload<S['select'][P]>>  :
        P extends 'donations'
        ? Array < DonationGetPayload<S['select'][P]>>  :
        P extends 'withdraws'
        ? Array < WithdrawalGetPayload<S['select'][P]>>  :
        P extends 'recurringDonations'
        ? Array < RecurringDonationGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? VaultCountOutputTypeGetPayload<S['select'][P]> : never
  }
    : Vault
  : Vault


  type VaultCountArgs = Merge<
    Omit<VaultFindManyArgs, 'select' | 'include'> & {
      select?: VaultCountAggregateInputType | true
    }
  >

  export interface VaultDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Vault that matches the filter.
     * @param {VaultFindUniqueArgs} args - Arguments to find a Vault
     * @example
     * // Get one Vault
     * const vault = await prisma.vault.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VaultFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VaultFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Vault'> extends True ? CheckSelect<T, Prisma__VaultClient<Vault>, Prisma__VaultClient<VaultGetPayload<T>>> : CheckSelect<T, Prisma__VaultClient<Vault | null >, Prisma__VaultClient<VaultGetPayload<T> | null >>

    /**
     * Find the first Vault that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaultFindFirstArgs} args - Arguments to find a Vault
     * @example
     * // Get one Vault
     * const vault = await prisma.vault.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VaultFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VaultFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Vault'> extends True ? CheckSelect<T, Prisma__VaultClient<Vault>, Prisma__VaultClient<VaultGetPayload<T>>> : CheckSelect<T, Prisma__VaultClient<Vault | null >, Prisma__VaultClient<VaultGetPayload<T> | null >>

    /**
     * Find zero or more Vaults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaultFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vaults
     * const vaults = await prisma.vault.findMany()
     *
     * // Get first 10 Vaults
     * const vaults = await prisma.vault.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const vaultWithIdOnly = await prisma.vault.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends VaultFindManyArgs>(
      args?: SelectSubset<T, VaultFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Vault>>, PrismaPromise<Array<VaultGetPayload<T>>>>

    /**
     * Create a Vault.
     * @param {VaultCreateArgs} args - Arguments to create a Vault.
     * @example
     * // Create one Vault
     * const Vault = await prisma.vault.create({
     *   data: {
     *     // ... data to create a Vault
     *   }
     * })
     *
    **/
    create<T extends VaultCreateArgs>(
      args: SelectSubset<T, VaultCreateArgs>
    ): CheckSelect<T, Prisma__VaultClient<Vault>, Prisma__VaultClient<VaultGetPayload<T>>>

    /**
     * Create many Vaults.
     *     @param {VaultCreateManyArgs} args - Arguments to create many Vaults.
     *     @example
     *     // Create many Vaults
     *     const vault = await prisma.vault.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends VaultCreateManyArgs>(
      args?: SelectSubset<T, VaultCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vault.
     * @param {VaultDeleteArgs} args - Arguments to delete one Vault.
     * @example
     * // Delete one Vault
     * const Vault = await prisma.vault.delete({
     *   where: {
     *     // ... filter to delete one Vault
     *   }
     * })
     *
    **/
    delete<T extends VaultDeleteArgs>(
      args: SelectSubset<T, VaultDeleteArgs>
    ): CheckSelect<T, Prisma__VaultClient<Vault>, Prisma__VaultClient<VaultGetPayload<T>>>

    /**
     * Update one Vault.
     * @param {VaultUpdateArgs} args - Arguments to update one Vault.
     * @example
     * // Update one Vault
     * const vault = await prisma.vault.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends VaultUpdateArgs>(
      args: SelectSubset<T, VaultUpdateArgs>
    ): CheckSelect<T, Prisma__VaultClient<Vault>, Prisma__VaultClient<VaultGetPayload<T>>>

    /**
     * Delete zero or more Vaults.
     * @param {VaultDeleteManyArgs} args - Arguments to filter Vaults to delete.
     * @example
     * // Delete a few Vaults
     * const { count } = await prisma.vault.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends VaultDeleteManyArgs>(
      args?: SelectSubset<T, VaultDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vaults
     * const vault = await prisma.vault.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends VaultUpdateManyArgs>(
      args: SelectSubset<T, VaultUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vault.
     * @param {VaultUpsertArgs} args - Arguments to update or create a Vault.
     * @example
     * // Update or create a Vault
     * const vault = await prisma.vault.upsert({
     *   create: {
     *     // ... data to create a Vault
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vault we want to update
     *   }
     * })
    **/
    upsert<T extends VaultUpsertArgs>(
      args: SelectSubset<T, VaultUpsertArgs>
    ): CheckSelect<T, Prisma__VaultClient<Vault>, Prisma__VaultClient<VaultGetPayload<T>>>

    /**
     * Count the number of Vaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaultCountArgs} args - Arguments to filter Vaults to count.
     * @example
     * // Count the number of Vaults
     * const count = await prisma.vault.count({
     *   where: {
     *     // ... the filter for the Vaults we want to count
     *   }
     * })
    **/
    count<T extends VaultCountArgs>(
      args?: Subset<T, VaultCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vault.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaultAggregateArgs>(args: Subset<T, VaultAggregateArgs>): PrismaPromise<GetVaultAggregateType<T>>

    /**
     * Group by Vault.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends VaultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaultGroupByArgs['orderBy'] }
        : { orderBy?: VaultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaultGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vault.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VaultClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    campaign<T extends CampaignArgs = {}>(args?: Subset<T, CampaignArgs>): CheckSelect<T, Prisma__CampaignClient<Campaign | null >, Prisma__CampaignClient<CampaignGetPayload<T> | null >>;

    expenses<T extends ExpenseFindManyArgs = {}>(args?: Subset<T, ExpenseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Expense>>, PrismaPromise<Array<ExpenseGetPayload<T>>>>;

    sourceTransfers<T extends TransferFindManyArgs = {}>(args?: Subset<T, TransferFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Transfer>>, PrismaPromise<Array<TransferGetPayload<T>>>>;

    targetTransfers<T extends TransferFindManyArgs = {}>(args?: Subset<T, TransferFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Transfer>>, PrismaPromise<Array<TransferGetPayload<T>>>>;

    donations<T extends DonationFindManyArgs = {}>(args?: Subset<T, DonationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Donation>>, PrismaPromise<Array<DonationGetPayload<T>>>>;

    withdraws<T extends WithdrawalFindManyArgs = {}>(args?: Subset<T, WithdrawalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Withdrawal>>, PrismaPromise<Array<WithdrawalGetPayload<T>>>>;

    recurringDonations<T extends RecurringDonationFindManyArgs = {}>(args?: Subset<T, RecurringDonationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<RecurringDonation>>, PrismaPromise<Array<RecurringDonationGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Vault findUnique
   */
  export type VaultFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Vault
     *
    **/
    select?: VaultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: VaultInclude | null
    /**
     * Throw an Error if a Vault can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vault to fetch.
     *
    **/
    where: VaultWhereUniqueInput
  }


  /**
   * Vault findFirst
   */
  export type VaultFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Vault
     *
    **/
    select?: VaultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: VaultInclude | null
    /**
     * Throw an Error if a Vault can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vault to fetch.
     *
    **/
    where?: VaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Vaults to fetch.
     *
    **/
    orderBy?: Enumerable<VaultOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Vaults.
     *
    **/
    cursor?: VaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Vaults from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Vaults.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Vaults.
     *
    **/
    distinct?: Enumerable<VaultScalarFieldEnum>
  }


  /**
   * Vault findMany
   */
  export type VaultFindManyArgs = {
    /**
     * Select specific fields to fetch from the Vault
     *
    **/
    select?: VaultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: VaultInclude | null
    /**
     * Filter, which Vaults to fetch.
     *
    **/
    where?: VaultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Vaults to fetch.
     *
    **/
    orderBy?: Enumerable<VaultOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Vaults.
     *
    **/
    cursor?: VaultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Vaults from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Vaults.
     *
    **/
    skip?: number
    distinct?: Enumerable<VaultScalarFieldEnum>
  }


  /**
   * Vault create
   */
  export type VaultCreateArgs = {
    /**
     * Select specific fields to fetch from the Vault
     *
    **/
    select?: VaultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: VaultInclude | null
    /**
     * The data needed to create a Vault.
     *
    **/
    data: XOR<VaultCreateInput, VaultUncheckedCreateInput>
  }


  /**
   * Vault createMany
   */
  export type VaultCreateManyArgs = {
    data: Enumerable<VaultCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Vault update
   */
  export type VaultUpdateArgs = {
    /**
     * Select specific fields to fetch from the Vault
     *
    **/
    select?: VaultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: VaultInclude | null
    /**
     * The data needed to update a Vault.
     *
    **/
    data: XOR<VaultUpdateInput, VaultUncheckedUpdateInput>
    /**
     * Choose, which Vault to update.
     *
    **/
    where: VaultWhereUniqueInput
  }


  /**
   * Vault updateMany
   */
  export type VaultUpdateManyArgs = {
    data: XOR<VaultUpdateManyMutationInput, VaultUncheckedUpdateManyInput>
    where?: VaultWhereInput
  }


  /**
   * Vault upsert
   */
  export type VaultUpsertArgs = {
    /**
     * Select specific fields to fetch from the Vault
     *
    **/
    select?: VaultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: VaultInclude | null
    /**
     * The filter to search for the Vault to update in case it exists.
     *
    **/
    where: VaultWhereUniqueInput
    /**
     * In case the Vault found by the `where` argument doesn't exist, create a new Vault with this data.
     *
    **/
    create: XOR<VaultCreateInput, VaultUncheckedCreateInput>
    /**
     * In case the Vault was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<VaultUpdateInput, VaultUncheckedUpdateInput>
  }


  /**
   * Vault delete
   */
  export type VaultDeleteArgs = {
    /**
     * Select specific fields to fetch from the Vault
     *
    **/
    select?: VaultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: VaultInclude | null
    /**
     * Filter which Vault to delete.
     *
    **/
    where: VaultWhereUniqueInput
  }


  /**
   * Vault deleteMany
   */
  export type VaultDeleteManyArgs = {
    where?: VaultWhereInput
  }


  /**
   * Vault without action
   */
  export type VaultArgs = {
    /**
     * Select specific fields to fetch from the Vault
     *
    **/
    select?: VaultSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: VaultInclude | null
  }



  /**
   * Model Donation
   */


  export type AggregateDonation = {
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  export type DonationAvgAggregateOutputType = {
    amount: number | null
  }

  export type DonationSumAggregateOutputType = {
    amount: number | null
  }

  export type DonationMinAggregateOutputType = {
    id: string | null
    type: DonationType | null
    status: DonationStatus | null
    provider: PaymentProvider | null
    personId: string | null
    currency: Currency | null
    amount: number | null
    targetVaultId: string | null
    extCustomerId: string | null
    extPaymentIntentId: string | null
    extPaymentMethodId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DonationMaxAggregateOutputType = {
    id: string | null
    type: DonationType | null
    status: DonationStatus | null
    provider: PaymentProvider | null
    personId: string | null
    currency: Currency | null
    amount: number | null
    targetVaultId: string | null
    extCustomerId: string | null
    extPaymentIntentId: string | null
    extPaymentMethodId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DonationCountAggregateOutputType = {
    id: number
    type: number
    status: number
    provider: number
    personId: number
    currency: number
    amount: number
    targetVaultId: number
    extCustomerId: number
    extPaymentIntentId: number
    extPaymentMethodId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DonationAvgAggregateInputType = {
    amount?: true
  }

  export type DonationSumAggregateInputType = {
    amount?: true
  }

  export type DonationMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    provider?: true
    personId?: true
    currency?: true
    amount?: true
    targetVaultId?: true
    extCustomerId?: true
    extPaymentIntentId?: true
    extPaymentMethodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DonationMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    provider?: true
    personId?: true
    currency?: true
    amount?: true
    targetVaultId?: true
    extCustomerId?: true
    extPaymentIntentId?: true
    extPaymentMethodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DonationCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    provider?: true
    personId?: true
    currency?: true
    amount?: true
    targetVaultId?: true
    extCustomerId?: true
    extPaymentIntentId?: true
    extPaymentMethodId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DonationAggregateArgs = {
    /**
     * Filter which Donation to aggregate.
     *
    **/
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Donations to fetch.
     *
    **/
    orderBy?: Enumerable<DonationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Donations from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Donations.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Donations
    **/
    _count?: true | DonationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: DonationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: DonationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: DonationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: DonationMaxAggregateInputType
  }

  export type GetDonationAggregateType<T extends DonationAggregateArgs> = {
        [P in keyof T & keyof AggregateDonation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonation[P]>
      : GetScalarType<T[P], AggregateDonation[P]>
  }




  export type DonationGroupByArgs = {
    where?: DonationWhereInput
    orderBy?: Enumerable<DonationOrderByWithAggregationInput>
    by: Array<DonationScalarFieldEnum>
    having?: DonationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonationCountAggregateInputType | true
    _avg?: DonationAvgAggregateInputType
    _sum?: DonationSumAggregateInputType
    _min?: DonationMinAggregateInputType
    _max?: DonationMaxAggregateInputType
  }


  export type DonationGroupByOutputType = {
    id: string
    type: DonationType
    status: DonationStatus
    provider: PaymentProvider
    personId: string | null
    currency: Currency
    amount: number
    targetVaultId: string
    extCustomerId: string
    extPaymentIntentId: string
    extPaymentMethodId: string
    createdAt: Date
    updatedAt: Date | null
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  type GetDonationGroupByPayload<T extends DonationGroupByArgs> = Promise<
    Array<
      PickArray<DonationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonationGroupByOutputType[P]>
            : GetScalarType<T[P], DonationGroupByOutputType[P]>
        }
      >
    >


  export type DonationSelect = {
    id?: boolean
    type?: boolean
    status?: boolean
    provider?: boolean
    personId?: boolean
    currency?: boolean
    amount?: boolean
    targetVaultId?: boolean
    extCustomerId?: boolean
    extPaymentIntentId?: boolean
    extPaymentMethodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    targetVault?: boolean | VaultArgs
    person?: boolean | PersonArgs
  }

  export type DonationInclude = {
    targetVault?: boolean | VaultArgs
    person?: boolean | PersonArgs
  }

  export type DonationGetPayload<
    S extends boolean | null | undefined | DonationArgs,
    U = keyof S
      > = S extends true
        ? Donation
    : S extends undefined
    ? never
    : S extends DonationArgs | DonationFindManyArgs
    ?'include' extends U
    ? Donation  & {
    [P in TrueKeys<S['include']>]:
          P extends 'targetVault'
        ? VaultGetPayload<S['include'][P]> :
        P extends 'person'
        ? PersonGetPayload<S['include'][P]> | null : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Donation ?Donation [P]
  :
          P extends 'targetVault'
        ? VaultGetPayload<S['select'][P]> :
        P extends 'person'
        ? PersonGetPayload<S['select'][P]> | null : never
  }
    : Donation
  : Donation


  type DonationCountArgs = Merge<
    Omit<DonationFindManyArgs, 'select' | 'include'> & {
      select?: DonationCountAggregateInputType | true
    }
  >

  export interface DonationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Donation that matches the filter.
     * @param {DonationFindUniqueArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DonationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DonationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Donation'> extends True ? CheckSelect<T, Prisma__DonationClient<Donation>, Prisma__DonationClient<DonationGetPayload<T>>> : CheckSelect<T, Prisma__DonationClient<Donation | null >, Prisma__DonationClient<DonationGetPayload<T> | null >>

    /**
     * Find the first Donation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindFirstArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DonationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DonationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Donation'> extends True ? CheckSelect<T, Prisma__DonationClient<Donation>, Prisma__DonationClient<DonationGetPayload<T>>> : CheckSelect<T, Prisma__DonationClient<Donation | null >, Prisma__DonationClient<DonationGetPayload<T> | null >>

    /**
     * Find zero or more Donations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donations
     * const donations = await prisma.donation.findMany()
     *
     * // Get first 10 Donations
     * const donations = await prisma.donation.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const donationWithIdOnly = await prisma.donation.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends DonationFindManyArgs>(
      args?: SelectSubset<T, DonationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Donation>>, PrismaPromise<Array<DonationGetPayload<T>>>>

    /**
     * Create a Donation.
     * @param {DonationCreateArgs} args - Arguments to create a Donation.
     * @example
     * // Create one Donation
     * const Donation = await prisma.donation.create({
     *   data: {
     *     // ... data to create a Donation
     *   }
     * })
     *
    **/
    create<T extends DonationCreateArgs>(
      args: SelectSubset<T, DonationCreateArgs>
    ): CheckSelect<T, Prisma__DonationClient<Donation>, Prisma__DonationClient<DonationGetPayload<T>>>

    /**
     * Create many Donations.
     *     @param {DonationCreateManyArgs} args - Arguments to create many Donations.
     *     @example
     *     // Create many Donations
     *     const donation = await prisma.donation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends DonationCreateManyArgs>(
      args?: SelectSubset<T, DonationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Donation.
     * @param {DonationDeleteArgs} args - Arguments to delete one Donation.
     * @example
     * // Delete one Donation
     * const Donation = await prisma.donation.delete({
     *   where: {
     *     // ... filter to delete one Donation
     *   }
     * })
     *
    **/
    delete<T extends DonationDeleteArgs>(
      args: SelectSubset<T, DonationDeleteArgs>
    ): CheckSelect<T, Prisma__DonationClient<Donation>, Prisma__DonationClient<DonationGetPayload<T>>>

    /**
     * Update one Donation.
     * @param {DonationUpdateArgs} args - Arguments to update one Donation.
     * @example
     * // Update one Donation
     * const donation = await prisma.donation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends DonationUpdateArgs>(
      args: SelectSubset<T, DonationUpdateArgs>
    ): CheckSelect<T, Prisma__DonationClient<Donation>, Prisma__DonationClient<DonationGetPayload<T>>>

    /**
     * Delete zero or more Donations.
     * @param {DonationDeleteManyArgs} args - Arguments to filter Donations to delete.
     * @example
     * // Delete a few Donations
     * const { count } = await prisma.donation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends DonationDeleteManyArgs>(
      args?: SelectSubset<T, DonationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donations
     * const donation = await prisma.donation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends DonationUpdateManyArgs>(
      args: SelectSubset<T, DonationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Donation.
     * @param {DonationUpsertArgs} args - Arguments to update or create a Donation.
     * @example
     * // Update or create a Donation
     * const donation = await prisma.donation.upsert({
     *   create: {
     *     // ... data to create a Donation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donation we want to update
     *   }
     * })
    **/
    upsert<T extends DonationUpsertArgs>(
      args: SelectSubset<T, DonationUpsertArgs>
    ): CheckSelect<T, Prisma__DonationClient<Donation>, Prisma__DonationClient<DonationGetPayload<T>>>

    /**
     * Count the number of Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationCountArgs} args - Arguments to filter Donations to count.
     * @example
     * // Count the number of Donations
     * const count = await prisma.donation.count({
     *   where: {
     *     // ... the filter for the Donations we want to count
     *   }
     * })
    **/
    count<T extends DonationCountArgs>(
      args?: Subset<T, DonationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonationAggregateArgs>(args: Subset<T, DonationAggregateArgs>): PrismaPromise<GetDonationAggregateType<T>>

    /**
     * Group by Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends DonationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DonationGroupByArgs['orderBy'] }
        : { orderBy?: DonationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DonationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Donation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DonationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    targetVault<T extends VaultArgs = {}>(args?: Subset<T, VaultArgs>): CheckSelect<T, Prisma__VaultClient<Vault | null >, Prisma__VaultClient<VaultGetPayload<T> | null >>;

    person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Donation findUnique
   */
  export type DonationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Donation
     *
    **/
    select?: DonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DonationInclude | null
    /**
     * Throw an Error if a Donation can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Donation to fetch.
     *
    **/
    where: DonationWhereUniqueInput
  }


  /**
   * Donation findFirst
   */
  export type DonationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Donation
     *
    **/
    select?: DonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DonationInclude | null
    /**
     * Throw an Error if a Donation can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Donation to fetch.
     *
    **/
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Donations to fetch.
     *
    **/
    orderBy?: Enumerable<DonationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Donations.
     *
    **/
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Donations from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Donations.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Donations.
     *
    **/
    distinct?: Enumerable<DonationScalarFieldEnum>
  }


  /**
   * Donation findMany
   */
  export type DonationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Donation
     *
    **/
    select?: DonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DonationInclude | null
    /**
     * Filter, which Donations to fetch.
     *
    **/
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Donations to fetch.
     *
    **/
    orderBy?: Enumerable<DonationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Donations.
     *
    **/
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Donations from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Donations.
     *
    **/
    skip?: number
    distinct?: Enumerable<DonationScalarFieldEnum>
  }


  /**
   * Donation create
   */
  export type DonationCreateArgs = {
    /**
     * Select specific fields to fetch from the Donation
     *
    **/
    select?: DonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DonationInclude | null
    /**
     * The data needed to create a Donation.
     *
    **/
    data: XOR<DonationCreateInput, DonationUncheckedCreateInput>
  }


  /**
   * Donation createMany
   */
  export type DonationCreateManyArgs = {
    data: Enumerable<DonationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Donation update
   */
  export type DonationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Donation
     *
    **/
    select?: DonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DonationInclude | null
    /**
     * The data needed to update a Donation.
     *
    **/
    data: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
    /**
     * Choose, which Donation to update.
     *
    **/
    where: DonationWhereUniqueInput
  }


  /**
   * Donation updateMany
   */
  export type DonationUpdateManyArgs = {
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyInput>
    where?: DonationWhereInput
  }


  /**
   * Donation upsert
   */
  export type DonationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Donation
     *
    **/
    select?: DonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DonationInclude | null
    /**
     * The filter to search for the Donation to update in case it exists.
     *
    **/
    where: DonationWhereUniqueInput
    /**
     * In case the Donation found by the `where` argument doesn't exist, create a new Donation with this data.
     *
    **/
    create: XOR<DonationCreateInput, DonationUncheckedCreateInput>
    /**
     * In case the Donation was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
  }


  /**
   * Donation delete
   */
  export type DonationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Donation
     *
    **/
    select?: DonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DonationInclude | null
    /**
     * Filter which Donation to delete.
     *
    **/
    where: DonationWhereUniqueInput
  }


  /**
   * Donation deleteMany
   */
  export type DonationDeleteManyArgs = {
    where?: DonationWhereInput
  }


  /**
   * Donation without action
   */
  export type DonationArgs = {
    /**
     * Select specific fields to fetch from the Donation
     *
    **/
    select?: DonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DonationInclude | null
  }



  /**
   * Model RecurringDonation
   */


  export type AggregateRecurringDonation = {
    _count: RecurringDonationCountAggregateOutputType | null
    _avg: RecurringDonationAvgAggregateOutputType | null
    _sum: RecurringDonationSumAggregateOutputType | null
    _min: RecurringDonationMinAggregateOutputType | null
    _max: RecurringDonationMaxAggregateOutputType | null
  }

  export type RecurringDonationAvgAggregateOutputType = {
    amount: number | null
  }

  export type RecurringDonationSumAggregateOutputType = {
    amount: number | null
  }

  export type RecurringDonationMinAggregateOutputType = {
    id: string | null
    status: RecurringDonationStatus | null
    vaultId: string | null
    personId: string | null
    currency: Currency | null
    amount: number | null
    extSubscriptionId: string | null
    extCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringDonationMaxAggregateOutputType = {
    id: string | null
    status: RecurringDonationStatus | null
    vaultId: string | null
    personId: string | null
    currency: Currency | null
    amount: number | null
    extSubscriptionId: string | null
    extCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringDonationCountAggregateOutputType = {
    id: number
    status: number
    vaultId: number
    personId: number
    currency: number
    amount: number
    extSubscriptionId: number
    extCustomerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecurringDonationAvgAggregateInputType = {
    amount?: true
  }

  export type RecurringDonationSumAggregateInputType = {
    amount?: true
  }

  export type RecurringDonationMinAggregateInputType = {
    id?: true
    status?: true
    vaultId?: true
    personId?: true
    currency?: true
    amount?: true
    extSubscriptionId?: true
    extCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringDonationMaxAggregateInputType = {
    id?: true
    status?: true
    vaultId?: true
    personId?: true
    currency?: true
    amount?: true
    extSubscriptionId?: true
    extCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringDonationCountAggregateInputType = {
    id?: true
    status?: true
    vaultId?: true
    personId?: true
    currency?: true
    amount?: true
    extSubscriptionId?: true
    extCustomerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecurringDonationAggregateArgs = {
    /**
     * Filter which RecurringDonation to aggregate.
     *
    **/
    where?: RecurringDonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RecurringDonations to fetch.
     *
    **/
    orderBy?: Enumerable<RecurringDonationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: RecurringDonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RecurringDonations from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RecurringDonations.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RecurringDonations
    **/
    _count?: true | RecurringDonationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: RecurringDonationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: RecurringDonationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: RecurringDonationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: RecurringDonationMaxAggregateInputType
  }

  export type GetRecurringDonationAggregateType<T extends RecurringDonationAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringDonation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringDonation[P]>
      : GetScalarType<T[P], AggregateRecurringDonation[P]>
  }




  export type RecurringDonationGroupByArgs = {
    where?: RecurringDonationWhereInput
    orderBy?: Enumerable<RecurringDonationOrderByWithAggregationInput>
    by: Array<RecurringDonationScalarFieldEnum>
    having?: RecurringDonationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringDonationCountAggregateInputType | true
    _avg?: RecurringDonationAvgAggregateInputType
    _sum?: RecurringDonationSumAggregateInputType
    _min?: RecurringDonationMinAggregateInputType
    _max?: RecurringDonationMaxAggregateInputType
  }


  export type RecurringDonationGroupByOutputType = {
    id: string
    status: RecurringDonationStatus
    vaultId: string
    personId: string
    currency: Currency
    amount: number
    extSubscriptionId: string
    extCustomerId: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: RecurringDonationCountAggregateOutputType | null
    _avg: RecurringDonationAvgAggregateOutputType | null
    _sum: RecurringDonationSumAggregateOutputType | null
    _min: RecurringDonationMinAggregateOutputType | null
    _max: RecurringDonationMaxAggregateOutputType | null
  }

  type GetRecurringDonationGroupByPayload<T extends RecurringDonationGroupByArgs> = Promise<
    Array<
      PickArray<RecurringDonationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringDonationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringDonationGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringDonationGroupByOutputType[P]>
        }
      >
    >


  export type RecurringDonationSelect = {
    id?: boolean
    status?: boolean
    vaultId?: boolean
    personId?: boolean
    currency?: boolean
    amount?: boolean
    extSubscriptionId?: boolean
    extCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceVault?: boolean | VaultArgs
    person?: boolean | PersonArgs
  }

  export type RecurringDonationInclude = {
    sourceVault?: boolean | VaultArgs
    person?: boolean | PersonArgs
  }

  export type RecurringDonationGetPayload<
    S extends boolean | null | undefined | RecurringDonationArgs,
    U = keyof S
      > = S extends true
        ? RecurringDonation
    : S extends undefined
    ? never
    : S extends RecurringDonationArgs | RecurringDonationFindManyArgs
    ?'include' extends U
    ? RecurringDonation  & {
    [P in TrueKeys<S['include']>]:
          P extends 'sourceVault'
        ? VaultGetPayload<S['include'][P]> :
        P extends 'person'
        ? PersonGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RecurringDonation ?RecurringDonation [P]
  :
          P extends 'sourceVault'
        ? VaultGetPayload<S['select'][P]> :
        P extends 'person'
        ? PersonGetPayload<S['select'][P]> : never
  }
    : RecurringDonation
  : RecurringDonation


  type RecurringDonationCountArgs = Merge<
    Omit<RecurringDonationFindManyArgs, 'select' | 'include'> & {
      select?: RecurringDonationCountAggregateInputType | true
    }
  >

  export interface RecurringDonationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RecurringDonation that matches the filter.
     * @param {RecurringDonationFindUniqueArgs} args - Arguments to find a RecurringDonation
     * @example
     * // Get one RecurringDonation
     * const recurringDonation = await prisma.recurringDonation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecurringDonationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RecurringDonationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RecurringDonation'> extends True ? CheckSelect<T, Prisma__RecurringDonationClient<RecurringDonation>, Prisma__RecurringDonationClient<RecurringDonationGetPayload<T>>> : CheckSelect<T, Prisma__RecurringDonationClient<RecurringDonation | null >, Prisma__RecurringDonationClient<RecurringDonationGetPayload<T> | null >>

    /**
     * Find the first RecurringDonation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringDonationFindFirstArgs} args - Arguments to find a RecurringDonation
     * @example
     * // Get one RecurringDonation
     * const recurringDonation = await prisma.recurringDonation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecurringDonationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RecurringDonationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RecurringDonation'> extends True ? CheckSelect<T, Prisma__RecurringDonationClient<RecurringDonation>, Prisma__RecurringDonationClient<RecurringDonationGetPayload<T>>> : CheckSelect<T, Prisma__RecurringDonationClient<RecurringDonation | null >, Prisma__RecurringDonationClient<RecurringDonationGetPayload<T> | null >>

    /**
     * Find zero or more RecurringDonations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringDonationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringDonations
     * const recurringDonations = await prisma.recurringDonation.findMany()
     *
     * // Get first 10 RecurringDonations
     * const recurringDonations = await prisma.recurringDonation.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const recurringDonationWithIdOnly = await prisma.recurringDonation.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends RecurringDonationFindManyArgs>(
      args?: SelectSubset<T, RecurringDonationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RecurringDonation>>, PrismaPromise<Array<RecurringDonationGetPayload<T>>>>

    /**
     * Create a RecurringDonation.
     * @param {RecurringDonationCreateArgs} args - Arguments to create a RecurringDonation.
     * @example
     * // Create one RecurringDonation
     * const RecurringDonation = await prisma.recurringDonation.create({
     *   data: {
     *     // ... data to create a RecurringDonation
     *   }
     * })
     *
    **/
    create<T extends RecurringDonationCreateArgs>(
      args: SelectSubset<T, RecurringDonationCreateArgs>
    ): CheckSelect<T, Prisma__RecurringDonationClient<RecurringDonation>, Prisma__RecurringDonationClient<RecurringDonationGetPayload<T>>>

    /**
     * Create many RecurringDonations.
     *     @param {RecurringDonationCreateManyArgs} args - Arguments to create many RecurringDonations.
     *     @example
     *     // Create many RecurringDonations
     *     const recurringDonation = await prisma.recurringDonation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends RecurringDonationCreateManyArgs>(
      args?: SelectSubset<T, RecurringDonationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RecurringDonation.
     * @param {RecurringDonationDeleteArgs} args - Arguments to delete one RecurringDonation.
     * @example
     * // Delete one RecurringDonation
     * const RecurringDonation = await prisma.recurringDonation.delete({
     *   where: {
     *     // ... filter to delete one RecurringDonation
     *   }
     * })
     *
    **/
    delete<T extends RecurringDonationDeleteArgs>(
      args: SelectSubset<T, RecurringDonationDeleteArgs>
    ): CheckSelect<T, Prisma__RecurringDonationClient<RecurringDonation>, Prisma__RecurringDonationClient<RecurringDonationGetPayload<T>>>

    /**
     * Update one RecurringDonation.
     * @param {RecurringDonationUpdateArgs} args - Arguments to update one RecurringDonation.
     * @example
     * // Update one RecurringDonation
     * const recurringDonation = await prisma.recurringDonation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends RecurringDonationUpdateArgs>(
      args: SelectSubset<T, RecurringDonationUpdateArgs>
    ): CheckSelect<T, Prisma__RecurringDonationClient<RecurringDonation>, Prisma__RecurringDonationClient<RecurringDonationGetPayload<T>>>

    /**
     * Delete zero or more RecurringDonations.
     * @param {RecurringDonationDeleteManyArgs} args - Arguments to filter RecurringDonations to delete.
     * @example
     * // Delete a few RecurringDonations
     * const { count } = await prisma.recurringDonation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends RecurringDonationDeleteManyArgs>(
      args?: SelectSubset<T, RecurringDonationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringDonations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringDonationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringDonations
     * const recurringDonation = await prisma.recurringDonation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends RecurringDonationUpdateManyArgs>(
      args: SelectSubset<T, RecurringDonationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RecurringDonation.
     * @param {RecurringDonationUpsertArgs} args - Arguments to update or create a RecurringDonation.
     * @example
     * // Update or create a RecurringDonation
     * const recurringDonation = await prisma.recurringDonation.upsert({
     *   create: {
     *     // ... data to create a RecurringDonation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringDonation we want to update
     *   }
     * })
    **/
    upsert<T extends RecurringDonationUpsertArgs>(
      args: SelectSubset<T, RecurringDonationUpsertArgs>
    ): CheckSelect<T, Prisma__RecurringDonationClient<RecurringDonation>, Prisma__RecurringDonationClient<RecurringDonationGetPayload<T>>>

    /**
     * Count the number of RecurringDonations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringDonationCountArgs} args - Arguments to filter RecurringDonations to count.
     * @example
     * // Count the number of RecurringDonations
     * const count = await prisma.recurringDonation.count({
     *   where: {
     *     // ... the filter for the RecurringDonations we want to count
     *   }
     * })
    **/
    count<T extends RecurringDonationCountArgs>(
      args?: Subset<T, RecurringDonationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringDonationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringDonation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringDonationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringDonationAggregateArgs>(args: Subset<T, RecurringDonationAggregateArgs>): PrismaPromise<GetRecurringDonationAggregateType<T>>

    /**
     * Group by RecurringDonation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringDonationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends RecurringDonationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringDonationGroupByArgs['orderBy'] }
        : { orderBy?: RecurringDonationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringDonationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringDonationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringDonation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RecurringDonationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    sourceVault<T extends VaultArgs = {}>(args?: Subset<T, VaultArgs>): CheckSelect<T, Prisma__VaultClient<Vault | null >, Prisma__VaultClient<VaultGetPayload<T> | null >>;

    person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RecurringDonation findUnique
   */
  export type RecurringDonationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RecurringDonation
     *
    **/
    select?: RecurringDonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: RecurringDonationInclude | null
    /**
     * Throw an Error if a RecurringDonation can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RecurringDonation to fetch.
     *
    **/
    where: RecurringDonationWhereUniqueInput
  }


  /**
   * RecurringDonation findFirst
   */
  export type RecurringDonationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RecurringDonation
     *
    **/
    select?: RecurringDonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: RecurringDonationInclude | null
    /**
     * Throw an Error if a RecurringDonation can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RecurringDonation to fetch.
     *
    **/
    where?: RecurringDonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RecurringDonations to fetch.
     *
    **/
    orderBy?: Enumerable<RecurringDonationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RecurringDonations.
     *
    **/
    cursor?: RecurringDonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RecurringDonations from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RecurringDonations.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RecurringDonations.
     *
    **/
    distinct?: Enumerable<RecurringDonationScalarFieldEnum>
  }


  /**
   * RecurringDonation findMany
   */
  export type RecurringDonationFindManyArgs = {
    /**
     * Select specific fields to fetch from the RecurringDonation
     *
    **/
    select?: RecurringDonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: RecurringDonationInclude | null
    /**
     * Filter, which RecurringDonations to fetch.
     *
    **/
    where?: RecurringDonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RecurringDonations to fetch.
     *
    **/
    orderBy?: Enumerable<RecurringDonationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RecurringDonations.
     *
    **/
    cursor?: RecurringDonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RecurringDonations from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RecurringDonations.
     *
    **/
    skip?: number
    distinct?: Enumerable<RecurringDonationScalarFieldEnum>
  }


  /**
   * RecurringDonation create
   */
  export type RecurringDonationCreateArgs = {
    /**
     * Select specific fields to fetch from the RecurringDonation
     *
    **/
    select?: RecurringDonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: RecurringDonationInclude | null
    /**
     * The data needed to create a RecurringDonation.
     *
    **/
    data: XOR<RecurringDonationCreateInput, RecurringDonationUncheckedCreateInput>
  }


  /**
   * RecurringDonation createMany
   */
  export type RecurringDonationCreateManyArgs = {
    data: Enumerable<RecurringDonationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RecurringDonation update
   */
  export type RecurringDonationUpdateArgs = {
    /**
     * Select specific fields to fetch from the RecurringDonation
     *
    **/
    select?: RecurringDonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: RecurringDonationInclude | null
    /**
     * The data needed to update a RecurringDonation.
     *
    **/
    data: XOR<RecurringDonationUpdateInput, RecurringDonationUncheckedUpdateInput>
    /**
     * Choose, which RecurringDonation to update.
     *
    **/
    where: RecurringDonationWhereUniqueInput
  }


  /**
   * RecurringDonation updateMany
   */
  export type RecurringDonationUpdateManyArgs = {
    data: XOR<RecurringDonationUpdateManyMutationInput, RecurringDonationUncheckedUpdateManyInput>
    where?: RecurringDonationWhereInput
  }


  /**
   * RecurringDonation upsert
   */
  export type RecurringDonationUpsertArgs = {
    /**
     * Select specific fields to fetch from the RecurringDonation
     *
    **/
    select?: RecurringDonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: RecurringDonationInclude | null
    /**
     * The filter to search for the RecurringDonation to update in case it exists.
     *
    **/
    where: RecurringDonationWhereUniqueInput
    /**
     * In case the RecurringDonation found by the `where` argument doesn't exist, create a new RecurringDonation with this data.
     *
    **/
    create: XOR<RecurringDonationCreateInput, RecurringDonationUncheckedCreateInput>
    /**
     * In case the RecurringDonation was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<RecurringDonationUpdateInput, RecurringDonationUncheckedUpdateInput>
  }


  /**
   * RecurringDonation delete
   */
  export type RecurringDonationDeleteArgs = {
    /**
     * Select specific fields to fetch from the RecurringDonation
     *
    **/
    select?: RecurringDonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: RecurringDonationInclude | null
    /**
     * Filter which RecurringDonation to delete.
     *
    **/
    where: RecurringDonationWhereUniqueInput
  }


  /**
   * RecurringDonation deleteMany
   */
  export type RecurringDonationDeleteManyArgs = {
    where?: RecurringDonationWhereInput
  }


  /**
   * RecurringDonation without action
   */
  export type RecurringDonationArgs = {
    /**
     * Select specific fields to fetch from the RecurringDonation
     *
    **/
    select?: RecurringDonationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: RecurringDonationInclude | null
  }



  /**
   * Model Transfer
   */


  export type AggregateTransfer = {
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  export type TransferAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransferSumAggregateOutputType = {
    amount: number | null
  }

  export type TransferMinAggregateOutputType = {
    id: string | null
    status: TransferStatus | null
    currency: Currency | null
    amount: number | null
    reason: string | null
    sourceVaultId: string | null
    sourceCampaignId: string | null
    targetVaultId: string | null
    targetCampaignId: string | null
    approvedById: string | null
    documentId: string | null
    targetDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferMaxAggregateOutputType = {
    id: string | null
    status: TransferStatus | null
    currency: Currency | null
    amount: number | null
    reason: string | null
    sourceVaultId: string | null
    sourceCampaignId: string | null
    targetVaultId: string | null
    targetCampaignId: string | null
    approvedById: string | null
    documentId: string | null
    targetDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferCountAggregateOutputType = {
    id: number
    status: number
    currency: number
    amount: number
    reason: number
    sourceVaultId: number
    sourceCampaignId: number
    targetVaultId: number
    targetCampaignId: number
    approvedById: number
    documentId: number
    targetDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferAvgAggregateInputType = {
    amount?: true
  }

  export type TransferSumAggregateInputType = {
    amount?: true
  }

  export type TransferMinAggregateInputType = {
    id?: true
    status?: true
    currency?: true
    amount?: true
    reason?: true
    sourceVaultId?: true
    sourceCampaignId?: true
    targetVaultId?: true
    targetCampaignId?: true
    approvedById?: true
    documentId?: true
    targetDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferMaxAggregateInputType = {
    id?: true
    status?: true
    currency?: true
    amount?: true
    reason?: true
    sourceVaultId?: true
    sourceCampaignId?: true
    targetVaultId?: true
    targetCampaignId?: true
    approvedById?: true
    documentId?: true
    targetDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferCountAggregateInputType = {
    id?: true
    status?: true
    currency?: true
    amount?: true
    reason?: true
    sourceVaultId?: true
    sourceCampaignId?: true
    targetVaultId?: true
    targetCampaignId?: true
    approvedById?: true
    documentId?: true
    targetDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferAggregateArgs = {
    /**
     * Filter which Transfer to aggregate.
     *
    **/
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Transfers to fetch.
     *
    **/
    orderBy?: Enumerable<TransferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Transfers from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Transfers.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Transfers
    **/
    _count?: true | TransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: TransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: TransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: TransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: TransferMaxAggregateInputType
  }

  export type GetTransferAggregateType<T extends TransferAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfer[P]>
      : GetScalarType<T[P], AggregateTransfer[P]>
  }




  export type TransferGroupByArgs = {
    where?: TransferWhereInput
    orderBy?: Enumerable<TransferOrderByWithAggregationInput>
    by: Array<TransferScalarFieldEnum>
    having?: TransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferCountAggregateInputType | true
    _avg?: TransferAvgAggregateInputType
    _sum?: TransferSumAggregateInputType
    _min?: TransferMinAggregateInputType
    _max?: TransferMaxAggregateInputType
  }


  export type TransferGroupByOutputType = {
    id: string
    status: TransferStatus
    currency: Currency
    amount: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    targetVaultId: string
    targetCampaignId: string
    approvedById: string | null
    documentId: string | null
    targetDate: Date | null
    createdAt: Date
    updatedAt: Date | null
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  type GetTransferGroupByPayload<T extends TransferGroupByArgs> = Promise<
    Array<
      PickArray<TransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferGroupByOutputType[P]>
            : GetScalarType<T[P], TransferGroupByOutputType[P]>
        }
      >
    >


  export type TransferSelect = {
    id?: boolean
    status?: boolean
    currency?: boolean
    amount?: boolean
    reason?: boolean
    sourceVaultId?: boolean
    sourceCampaignId?: boolean
    targetVaultId?: boolean
    targetCampaignId?: boolean
    approvedById?: boolean
    documentId?: boolean
    targetDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedBy?: boolean | PersonArgs
    sourceVault?: boolean | VaultArgs
    sourceCampaign?: boolean | CampaignArgs
    targetVault?: boolean | VaultArgs
    targetCampaign?: boolean | CampaignArgs
  }

  export type TransferInclude = {
    approvedBy?: boolean | PersonArgs
    sourceVault?: boolean | VaultArgs
    sourceCampaign?: boolean | CampaignArgs
    targetVault?: boolean | VaultArgs
    targetCampaign?: boolean | CampaignArgs
  }

  export type TransferGetPayload<
    S extends boolean | null | undefined | TransferArgs,
    U = keyof S
      > = S extends true
        ? Transfer
    : S extends undefined
    ? never
    : S extends TransferArgs | TransferFindManyArgs
    ?'include' extends U
    ? Transfer  & {
    [P in TrueKeys<S['include']>]:
          P extends 'approvedBy'
        ? PersonGetPayload<S['include'][P]> | null :
        P extends 'sourceVault'
        ? VaultGetPayload<S['include'][P]> :
        P extends 'sourceCampaign'
        ? CampaignGetPayload<S['include'][P]> :
        P extends 'targetVault'
        ? VaultGetPayload<S['include'][P]> :
        P extends 'targetCampaign'
        ? CampaignGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Transfer ?Transfer [P]
  :
          P extends 'approvedBy'
        ? PersonGetPayload<S['select'][P]> | null :
        P extends 'sourceVault'
        ? VaultGetPayload<S['select'][P]> :
        P extends 'sourceCampaign'
        ? CampaignGetPayload<S['select'][P]> :
        P extends 'targetVault'
        ? VaultGetPayload<S['select'][P]> :
        P extends 'targetCampaign'
        ? CampaignGetPayload<S['select'][P]> : never
  }
    : Transfer
  : Transfer


  type TransferCountArgs = Merge<
    Omit<TransferFindManyArgs, 'select' | 'include'> & {
      select?: TransferCountAggregateInputType | true
    }
  >

  export interface TransferDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Transfer that matches the filter.
     * @param {TransferFindUniqueArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransferFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TransferFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Transfer'> extends True ? CheckSelect<T, Prisma__TransferClient<Transfer>, Prisma__TransferClient<TransferGetPayload<T>>> : CheckSelect<T, Prisma__TransferClient<Transfer | null >, Prisma__TransferClient<TransferGetPayload<T> | null >>

    /**
     * Find the first Transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransferFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TransferFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Transfer'> extends True ? CheckSelect<T, Prisma__TransferClient<Transfer>, Prisma__TransferClient<TransferGetPayload<T>>> : CheckSelect<T, Prisma__TransferClient<Transfer | null >, Prisma__TransferClient<TransferGetPayload<T> | null >>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfer.findMany()
     *
     * // Get first 10 Transfers
     * const transfers = await prisma.transfer.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const transferWithIdOnly = await prisma.transfer.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends TransferFindManyArgs>(
      args?: SelectSubset<T, TransferFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Transfer>>, PrismaPromise<Array<TransferGetPayload<T>>>>

    /**
     * Create a Transfer.
     * @param {TransferCreateArgs} args - Arguments to create a Transfer.
     * @example
     * // Create one Transfer
     * const Transfer = await prisma.transfer.create({
     *   data: {
     *     // ... data to create a Transfer
     *   }
     * })
     *
    **/
    create<T extends TransferCreateArgs>(
      args: SelectSubset<T, TransferCreateArgs>
    ): CheckSelect<T, Prisma__TransferClient<Transfer>, Prisma__TransferClient<TransferGetPayload<T>>>

    /**
     * Create many Transfers.
     *     @param {TransferCreateManyArgs} args - Arguments to create many Transfers.
     *     @example
     *     // Create many Transfers
     *     const transfer = await prisma.transfer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends TransferCreateManyArgs>(
      args?: SelectSubset<T, TransferCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Transfer.
     * @param {TransferDeleteArgs} args - Arguments to delete one Transfer.
     * @example
     * // Delete one Transfer
     * const Transfer = await prisma.transfer.delete({
     *   where: {
     *     // ... filter to delete one Transfer
     *   }
     * })
     *
    **/
    delete<T extends TransferDeleteArgs>(
      args: SelectSubset<T, TransferDeleteArgs>
    ): CheckSelect<T, Prisma__TransferClient<Transfer>, Prisma__TransferClient<TransferGetPayload<T>>>

    /**
     * Update one Transfer.
     * @param {TransferUpdateArgs} args - Arguments to update one Transfer.
     * @example
     * // Update one Transfer
     * const transfer = await prisma.transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends TransferUpdateArgs>(
      args: SelectSubset<T, TransferUpdateArgs>
    ): CheckSelect<T, Prisma__TransferClient<Transfer>, Prisma__TransferClient<TransferGetPayload<T>>>

    /**
     * Delete zero or more Transfers.
     * @param {TransferDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends TransferDeleteManyArgs>(
      args?: SelectSubset<T, TransferDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends TransferUpdateManyArgs>(
      args: SelectSubset<T, TransferUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Transfer.
     * @param {TransferUpsertArgs} args - Arguments to update or create a Transfer.
     * @example
     * // Update or create a Transfer
     * const transfer = await prisma.transfer.upsert({
     *   create: {
     *     // ... data to create a Transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfer we want to update
     *   }
     * })
    **/
    upsert<T extends TransferUpsertArgs>(
      args: SelectSubset<T, TransferUpsertArgs>
    ): CheckSelect<T, Prisma__TransferClient<Transfer>, Prisma__TransferClient<TransferGetPayload<T>>>

    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfer.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends TransferCountArgs>(
      args?: Subset<T, TransferCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferAggregateArgs>(args: Subset<T, TransferAggregateArgs>): PrismaPromise<GetTransferAggregateType<T>>

    /**
     * Group by Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends TransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferGroupByArgs['orderBy'] }
        : { orderBy?: TransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TransferClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    approvedBy<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    sourceVault<T extends VaultArgs = {}>(args?: Subset<T, VaultArgs>): CheckSelect<T, Prisma__VaultClient<Vault | null >, Prisma__VaultClient<VaultGetPayload<T> | null >>;

    sourceCampaign<T extends CampaignArgs = {}>(args?: Subset<T, CampaignArgs>): CheckSelect<T, Prisma__CampaignClient<Campaign | null >, Prisma__CampaignClient<CampaignGetPayload<T> | null >>;

    targetVault<T extends VaultArgs = {}>(args?: Subset<T, VaultArgs>): CheckSelect<T, Prisma__VaultClient<Vault | null >, Prisma__VaultClient<VaultGetPayload<T> | null >>;

    targetCampaign<T extends CampaignArgs = {}>(args?: Subset<T, CampaignArgs>): CheckSelect<T, Prisma__CampaignClient<Campaign | null >, Prisma__CampaignClient<CampaignGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Transfer findUnique
   */
  export type TransferFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Transfer
     *
    **/
    select?: TransferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: TransferInclude | null
    /**
     * Throw an Error if a Transfer can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Transfer to fetch.
     *
    **/
    where: TransferWhereUniqueInput
  }


  /**
   * Transfer findFirst
   */
  export type TransferFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Transfer
     *
    **/
    select?: TransferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: TransferInclude | null
    /**
     * Throw an Error if a Transfer can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Transfer to fetch.
     *
    **/
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Transfers to fetch.
     *
    **/
    orderBy?: Enumerable<TransferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Transfers.
     *
    **/
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Transfers from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Transfers.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Transfers.
     *
    **/
    distinct?: Enumerable<TransferScalarFieldEnum>
  }


  /**
   * Transfer findMany
   */
  export type TransferFindManyArgs = {
    /**
     * Select specific fields to fetch from the Transfer
     *
    **/
    select?: TransferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: TransferInclude | null
    /**
     * Filter, which Transfers to fetch.
     *
    **/
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Transfers to fetch.
     *
    **/
    orderBy?: Enumerable<TransferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Transfers.
     *
    **/
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Transfers from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Transfers.
     *
    **/
    skip?: number
    distinct?: Enumerable<TransferScalarFieldEnum>
  }


  /**
   * Transfer create
   */
  export type TransferCreateArgs = {
    /**
     * Select specific fields to fetch from the Transfer
     *
    **/
    select?: TransferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: TransferInclude | null
    /**
     * The data needed to create a Transfer.
     *
    **/
    data: XOR<TransferCreateInput, TransferUncheckedCreateInput>
  }


  /**
   * Transfer createMany
   */
  export type TransferCreateManyArgs = {
    data: Enumerable<TransferCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Transfer update
   */
  export type TransferUpdateArgs = {
    /**
     * Select specific fields to fetch from the Transfer
     *
    **/
    select?: TransferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: TransferInclude | null
    /**
     * The data needed to update a Transfer.
     *
    **/
    data: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
    /**
     * Choose, which Transfer to update.
     *
    **/
    where: TransferWhereUniqueInput
  }


  /**
   * Transfer updateMany
   */
  export type TransferUpdateManyArgs = {
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    where?: TransferWhereInput
  }


  /**
   * Transfer upsert
   */
  export type TransferUpsertArgs = {
    /**
     * Select specific fields to fetch from the Transfer
     *
    **/
    select?: TransferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: TransferInclude | null
    /**
     * The filter to search for the Transfer to update in case it exists.
     *
    **/
    where: TransferWhereUniqueInput
    /**
     * In case the Transfer found by the `where` argument doesn't exist, create a new Transfer with this data.
     *
    **/
    create: XOR<TransferCreateInput, TransferUncheckedCreateInput>
    /**
     * In case the Transfer was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
  }


  /**
   * Transfer delete
   */
  export type TransferDeleteArgs = {
    /**
     * Select specific fields to fetch from the Transfer
     *
    **/
    select?: TransferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: TransferInclude | null
    /**
     * Filter which Transfer to delete.
     *
    **/
    where: TransferWhereUniqueInput
  }


  /**
   * Transfer deleteMany
   */
  export type TransferDeleteManyArgs = {
    where?: TransferWhereInput
  }


  /**
   * Transfer without action
   */
  export type TransferArgs = {
    /**
     * Select specific fields to fetch from the Transfer
     *
    **/
    select?: TransferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: TransferInclude | null
  }



  /**
   * Model Withdrawal
   */


  export type AggregateWithdrawal = {
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  export type WithdrawalAvgAggregateOutputType = {
    amount: number | null
  }

  export type WithdrawalSumAggregateOutputType = {
    amount: number | null
  }

  export type WithdrawalMinAggregateOutputType = {
    id: string | null
    status: WithdrawStatus | null
    currency: Currency | null
    amount: number | null
    reason: string | null
    sourceVaultId: string | null
    sourceCampaignId: string | null
    bankAccountId: string | null
    documentId: string | null
    approvedById: string | null
    targetDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WithdrawalMaxAggregateOutputType = {
    id: string | null
    status: WithdrawStatus | null
    currency: Currency | null
    amount: number | null
    reason: string | null
    sourceVaultId: string | null
    sourceCampaignId: string | null
    bankAccountId: string | null
    documentId: string | null
    approvedById: string | null
    targetDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WithdrawalCountAggregateOutputType = {
    id: number
    status: number
    currency: number
    amount: number
    reason: number
    sourceVaultId: number
    sourceCampaignId: number
    bankAccountId: number
    documentId: number
    approvedById: number
    targetDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WithdrawalAvgAggregateInputType = {
    amount?: true
  }

  export type WithdrawalSumAggregateInputType = {
    amount?: true
  }

  export type WithdrawalMinAggregateInputType = {
    id?: true
    status?: true
    currency?: true
    amount?: true
    reason?: true
    sourceVaultId?: true
    sourceCampaignId?: true
    bankAccountId?: true
    documentId?: true
    approvedById?: true
    targetDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WithdrawalMaxAggregateInputType = {
    id?: true
    status?: true
    currency?: true
    amount?: true
    reason?: true
    sourceVaultId?: true
    sourceCampaignId?: true
    bankAccountId?: true
    documentId?: true
    approvedById?: true
    targetDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WithdrawalCountAggregateInputType = {
    id?: true
    status?: true
    currency?: true
    amount?: true
    reason?: true
    sourceVaultId?: true
    sourceCampaignId?: true
    bankAccountId?: true
    documentId?: true
    approvedById?: true
    targetDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WithdrawalAggregateArgs = {
    /**
     * Filter which Withdrawal to aggregate.
     *
    **/
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Withdrawals to fetch.
     *
    **/
    orderBy?: Enumerable<WithdrawalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Withdrawals from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Withdrawals.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Withdrawals
    **/
    _count?: true | WithdrawalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: WithdrawalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: WithdrawalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: WithdrawalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: WithdrawalMaxAggregateInputType
  }

  export type GetWithdrawalAggregateType<T extends WithdrawalAggregateArgs> = {
        [P in keyof T & keyof AggregateWithdrawal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWithdrawal[P]>
      : GetScalarType<T[P], AggregateWithdrawal[P]>
  }




  export type WithdrawalGroupByArgs = {
    where?: WithdrawalWhereInput
    orderBy?: Enumerable<WithdrawalOrderByWithAggregationInput>
    by: Array<WithdrawalScalarFieldEnum>
    having?: WithdrawalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WithdrawalCountAggregateInputType | true
    _avg?: WithdrawalAvgAggregateInputType
    _sum?: WithdrawalSumAggregateInputType
    _min?: WithdrawalMinAggregateInputType
    _max?: WithdrawalMaxAggregateInputType
  }


  export type WithdrawalGroupByOutputType = {
    id: string
    status: WithdrawStatus
    currency: Currency
    amount: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    bankAccountId: string
    documentId: string | null
    approvedById: string | null
    targetDate: Date | null
    createdAt: Date
    updatedAt: Date | null
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  type GetWithdrawalGroupByPayload<T extends WithdrawalGroupByArgs> = Promise<
    Array<
      PickArray<WithdrawalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WithdrawalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
            : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
        }
      >
    >


  export type WithdrawalSelect = {
    id?: boolean
    status?: boolean
    currency?: boolean
    amount?: boolean
    reason?: boolean
    sourceVaultId?: boolean
    sourceCampaignId?: boolean
    bankAccountId?: boolean
    documentId?: boolean
    approvedById?: boolean
    targetDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedBy?: boolean | PersonArgs
    sourceVault?: boolean | VaultArgs
    sourceCampaign?: boolean | CampaignArgs
    bankAccount?: boolean | BankAccountArgs
  }

  export type WithdrawalInclude = {
    approvedBy?: boolean | PersonArgs
    sourceVault?: boolean | VaultArgs
    sourceCampaign?: boolean | CampaignArgs
    bankAccount?: boolean | BankAccountArgs
  }

  export type WithdrawalGetPayload<
    S extends boolean | null | undefined | WithdrawalArgs,
    U = keyof S
      > = S extends true
        ? Withdrawal
    : S extends undefined
    ? never
    : S extends WithdrawalArgs | WithdrawalFindManyArgs
    ?'include' extends U
    ? Withdrawal  & {
    [P in TrueKeys<S['include']>]:
          P extends 'approvedBy'
        ? PersonGetPayload<S['include'][P]> | null :
        P extends 'sourceVault'
        ? VaultGetPayload<S['include'][P]> :
        P extends 'sourceCampaign'
        ? CampaignGetPayload<S['include'][P]> :
        P extends 'bankAccount'
        ? BankAccountGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Withdrawal ?Withdrawal [P]
  :
          P extends 'approvedBy'
        ? PersonGetPayload<S['select'][P]> | null :
        P extends 'sourceVault'
        ? VaultGetPayload<S['select'][P]> :
        P extends 'sourceCampaign'
        ? CampaignGetPayload<S['select'][P]> :
        P extends 'bankAccount'
        ? BankAccountGetPayload<S['select'][P]> : never
  }
    : Withdrawal
  : Withdrawal


  type WithdrawalCountArgs = Merge<
    Omit<WithdrawalFindManyArgs, 'select' | 'include'> & {
      select?: WithdrawalCountAggregateInputType | true
    }
  >

  export interface WithdrawalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Withdrawal that matches the filter.
     * @param {WithdrawalFindUniqueArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WithdrawalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WithdrawalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Withdrawal'> extends True ? CheckSelect<T, Prisma__WithdrawalClient<Withdrawal>, Prisma__WithdrawalClient<WithdrawalGetPayload<T>>> : CheckSelect<T, Prisma__WithdrawalClient<Withdrawal | null >, Prisma__WithdrawalClient<WithdrawalGetPayload<T> | null >>

    /**
     * Find the first Withdrawal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindFirstArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WithdrawalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WithdrawalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Withdrawal'> extends True ? CheckSelect<T, Prisma__WithdrawalClient<Withdrawal>, Prisma__WithdrawalClient<WithdrawalGetPayload<T>>> : CheckSelect<T, Prisma__WithdrawalClient<Withdrawal | null >, Prisma__WithdrawalClient<WithdrawalGetPayload<T> | null >>

    /**
     * Find zero or more Withdrawals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany()
     *
     * // Get first 10 Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends WithdrawalFindManyArgs>(
      args?: SelectSubset<T, WithdrawalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Withdrawal>>, PrismaPromise<Array<WithdrawalGetPayload<T>>>>

    /**
     * Create a Withdrawal.
     * @param {WithdrawalCreateArgs} args - Arguments to create a Withdrawal.
     * @example
     * // Create one Withdrawal
     * const Withdrawal = await prisma.withdrawal.create({
     *   data: {
     *     // ... data to create a Withdrawal
     *   }
     * })
     *
    **/
    create<T extends WithdrawalCreateArgs>(
      args: SelectSubset<T, WithdrawalCreateArgs>
    ): CheckSelect<T, Prisma__WithdrawalClient<Withdrawal>, Prisma__WithdrawalClient<WithdrawalGetPayload<T>>>

    /**
     * Create many Withdrawals.
     *     @param {WithdrawalCreateManyArgs} args - Arguments to create many Withdrawals.
     *     @example
     *     // Create many Withdrawals
     *     const withdrawal = await prisma.withdrawal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends WithdrawalCreateManyArgs>(
      args?: SelectSubset<T, WithdrawalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Withdrawal.
     * @param {WithdrawalDeleteArgs} args - Arguments to delete one Withdrawal.
     * @example
     * // Delete one Withdrawal
     * const Withdrawal = await prisma.withdrawal.delete({
     *   where: {
     *     // ... filter to delete one Withdrawal
     *   }
     * })
     *
    **/
    delete<T extends WithdrawalDeleteArgs>(
      args: SelectSubset<T, WithdrawalDeleteArgs>
    ): CheckSelect<T, Prisma__WithdrawalClient<Withdrawal>, Prisma__WithdrawalClient<WithdrawalGetPayload<T>>>

    /**
     * Update one Withdrawal.
     * @param {WithdrawalUpdateArgs} args - Arguments to update one Withdrawal.
     * @example
     * // Update one Withdrawal
     * const withdrawal = await prisma.withdrawal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends WithdrawalUpdateArgs>(
      args: SelectSubset<T, WithdrawalUpdateArgs>
    ): CheckSelect<T, Prisma__WithdrawalClient<Withdrawal>, Prisma__WithdrawalClient<WithdrawalGetPayload<T>>>

    /**
     * Delete zero or more Withdrawals.
     * @param {WithdrawalDeleteManyArgs} args - Arguments to filter Withdrawals to delete.
     * @example
     * // Delete a few Withdrawals
     * const { count } = await prisma.withdrawal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends WithdrawalDeleteManyArgs>(
      args?: SelectSubset<T, WithdrawalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Withdrawals
     * const withdrawal = await prisma.withdrawal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends WithdrawalUpdateManyArgs>(
      args: SelectSubset<T, WithdrawalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Withdrawal.
     * @param {WithdrawalUpsertArgs} args - Arguments to update or create a Withdrawal.
     * @example
     * // Update or create a Withdrawal
     * const withdrawal = await prisma.withdrawal.upsert({
     *   create: {
     *     // ... data to create a Withdrawal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Withdrawal we want to update
     *   }
     * })
    **/
    upsert<T extends WithdrawalUpsertArgs>(
      args: SelectSubset<T, WithdrawalUpsertArgs>
    ): CheckSelect<T, Prisma__WithdrawalClient<Withdrawal>, Prisma__WithdrawalClient<WithdrawalGetPayload<T>>>

    /**
     * Count the number of Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalCountArgs} args - Arguments to filter Withdrawals to count.
     * @example
     * // Count the number of Withdrawals
     * const count = await prisma.withdrawal.count({
     *   where: {
     *     // ... the filter for the Withdrawals we want to count
     *   }
     * })
    **/
    count<T extends WithdrawalCountArgs>(
      args?: Subset<T, WithdrawalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WithdrawalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WithdrawalAggregateArgs>(args: Subset<T, WithdrawalAggregateArgs>): PrismaPromise<GetWithdrawalAggregateType<T>>

    /**
     * Group by Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends WithdrawalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WithdrawalGroupByArgs['orderBy'] }
        : { orderBy?: WithdrawalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WithdrawalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWithdrawalGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Withdrawal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WithdrawalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    approvedBy<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    sourceVault<T extends VaultArgs = {}>(args?: Subset<T, VaultArgs>): CheckSelect<T, Prisma__VaultClient<Vault | null >, Prisma__VaultClient<VaultGetPayload<T> | null >>;

    sourceCampaign<T extends CampaignArgs = {}>(args?: Subset<T, CampaignArgs>): CheckSelect<T, Prisma__CampaignClient<Campaign | null >, Prisma__CampaignClient<CampaignGetPayload<T> | null >>;

    bankAccount<T extends BankAccountArgs = {}>(args?: Subset<T, BankAccountArgs>): CheckSelect<T, Prisma__BankAccountClient<BankAccount | null >, Prisma__BankAccountClient<BankAccountGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Withdrawal findUnique
   */
  export type WithdrawalFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Withdrawal
     *
    **/
    select?: WithdrawalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: WithdrawalInclude | null
    /**
     * Throw an Error if a Withdrawal can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Withdrawal to fetch.
     *
    **/
    where: WithdrawalWhereUniqueInput
  }


  /**
   * Withdrawal findFirst
   */
  export type WithdrawalFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Withdrawal
     *
    **/
    select?: WithdrawalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: WithdrawalInclude | null
    /**
     * Throw an Error if a Withdrawal can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Withdrawal to fetch.
     *
    **/
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Withdrawals to fetch.
     *
    **/
    orderBy?: Enumerable<WithdrawalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Withdrawals.
     *
    **/
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Withdrawals from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Withdrawals.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Withdrawals.
     *
    **/
    distinct?: Enumerable<WithdrawalScalarFieldEnum>
  }


  /**
   * Withdrawal findMany
   */
  export type WithdrawalFindManyArgs = {
    /**
     * Select specific fields to fetch from the Withdrawal
     *
    **/
    select?: WithdrawalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: WithdrawalInclude | null
    /**
     * Filter, which Withdrawals to fetch.
     *
    **/
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Withdrawals to fetch.
     *
    **/
    orderBy?: Enumerable<WithdrawalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Withdrawals.
     *
    **/
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Withdrawals from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Withdrawals.
     *
    **/
    skip?: number
    distinct?: Enumerable<WithdrawalScalarFieldEnum>
  }


  /**
   * Withdrawal create
   */
  export type WithdrawalCreateArgs = {
    /**
     * Select specific fields to fetch from the Withdrawal
     *
    **/
    select?: WithdrawalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: WithdrawalInclude | null
    /**
     * The data needed to create a Withdrawal.
     *
    **/
    data: XOR<WithdrawalCreateInput, WithdrawalUncheckedCreateInput>
  }


  /**
   * Withdrawal createMany
   */
  export type WithdrawalCreateManyArgs = {
    data: Enumerable<WithdrawalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Withdrawal update
   */
  export type WithdrawalUpdateArgs = {
    /**
     * Select specific fields to fetch from the Withdrawal
     *
    **/
    select?: WithdrawalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: WithdrawalInclude | null
    /**
     * The data needed to update a Withdrawal.
     *
    **/
    data: XOR<WithdrawalUpdateInput, WithdrawalUncheckedUpdateInput>
    /**
     * Choose, which Withdrawal to update.
     *
    **/
    where: WithdrawalWhereUniqueInput
  }


  /**
   * Withdrawal updateMany
   */
  export type WithdrawalUpdateManyArgs = {
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyInput>
    where?: WithdrawalWhereInput
  }


  /**
   * Withdrawal upsert
   */
  export type WithdrawalUpsertArgs = {
    /**
     * Select specific fields to fetch from the Withdrawal
     *
    **/
    select?: WithdrawalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: WithdrawalInclude | null
    /**
     * The filter to search for the Withdrawal to update in case it exists.
     *
    **/
    where: WithdrawalWhereUniqueInput
    /**
     * In case the Withdrawal found by the `where` argument doesn't exist, create a new Withdrawal with this data.
     *
    **/
    create: XOR<WithdrawalCreateInput, WithdrawalUncheckedCreateInput>
    /**
     * In case the Withdrawal was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<WithdrawalUpdateInput, WithdrawalUncheckedUpdateInput>
  }


  /**
   * Withdrawal delete
   */
  export type WithdrawalDeleteArgs = {
    /**
     * Select specific fields to fetch from the Withdrawal
     *
    **/
    select?: WithdrawalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: WithdrawalInclude | null
    /**
     * Filter which Withdrawal to delete.
     *
    **/
    where: WithdrawalWhereUniqueInput
  }


  /**
   * Withdrawal deleteMany
   */
  export type WithdrawalDeleteManyArgs = {
    where?: WithdrawalWhereInput
  }


  /**
   * Withdrawal without action
   */
  export type WithdrawalArgs = {
    /**
     * Select specific fields to fetch from the Withdrawal
     *
    **/
    select?: WithdrawalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: WithdrawalInclude | null
  }



  /**
   * Model BankAccount
   */


  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountMinAggregateOutputType = {
    id: string | null
    status: BankAccountStatus | null
    ibanNumber: string | null
    accountHolderName: string | null
    accountHolderType: AccountHolderType | null
    bankName: string | null
    bankIdCode: string | null
    fingerprint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountMaxAggregateOutputType = {
    id: string | null
    status: BankAccountStatus | null
    ibanNumber: string | null
    accountHolderName: string | null
    accountHolderType: AccountHolderType | null
    bankName: string | null
    bankIdCode: string | null
    fingerprint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountCountAggregateOutputType = {
    id: number
    status: number
    ibanNumber: number
    accountHolderName: number
    accountHolderType: number
    bankName: number
    bankIdCode: number
    fingerprint: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankAccountMinAggregateInputType = {
    id?: true
    status?: true
    ibanNumber?: true
    accountHolderName?: true
    accountHolderType?: true
    bankName?: true
    bankIdCode?: true
    fingerprint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountMaxAggregateInputType = {
    id?: true
    status?: true
    ibanNumber?: true
    accountHolderName?: true
    accountHolderType?: true
    bankName?: true
    bankIdCode?: true
    fingerprint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountCountAggregateInputType = {
    id?: true
    status?: true
    ibanNumber?: true
    accountHolderName?: true
    accountHolderType?: true
    bankName?: true
    bankIdCode?: true
    fingerprint?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankAccountAggregateArgs = {
    /**
     * Filter which BankAccount to aggregate.
     *
    **/
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BankAccounts to fetch.
     *
    **/
    orderBy?: Enumerable<BankAccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BankAccounts from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BankAccounts.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs = {
    where?: BankAccountWhereInput
    orderBy?: Enumerable<BankAccountOrderByWithAggregationInput>
    by: Array<BankAccountScalarFieldEnum>
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }


  export type BankAccountGroupByOutputType = {
    id: string
    status: BankAccountStatus
    ibanNumber: string
    accountHolderName: string
    accountHolderType: AccountHolderType
    bankName: string | null
    bankIdCode: string | null
    fingerprint: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: BankAccountCountAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = Promise<
    Array<
      PickArray<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect = {
    id?: boolean
    status?: boolean
    ibanNumber?: boolean
    accountHolderName?: boolean
    accountHolderType?: boolean
    bankName?: boolean
    bankIdCode?: boolean
    fingerprint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    withdraws?: boolean | WithdrawalFindManyArgs
    _count?: boolean | BankAccountCountOutputTypeArgs
  }

  export type BankAccountInclude = {
    withdraws?: boolean | WithdrawalFindManyArgs
    _count?: boolean | BankAccountCountOutputTypeArgs
  }

  export type BankAccountGetPayload<
    S extends boolean | null | undefined | BankAccountArgs,
    U = keyof S
      > = S extends true
        ? BankAccount
    : S extends undefined
    ? never
    : S extends BankAccountArgs | BankAccountFindManyArgs
    ?'include' extends U
    ? BankAccount  & {
    [P in TrueKeys<S['include']>]:
          P extends 'withdraws'
        ? Array < WithdrawalGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? BankAccountCountOutputTypeGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof BankAccount ?BankAccount [P]
  :
          P extends 'withdraws'
        ? Array < WithdrawalGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? BankAccountCountOutputTypeGetPayload<S['select'][P]> : never
  }
    : BankAccount
  : BankAccount


  type BankAccountCountArgs = Merge<
    Omit<BankAccountFindManyArgs, 'select' | 'include'> & {
      select?: BankAccountCountAggregateInputType | true
    }
  >

  export interface BankAccountDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BankAccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BankAccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BankAccount'> extends True ? CheckSelect<T, Prisma__BankAccountClient<BankAccount>, Prisma__BankAccountClient<BankAccountGetPayload<T>>> : CheckSelect<T, Prisma__BankAccountClient<BankAccount | null >, Prisma__BankAccountClient<BankAccountGetPayload<T> | null >>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BankAccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BankAccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BankAccount'> extends True ? CheckSelect<T, Prisma__BankAccountClient<BankAccount>, Prisma__BankAccountClient<BankAccountGetPayload<T>>> : CheckSelect<T, Prisma__BankAccountClient<BankAccount | null >, Prisma__BankAccountClient<BankAccountGetPayload<T> | null >>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     *
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends BankAccountFindManyArgs>(
      args?: SelectSubset<T, BankAccountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<BankAccount>>, PrismaPromise<Array<BankAccountGetPayload<T>>>>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     *
    **/
    create<T extends BankAccountCreateArgs>(
      args: SelectSubset<T, BankAccountCreateArgs>
    ): CheckSelect<T, Prisma__BankAccountClient<BankAccount>, Prisma__BankAccountClient<BankAccountGetPayload<T>>>

    /**
     * Create many BankAccounts.
     *     @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     *     @example
     *     // Create many BankAccounts
     *     const bankAccount = await prisma.bankAccount.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends BankAccountCreateManyArgs>(
      args?: SelectSubset<T, BankAccountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     *
    **/
    delete<T extends BankAccountDeleteArgs>(
      args: SelectSubset<T, BankAccountDeleteArgs>
    ): CheckSelect<T, Prisma__BankAccountClient<BankAccount>, Prisma__BankAccountClient<BankAccountGetPayload<T>>>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends BankAccountUpdateArgs>(
      args: SelectSubset<T, BankAccountUpdateArgs>
    ): CheckSelect<T, Prisma__BankAccountClient<BankAccount>, Prisma__BankAccountClient<BankAccountGetPayload<T>>>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends BankAccountDeleteManyArgs>(
      args?: SelectSubset<T, BankAccountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends BankAccountUpdateManyArgs>(
      args: SelectSubset<T, BankAccountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
    **/
    upsert<T extends BankAccountUpsertArgs>(
      args: SelectSubset<T, BankAccountUpsertArgs>
    ): CheckSelect<T, Prisma__BankAccountClient<BankAccount>, Prisma__BankAccountClient<BankAccountGetPayload<T>>>

    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BankAccountClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    withdraws<T extends WithdrawalFindManyArgs = {}>(args?: Subset<T, WithdrawalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Withdrawal>>, PrismaPromise<Array<WithdrawalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     *
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BankAccountInclude | null
    /**
     * Throw an Error if a BankAccount can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which BankAccount to fetch.
     *
    **/
    where: BankAccountWhereUniqueInput
  }


  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     *
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BankAccountInclude | null
    /**
     * Throw an Error if a BankAccount can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which BankAccount to fetch.
     *
    **/
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BankAccounts to fetch.
     *
    **/
    orderBy?: Enumerable<BankAccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for BankAccounts.
     *
    **/
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BankAccounts from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BankAccounts.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of BankAccounts.
     *
    **/
    distinct?: Enumerable<BankAccountScalarFieldEnum>
  }


  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     *
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BankAccountInclude | null
    /**
     * Filter, which BankAccounts to fetch.
     *
    **/
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BankAccounts to fetch.
     *
    **/
    orderBy?: Enumerable<BankAccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing BankAccounts.
     *
    **/
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BankAccounts from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BankAccounts.
     *
    **/
    skip?: number
    distinct?: Enumerable<BankAccountScalarFieldEnum>
  }


  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     *
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BankAccountInclude | null
    /**
     * The data needed to create a BankAccount.
     *
    **/
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }


  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs = {
    data: Enumerable<BankAccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     *
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BankAccountInclude | null
    /**
     * The data needed to update a BankAccount.
     *
    **/
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     *
    **/
    where: BankAccountWhereUniqueInput
  }


  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs = {
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    where?: BankAccountWhereInput
  }


  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     *
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BankAccountInclude | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     *
    **/
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     *
    **/
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }


  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     *
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BankAccountInclude | null
    /**
     * Filter which BankAccount to delete.
     *
    **/
    where: BankAccountWhereUniqueInput
  }


  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs = {
    where?: BankAccountWhereInput
  }


  /**
   * BankAccount without action
   */
  export type BankAccountArgs = {
    /**
     * Select specific fields to fetch from the BankAccount
     *
    **/
    select?: BankAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: BankAccountInclude | null
  }



  /**
   * Model Expense
   */


  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    type: ExpenseType | null
    currency: Currency | null
    amount: number | null
    description: string | null
    vaultId: string | null
    documentId: string | null
    approvedById: string | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    type: ExpenseType | null
    currency: Currency | null
    amount: number | null
    description: string | null
    vaultId: string | null
    documentId: string | null
    approvedById: string | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    type: number
    currency: number
    amount: number
    description: number
    vaultId: number
    documentId: number
    approvedById: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    type?: true
    currency?: true
    amount?: true
    description?: true
    vaultId?: true
    documentId?: true
    approvedById?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    type?: true
    currency?: true
    amount?: true
    description?: true
    vaultId?: true
    documentId?: true
    approvedById?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    type?: true
    currency?: true
    amount?: true
    description?: true
    vaultId?: true
    documentId?: true
    approvedById?: true
    _all?: true
  }

  export type ExpenseAggregateArgs = {
    /**
     * Filter which Expense to aggregate.
     *
    **/
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Expenses to fetch.
     *
    **/
    orderBy?: Enumerable<ExpenseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Expenses from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Expenses.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs = {
    where?: ExpenseWhereInput
    orderBy?: Enumerable<ExpenseOrderByWithAggregationInput>
    by: Array<ExpenseScalarFieldEnum>
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }


  export type ExpenseGroupByOutputType = {
    id: string
    type: ExpenseType
    currency: Currency
    amount: number
    description: string | null
    vaultId: string
    documentId: string | null
    approvedById: string | null
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Promise<
    Array<
      PickArray<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect = {
    id?: boolean
    type?: boolean
    currency?: boolean
    amount?: boolean
    description?: boolean
    vaultId?: boolean
    documentId?: boolean
    approvedById?: boolean
    vault?: boolean | VaultArgs
    approvedBy?: boolean | PersonArgs
    document?: boolean | DocumentArgs
  }

  export type ExpenseInclude = {
    vault?: boolean | VaultArgs
    approvedBy?: boolean | PersonArgs
    document?: boolean | DocumentArgs
  }

  export type ExpenseGetPayload<
    S extends boolean | null | undefined | ExpenseArgs,
    U = keyof S
      > = S extends true
        ? Expense
    : S extends undefined
    ? never
    : S extends ExpenseArgs | ExpenseFindManyArgs
    ?'include' extends U
    ? Expense  & {
    [P in TrueKeys<S['include']>]:
          P extends 'vault'
        ? VaultGetPayload<S['include'][P]> :
        P extends 'approvedBy'
        ? PersonGetPayload<S['include'][P]> | null :
        P extends 'document'
        ? DocumentGetPayload<S['include'][P]> | null : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Expense ?Expense [P]
  :
          P extends 'vault'
        ? VaultGetPayload<S['select'][P]> :
        P extends 'approvedBy'
        ? PersonGetPayload<S['select'][P]> | null :
        P extends 'document'
        ? DocumentGetPayload<S['select'][P]> | null : never
  }
    : Expense
  : Expense


  type ExpenseCountArgs = Merge<
    Omit<ExpenseFindManyArgs, 'select' | 'include'> & {
      select?: ExpenseCountAggregateInputType | true
    }
  >

  export interface ExpenseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExpenseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExpenseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Expense'> extends True ? CheckSelect<T, Prisma__ExpenseClient<Expense>, Prisma__ExpenseClient<ExpenseGetPayload<T>>> : CheckSelect<T, Prisma__ExpenseClient<Expense | null >, Prisma__ExpenseClient<ExpenseGetPayload<T> | null >>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExpenseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExpenseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Expense'> extends True ? CheckSelect<T, Prisma__ExpenseClient<Expense>, Prisma__ExpenseClient<ExpenseGetPayload<T>>> : CheckSelect<T, Prisma__ExpenseClient<Expense | null >, Prisma__ExpenseClient<ExpenseGetPayload<T> | null >>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     *
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends ExpenseFindManyArgs>(
      args?: SelectSubset<T, ExpenseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Expense>>, PrismaPromise<Array<ExpenseGetPayload<T>>>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     *
    **/
    create<T extends ExpenseCreateArgs>(
      args: SelectSubset<T, ExpenseCreateArgs>
    ): CheckSelect<T, Prisma__ExpenseClient<Expense>, Prisma__ExpenseClient<ExpenseGetPayload<T>>>

    /**
     * Create many Expenses.
     *     @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     *     @example
     *     // Create many Expenses
     *     const expense = await prisma.expense.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends ExpenseCreateManyArgs>(
      args?: SelectSubset<T, ExpenseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     *
    **/
    delete<T extends ExpenseDeleteArgs>(
      args: SelectSubset<T, ExpenseDeleteArgs>
    ): CheckSelect<T, Prisma__ExpenseClient<Expense>, Prisma__ExpenseClient<ExpenseGetPayload<T>>>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends ExpenseUpdateArgs>(
      args: SelectSubset<T, ExpenseUpdateArgs>
    ): CheckSelect<T, Prisma__ExpenseClient<Expense>, Prisma__ExpenseClient<ExpenseGetPayload<T>>>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends ExpenseDeleteManyArgs>(
      args?: SelectSubset<T, ExpenseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends ExpenseUpdateManyArgs>(
      args: SelectSubset<T, ExpenseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
    **/
    upsert<T extends ExpenseUpsertArgs>(
      args: SelectSubset<T, ExpenseUpsertArgs>
    ): CheckSelect<T, Prisma__ExpenseClient<Expense>, Prisma__ExpenseClient<ExpenseGetPayload<T>>>

    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExpenseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vault<T extends VaultArgs = {}>(args?: Subset<T, VaultArgs>): CheckSelect<T, Prisma__VaultClient<Vault | null >, Prisma__VaultClient<VaultGetPayload<T> | null >>;

    approvedBy<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    document<T extends DocumentArgs = {}>(args?: Subset<T, DocumentArgs>): CheckSelect<T, Prisma__DocumentClient<Document | null >, Prisma__DocumentClient<DocumentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Expense
     *
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: ExpenseInclude | null
    /**
     * Throw an Error if a Expense can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Expense to fetch.
     *
    **/
    where: ExpenseWhereUniqueInput
  }


  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Expense
     *
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: ExpenseInclude | null
    /**
     * Throw an Error if a Expense can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Expense to fetch.
     *
    **/
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Expenses to fetch.
     *
    **/
    orderBy?: Enumerable<ExpenseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Expenses.
     *
    **/
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Expenses from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Expenses.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Expenses.
     *
    **/
    distinct?: Enumerable<ExpenseScalarFieldEnum>
  }


  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs = {
    /**
     * Select specific fields to fetch from the Expense
     *
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: ExpenseInclude | null
    /**
     * Filter, which Expenses to fetch.
     *
    **/
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Expenses to fetch.
     *
    **/
    orderBy?: Enumerable<ExpenseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Expenses.
     *
    **/
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Expenses from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Expenses.
     *
    **/
    skip?: number
    distinct?: Enumerable<ExpenseScalarFieldEnum>
  }


  /**
   * Expense create
   */
  export type ExpenseCreateArgs = {
    /**
     * Select specific fields to fetch from the Expense
     *
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: ExpenseInclude | null
    /**
     * The data needed to create a Expense.
     *
    **/
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }


  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs = {
    data: Enumerable<ExpenseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Expense update
   */
  export type ExpenseUpdateArgs = {
    /**
     * Select specific fields to fetch from the Expense
     *
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: ExpenseInclude | null
    /**
     * The data needed to update a Expense.
     *
    **/
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     *
    **/
    where: ExpenseWhereUniqueInput
  }


  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs = {
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    where?: ExpenseWhereInput
  }


  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs = {
    /**
     * Select specific fields to fetch from the Expense
     *
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: ExpenseInclude | null
    /**
     * The filter to search for the Expense to update in case it exists.
     *
    **/
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     *
    **/
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }


  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs = {
    /**
     * Select specific fields to fetch from the Expense
     *
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: ExpenseInclude | null
    /**
     * Filter which Expense to delete.
     *
    **/
    where: ExpenseWhereUniqueInput
  }


  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs = {
    where?: ExpenseWhereInput
  }


  /**
   * Expense without action
   */
  export type ExpenseArgs = {
    /**
     * Select specific fields to fetch from the Expense
     *
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: ExpenseInclude | null
  }



  /**
   * Model Document
   */


  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    type: DocumentType | null
    name: string | null
    filename: string | null
    filetype: string | null
    description: string | null
    sourceUrl: string | null
    ownerId: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    type: DocumentType | null
    name: string | null
    filename: string | null
    filetype: string | null
    description: string | null
    sourceUrl: string | null
    ownerId: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    type: number
    name: number
    filename: number
    filetype: number
    description: number
    sourceUrl: number
    ownerId: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    filename?: true
    filetype?: true
    description?: true
    sourceUrl?: true
    ownerId?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    filename?: true
    filetype?: true
    description?: true
    sourceUrl?: true
    ownerId?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    filename?: true
    filetype?: true
    description?: true
    sourceUrl?: true
    ownerId?: true
    _all?: true
  }

  export type DocumentAggregateArgs = {
    /**
     * Filter which Document to aggregate.
     *
    **/
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     *
    **/
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     *
    **/
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs = {
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithAggregationInput>
    by: Array<DocumentScalarFieldEnum>
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }


  export type DocumentGroupByOutputType = {
    id: string
    type: DocumentType
    name: string
    filename: string
    filetype: string | null
    description: string | null
    sourceUrl: string
    ownerId: string
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Promise<
    Array<
      PickArray<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect = {
    id?: boolean
    type?: boolean
    name?: boolean
    filename?: boolean
    filetype?: boolean
    description?: boolean
    sourceUrl?: boolean
    ownerId?: boolean
    owner?: boolean | PersonArgs
    expenses?: boolean | ExpenseFindManyArgs
    _count?: boolean | DocumentCountOutputTypeArgs
  }

  export type DocumentInclude = {
    owner?: boolean | PersonArgs
    expenses?: boolean | ExpenseFindManyArgs
    _count?: boolean | DocumentCountOutputTypeArgs
  }

  export type DocumentGetPayload<
    S extends boolean | null | undefined | DocumentArgs,
    U = keyof S
      > = S extends true
        ? Document
    : S extends undefined
    ? never
    : S extends DocumentArgs | DocumentFindManyArgs
    ?'include' extends U
    ? Document  & {
    [P in TrueKeys<S['include']>]:
          P extends 'owner'
        ? PersonGetPayload<S['include'][P]> :
        P extends 'expenses'
        ? Array < ExpenseGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? DocumentCountOutputTypeGetPayload<S['include'][P]> : never
  }
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Document ?Document [P]
  :
          P extends 'owner'
        ? PersonGetPayload<S['select'][P]> :
        P extends 'expenses'
        ? Array < ExpenseGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? DocumentCountOutputTypeGetPayload<S['select'][P]> : never
  }
    : Document
  : Document


  type DocumentCountArgs = Merge<
    Omit<DocumentFindManyArgs, 'select' | 'include'> & {
      select?: DocumentCountAggregateInputType | true
    }
  >

  export interface DocumentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Document'> extends True ? CheckSelect<T, Prisma__DocumentClient<Document>, Prisma__DocumentClient<DocumentGetPayload<T>>> : CheckSelect<T, Prisma__DocumentClient<Document | null >, Prisma__DocumentClient<DocumentGetPayload<T> | null >>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Document'> extends True ? CheckSelect<T, Prisma__DocumentClient<Document>, Prisma__DocumentClient<DocumentGetPayload<T>>> : CheckSelect<T, Prisma__DocumentClient<Document | null >, Prisma__DocumentClient<DocumentGetPayload<T> | null >>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     *
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     *
    **/
    findMany<T extends DocumentFindManyArgs>(
      args?: SelectSubset<T, DocumentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Document>>, PrismaPromise<Array<DocumentGetPayload<T>>>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     *
    **/
    create<T extends DocumentCreateArgs>(
      args: SelectSubset<T, DocumentCreateArgs>
    ): CheckSelect<T, Prisma__DocumentClient<Document>, Prisma__DocumentClient<DocumentGetPayload<T>>>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *
    **/
    createMany<T extends DocumentCreateManyArgs>(
      args?: SelectSubset<T, DocumentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     *
    **/
    delete<T extends DocumentDeleteArgs>(
      args: SelectSubset<T, DocumentDeleteArgs>
    ): CheckSelect<T, Prisma__DocumentClient<Document>, Prisma__DocumentClient<DocumentGetPayload<T>>>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    update<T extends DocumentUpdateArgs>(
      args: SelectSubset<T, DocumentUpdateArgs>
    ): CheckSelect<T, Prisma__DocumentClient<Document>, Prisma__DocumentClient<DocumentGetPayload<T>>>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
    **/
    deleteMany<T extends DocumentDeleteManyArgs>(
      args?: SelectSubset<T, DocumentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
    **/
    updateMany<T extends DocumentUpdateManyArgs>(
      args: SelectSubset<T, DocumentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs>(
      args: SelectSubset<T, DocumentUpsertArgs>
    ): CheckSelect<T, Prisma__DocumentClient<Document>, Prisma__DocumentClient<DocumentGetPayload<T>>>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    owner<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null >, Prisma__PersonClient<PersonGetPayload<T> | null >>;

    expenses<T extends ExpenseFindManyArgs = {}>(args?: Subset<T, ExpenseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Expense>>, PrismaPromise<Array<ExpenseGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Document
     *
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DocumentInclude | null
    /**
     * Throw an Error if a Document can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Document to fetch.
     *
    **/
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Document
     *
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DocumentInclude | null
    /**
     * Throw an Error if a Document can't be found
     *
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Document to fetch.
     *
    **/
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     *
    **/
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Documents.
     *
    **/
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     *
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Documents.
     *
    **/
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Document
     *
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DocumentInclude | null
    /**
     * Filter, which Documents to fetch.
     *
    **/
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     *
    **/
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Documents.
     *
    **/
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     *
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     *
    **/
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs = {
    /**
     * Select specific fields to fetch from the Document
     *
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DocumentInclude | null
    /**
     * The data needed to create a Document.
     *
    **/
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs = {
    data: Enumerable<DocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Document
     *
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DocumentInclude | null
    /**
     * The data needed to update a Document.
     *
    **/
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     *
    **/
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs = {
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Document
     *
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DocumentInclude | null
    /**
     * The filter to search for the Document to update in case it exists.
     *
    **/
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     *
    **/
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     *
    **/
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Document
     *
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DocumentInclude | null
    /**
     * Filter which Document to delete.
     *
    **/
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs = {
    where?: DocumentWhereInput
  }


  /**
   * Document without action
   */
  export type DocumentArgs = {
    /**
     * Select specific fields to fetch from the Document
     *
    **/
    select?: DocumentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     *
    **/
    include?: DocumentInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const PersonScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    emailConfirmed: 'emailConfirmed',
    phone: 'phone',
    company: 'company',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    newsletter: 'newsletter',
    address: 'address',
    birthday: 'birthday',
    personalNumber: 'personalNumber',
    keycloakId: 'keycloakId',
    stripeCustomerId: 'stripeCustomerId'
  };

  export type PersonScalarFieldEnum = (typeof PersonScalarFieldEnum)[keyof typeof PersonScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    companyNumber: 'companyNumber',
    legalPersonName: 'legalPersonName',
    countryCode: 'countryCode',
    cityId: 'cityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CoordinatorScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoordinatorScalarFieldEnum = (typeof CoordinatorScalarFieldEnum)[keyof typeof CoordinatorScalarFieldEnum]


  export const BenefactorScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    extCustomerId: 'extCustomerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BenefactorScalarFieldEnum = (typeof BenefactorScalarFieldEnum)[keyof typeof BenefactorScalarFieldEnum]


  export const BeneficiaryScalarFieldEnum: {
    id: 'id',
    type: 'type',
    personId: 'personId',
    companyId: 'companyId',
    coordinatorId: 'coordinatorId',
    countryCode: 'countryCode',
    cityId: 'cityId',
    description: 'description',
    publicData: 'publicData',
    privateData: 'privateData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    coordinatorRelation: 'coordinatorRelation'
  };

  export type BeneficiaryScalarFieldEnum = (typeof BeneficiaryScalarFieldEnum)[keyof typeof BeneficiaryScalarFieldEnum]


  export const CampaignTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    parentId: 'parentId'
  };

  export type CampaignTypeScalarFieldEnum = (typeof CampaignTypeScalarFieldEnum)[keyof typeof CampaignTypeScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    state: 'state',
    slug: 'slug',
    title: 'title',
    essence: 'essence',
    coordinatorId: 'coordinatorId',
    beneficiaryId: 'beneficiaryId',
    campaignTypeId: 'campaignTypeId',
    approvedById: 'approvedById',
    description: 'description',
    targetAmount: 'targetAmount',
    currency: 'currency',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const InfoRequestScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type InfoRequestScalarFieldEnum = (typeof InfoRequestScalarFieldEnum)[keyof typeof InfoRequestScalarFieldEnum]


  export const SupporterScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    comment: 'comment',
    associationMember: 'associationMember',
    benefactorCampaign: 'benefactorCampaign',
    benefactorPlatform: 'benefactorPlatform',
    companyOtherText: 'companyOtherText',
    companySponsor: 'companySponsor',
    companyVolunteer: 'companyVolunteer',
    partnerBussiness: 'partnerBussiness',
    partnerNpo: 'partnerNpo',
    partnerOtherText: 'partnerOtherText',
    roleAssociationMember: 'roleAssociationMember',
    roleBenefactor: 'roleBenefactor',
    roleCompany: 'roleCompany',
    rolePartner: 'rolePartner',
    roleVolunteer: 'roleVolunteer',
    volunteerBackend: 'volunteerBackend',
    volunteerDesigner: 'volunteerDesigner',
    volunteerDevOps: 'volunteerDevOps',
    volunteerFinancesAndAccounts: 'volunteerFinancesAndAccounts',
    volunteerFrontend: 'volunteerFrontend',
    volunteerLawyer: 'volunteerLawyer',
    volunteerMarketing: 'volunteerMarketing',
    volunteerProjectManager: 'volunteerProjectManager',
    volunteerQa: 'volunteerQa',
    volunteerSecurity: 'volunteerSecurity'
  };

  export type SupporterScalarFieldEnum = (typeof SupporterScalarFieldEnum)[keyof typeof SupporterScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    postalCode: 'postalCode',
    countryId: 'countryId'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    countryCode: 'countryCode'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const VaultScalarFieldEnum: {
    id: 'id',
    currency: 'currency',
    amount: 'amount',
    campaignId: 'campaignId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VaultScalarFieldEnum = (typeof VaultScalarFieldEnum)[keyof typeof VaultScalarFieldEnum]


  export const DonationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    provider: 'provider',
    personId: 'personId',
    currency: 'currency',
    amount: 'amount',
    targetVaultId: 'targetVaultId',
    extCustomerId: 'extCustomerId',
    extPaymentIntentId: 'extPaymentIntentId',
    extPaymentMethodId: 'extPaymentMethodId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DonationScalarFieldEnum = (typeof DonationScalarFieldEnum)[keyof typeof DonationScalarFieldEnum]


  export const RecurringDonationScalarFieldEnum: {
    id: 'id',
    status: 'status',
    vaultId: 'vaultId',
    personId: 'personId',
    currency: 'currency',
    amount: 'amount',
    extSubscriptionId: 'extSubscriptionId',
    extCustomerId: 'extCustomerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecurringDonationScalarFieldEnum = (typeof RecurringDonationScalarFieldEnum)[keyof typeof RecurringDonationScalarFieldEnum]


  export const TransferScalarFieldEnum: {
    id: 'id',
    status: 'status',
    currency: 'currency',
    amount: 'amount',
    reason: 'reason',
    sourceVaultId: 'sourceVaultId',
    sourceCampaignId: 'sourceCampaignId',
    targetVaultId: 'targetVaultId',
    targetCampaignId: 'targetCampaignId',
    approvedById: 'approvedById',
    documentId: 'documentId',
    targetDate: 'targetDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferScalarFieldEnum = (typeof TransferScalarFieldEnum)[keyof typeof TransferScalarFieldEnum]


  export const WithdrawalScalarFieldEnum: {
    id: 'id',
    status: 'status',
    currency: 'currency',
    amount: 'amount',
    reason: 'reason',
    sourceVaultId: 'sourceVaultId',
    sourceCampaignId: 'sourceCampaignId',
    bankAccountId: 'bankAccountId',
    documentId: 'documentId',
    approvedById: 'approvedById',
    targetDate: 'targetDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WithdrawalScalarFieldEnum = (typeof WithdrawalScalarFieldEnum)[keyof typeof WithdrawalScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    id: 'id',
    status: 'status',
    ibanNumber: 'ibanNumber',
    accountHolderName: 'accountHolderName',
    accountHolderType: 'accountHolderType',
    bankName: 'bankName',
    bankIdCode: 'bankIdCode',
    fingerprint: 'fingerprint',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    type: 'type',
    currency: 'currency',
    amount: 'amount',
    description: 'description',
    vaultId: 'vaultId',
    documentId: 'documentId',
    approvedById: 'approvedById'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    filename: 'filename',
    filetype: 'filetype',
    description: 'description',
    sourceUrl: 'sourceUrl',
    ownerId: 'ownerId'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull'
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull',
    AnyNull: 'AnyNull'
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type PersonWhereInput = {
    AND?: Enumerable<PersonWhereInput>
    OR?: Enumerable<PersonWhereInput>
    NOT?: Enumerable<PersonWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    email?: StringFilter | string
    emailConfirmed?: BoolNullableFilter | boolean | null
    phone?: StringNullableFilter | string | null
    company?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    newsletter?: BoolNullableFilter | boolean | null
    address?: StringNullableFilter | string | null
    birthday?: DateTimeNullableFilter | Date | string | null
    personalNumber?: StringNullableFilter | string | null
    keycloakId?: StringNullableFilter | string | null
    stripeCustomerId?: StringNullableFilter | string | null
    Donation?: DonationListRelationFilter
    expenses?: ExpenseListRelationFilter
    documents?: DocumentListRelationFilter
    transfers?: TransferListRelationFilter
    campaigns?: CampaignListRelationFilter
    supporters?: SupporterListRelationFilter
    benefactors?: BenefactorListRelationFilter
    withdrawals?: WithdrawalListRelationFilter
    beneficiaries?: BeneficiaryListRelationFilter
    infoRequests?: InfoRequestListRelationFilter
    coordinators?: CoordinatorListRelationFilter
    recurringDonations?: RecurringDonationListRelationFilter
  }

  export type PersonOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailConfirmed?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    newsletter?: SortOrder
    address?: SortOrder
    birthday?: SortOrder
    personalNumber?: SortOrder
    keycloakId?: SortOrder
    stripeCustomerId?: SortOrder
    Donation?: DonationOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    transfers?: TransferOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
    supporters?: SupporterOrderByRelationAggregateInput
    benefactors?: BenefactorOrderByRelationAggregateInput
    withdrawals?: WithdrawalOrderByRelationAggregateInput
    beneficiaries?: BeneficiaryOrderByRelationAggregateInput
    infoRequests?: InfoRequestOrderByRelationAggregateInput
    coordinators?: CoordinatorOrderByRelationAggregateInput
    recurringDonations?: RecurringDonationOrderByRelationAggregateInput
  }

  export type PersonWhereUniqueInput = {
    id?: string
    email?: string
    personalNumber?: string
    keycloakId?: string
    stripeCustomerId?: string
  }

  export type PersonOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailConfirmed?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    newsletter?: SortOrder
    address?: SortOrder
    birthday?: SortOrder
    personalNumber?: SortOrder
    keycloakId?: SortOrder
    stripeCustomerId?: SortOrder
    _count?: PersonCountOrderByAggregateInput
    _max?: PersonMaxOrderByAggregateInput
    _min?: PersonMinOrderByAggregateInput
  }

  export type PersonScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PersonScalarWhereWithAggregatesInput>
    OR?: Enumerable<PersonScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PersonScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    emailConfirmed?: BoolNullableWithAggregatesFilter | boolean | null
    phone?: StringNullableWithAggregatesFilter | string | null
    company?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    newsletter?: BoolNullableWithAggregatesFilter | boolean | null
    address?: StringNullableWithAggregatesFilter | string | null
    birthday?: DateTimeNullableWithAggregatesFilter | Date | string | null
    personalNumber?: StringNullableWithAggregatesFilter | string | null
    keycloakId?: StringNullableWithAggregatesFilter | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter | string | null
  }

  export type CompanyWhereInput = {
    AND?: Enumerable<CompanyWhereInput>
    OR?: Enumerable<CompanyWhereInput>
    NOT?: Enumerable<CompanyWhereInput>
    id?: StringFilter | string
    companyName?: StringFilter | string
    companyNumber?: StringFilter | string
    legalPersonName?: StringNullableFilter | string | null
    countryCode?: StringNullableFilter | string | null
    cityId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    beneficiaries?: BeneficiaryListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    companyNumber?: SortOrder
    legalPersonName?: SortOrder
    countryCode?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    beneficiaries?: BeneficiaryOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = {
    id?: string
    companyNumber?: string
  }

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    companyNumber?: SortOrder
    legalPersonName?: SortOrder
    countryCode?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    OR?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    companyName?: StringWithAggregatesFilter | string
    companyNumber?: StringWithAggregatesFilter | string
    legalPersonName?: StringNullableWithAggregatesFilter | string | null
    countryCode?: StringNullableWithAggregatesFilter | string | null
    cityId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CoordinatorWhereInput = {
    AND?: Enumerable<CoordinatorWhereInput>
    OR?: Enumerable<CoordinatorWhereInput>
    NOT?: Enumerable<CoordinatorWhereInput>
    id?: StringFilter | string
    personId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    person?: XOR<PersonRelationFilter, PersonWhereInput>
    beneficiaries?: BeneficiaryListRelationFilter
  }

  export type CoordinatorOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
    beneficiaries?: BeneficiaryOrderByRelationAggregateInput
  }

  export type CoordinatorWhereUniqueInput = {
    id?: string
  }

  export type CoordinatorOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoordinatorCountOrderByAggregateInput
    _max?: CoordinatorMaxOrderByAggregateInput
    _min?: CoordinatorMinOrderByAggregateInput
  }

  export type CoordinatorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CoordinatorScalarWhereWithAggregatesInput>
    OR?: Enumerable<CoordinatorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CoordinatorScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    personId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type BenefactorWhereInput = {
    AND?: Enumerable<BenefactorWhereInput>
    OR?: Enumerable<BenefactorWhereInput>
    NOT?: Enumerable<BenefactorWhereInput>
    id?: StringFilter | string
    personId?: StringFilter | string
    extCustomerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }

  export type BenefactorOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    extCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
  }

  export type BenefactorWhereUniqueInput = {
    id?: string
    extCustomerId?: string
  }

  export type BenefactorOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    extCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BenefactorCountOrderByAggregateInput
    _max?: BenefactorMaxOrderByAggregateInput
    _min?: BenefactorMinOrderByAggregateInput
  }

  export type BenefactorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BenefactorScalarWhereWithAggregatesInput>
    OR?: Enumerable<BenefactorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BenefactorScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    personId?: StringWithAggregatesFilter | string
    extCustomerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type BeneficiaryWhereInput = {
    AND?: Enumerable<BeneficiaryWhereInput>
    OR?: Enumerable<BeneficiaryWhereInput>
    NOT?: Enumerable<BeneficiaryWhereInput>
    id?: StringFilter | string
    type?: EnumBeneficiaryTypeFilter | BeneficiaryType
    personId?: StringNullableFilter | string | null
    companyId?: StringNullableFilter | string | null
    coordinatorId?: StringFilter | string
    countryCode?: StringFilter | string
    cityId?: StringFilter | string
    description?: StringNullableFilter | string | null
    publicData?: JsonNullableFilter
    privateData?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    coordinatorRelation?: EnumPersonRelationFilter | PersonRelation
    city?: XOR<CityRelationFilter, CityWhereInput>
    coordinator?: XOR<CoordinatorRelationFilter, CoordinatorWhereInput>
    person?: XOR<PersonRelationFilter, PersonWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput> | null
    campaigns?: CampaignListRelationFilter
  }

  export type BeneficiaryOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    personId?: SortOrder
    companyId?: SortOrder
    coordinatorId?: SortOrder
    countryCode?: SortOrder
    cityId?: SortOrder
    description?: SortOrder
    publicData?: SortOrder
    privateData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coordinatorRelation?: SortOrder
    city?: CityOrderByWithRelationInput
    coordinator?: CoordinatorOrderByWithRelationInput
    person?: PersonOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    campaigns?: CampaignOrderByRelationAggregateInput
  }

  export type BeneficiaryWhereUniqueInput = {
    id?: string
  }

  export type BeneficiaryOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    personId?: SortOrder
    companyId?: SortOrder
    coordinatorId?: SortOrder
    countryCode?: SortOrder
    cityId?: SortOrder
    description?: SortOrder
    publicData?: SortOrder
    privateData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coordinatorRelation?: SortOrder
    _count?: BeneficiaryCountOrderByAggregateInput
    _max?: BeneficiaryMaxOrderByAggregateInput
    _min?: BeneficiaryMinOrderByAggregateInput
  }

  export type BeneficiaryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BeneficiaryScalarWhereWithAggregatesInput>
    OR?: Enumerable<BeneficiaryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BeneficiaryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumBeneficiaryTypeWithAggregatesFilter | BeneficiaryType
    personId?: StringNullableWithAggregatesFilter | string | null
    companyId?: StringNullableWithAggregatesFilter | string | null
    coordinatorId?: StringWithAggregatesFilter | string
    countryCode?: StringWithAggregatesFilter | string
    cityId?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    publicData?: JsonNullableWithAggregatesFilter
    privateData?: JsonNullableWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    coordinatorRelation?: EnumPersonRelationWithAggregatesFilter | PersonRelation
  }

  export type CampaignTypeWhereInput = {
    AND?: Enumerable<CampaignTypeWhereInput>
    OR?: Enumerable<CampaignTypeWhereInput>
    NOT?: Enumerable<CampaignTypeWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    description?: StringNullableFilter | string | null
    parentId?: StringNullableFilter | string | null
    parent?: XOR<CampaignTypeRelationFilter, CampaignTypeWhereInput> | null
    children?: CampaignTypeListRelationFilter
    campaigns?: CampaignListRelationFilter
  }

  export type CampaignTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    parent?: CampaignTypeOrderByWithRelationInput
    children?: CampaignTypeOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
  }

  export type CampaignTypeWhereUniqueInput = {
    id?: string
    slug?: string
  }

  export type CampaignTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    _count?: CampaignTypeCountOrderByAggregateInput
    _max?: CampaignTypeMaxOrderByAggregateInput
    _min?: CampaignTypeMinOrderByAggregateInput
  }

  export type CampaignTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignTypeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    parentId?: StringNullableWithAggregatesFilter | string | null
  }

  export type CampaignWhereInput = {
    AND?: Enumerable<CampaignWhereInput>
    OR?: Enumerable<CampaignWhereInput>
    NOT?: Enumerable<CampaignWhereInput>
    id?: StringFilter | string
    state?: EnumCampaignStateFilter | CampaignState
    slug?: StringFilter | string
    title?: StringFilter | string
    essence?: StringFilter | string
    coordinatorId?: StringFilter | string
    beneficiaryId?: StringFilter | string
    campaignTypeId?: StringFilter | string
    approvedById?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    targetAmount?: IntNullableFilter | number | null
    currency?: EnumCurrencyFilter | Currency
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    approvedBy?: XOR<PersonRelationFilter, PersonWhereInput> | null
    beneficiaries?: XOR<BeneficiaryRelationFilter, BeneficiaryWhereInput>
    campaignTypes?: XOR<CampaignTypeRelationFilter, CampaignTypeWhereInput>
    vaults?: VaultListRelationFilter
    incomingTransfers?: TransferListRelationFilter
    outgoingTransfers?: TransferListRelationFilter
    withdrawals?: WithdrawalListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    state?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    essence?: SortOrder
    coordinatorId?: SortOrder
    beneficiaryId?: SortOrder
    campaignTypeId?: SortOrder
    approvedById?: SortOrder
    description?: SortOrder
    targetAmount?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    approvedBy?: PersonOrderByWithRelationInput
    beneficiaries?: BeneficiaryOrderByWithRelationInput
    campaignTypes?: CampaignTypeOrderByWithRelationInput
    vaults?: VaultOrderByRelationAggregateInput
    incomingTransfers?: TransferOrderByRelationAggregateInput
    outgoingTransfers?: TransferOrderByRelationAggregateInput
    withdrawals?: WithdrawalOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = {
    id?: string
    slug?: string
  }

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    state?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    essence?: SortOrder
    coordinatorId?: SortOrder
    beneficiaryId?: SortOrder
    campaignTypeId?: SortOrder
    approvedById?: SortOrder
    description?: SortOrder
    targetAmount?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    state?: EnumCampaignStateWithAggregatesFilter | CampaignState
    slug?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    essence?: StringWithAggregatesFilter | string
    coordinatorId?: StringWithAggregatesFilter | string
    beneficiaryId?: StringWithAggregatesFilter | string
    campaignTypeId?: StringWithAggregatesFilter | string
    approvedById?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    targetAmount?: IntNullableWithAggregatesFilter | number | null
    currency?: EnumCurrencyWithAggregatesFilter | Currency
    startDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type InfoRequestWhereInput = {
    AND?: Enumerable<InfoRequestWhereInput>
    OR?: Enumerable<InfoRequestWhereInput>
    NOT?: Enumerable<InfoRequestWhereInput>
    id?: StringFilter | string
    personId?: StringFilter | string
    message?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }

  export type InfoRequestOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    person?: PersonOrderByWithRelationInput
  }

  export type InfoRequestWhereUniqueInput = {
    id?: string
  }

  export type InfoRequestOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: InfoRequestCountOrderByAggregateInput
    _max?: InfoRequestMaxOrderByAggregateInput
    _min?: InfoRequestMinOrderByAggregateInput
  }

  export type InfoRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InfoRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<InfoRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InfoRequestScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    personId?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SupporterWhereInput = {
    AND?: Enumerable<SupporterWhereInput>
    OR?: Enumerable<SupporterWhereInput>
    NOT?: Enumerable<SupporterWhereInput>
    id?: StringFilter | string
    personId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    comment?: StringNullableFilter | string | null
    associationMember?: BoolFilter | boolean
    benefactorCampaign?: BoolFilter | boolean
    benefactorPlatform?: BoolFilter | boolean
    companyOtherText?: StringNullableFilter | string | null
    companySponsor?: BoolFilter | boolean
    companyVolunteer?: BoolFilter | boolean
    partnerBussiness?: BoolFilter | boolean
    partnerNpo?: BoolFilter | boolean
    partnerOtherText?: StringNullableFilter | string | null
    roleAssociationMember?: BoolFilter | boolean
    roleBenefactor?: BoolFilter | boolean
    roleCompany?: BoolFilter | boolean
    rolePartner?: BoolFilter | boolean
    roleVolunteer?: BoolFilter | boolean
    volunteerBackend?: BoolFilter | boolean
    volunteerDesigner?: BoolFilter | boolean
    volunteerDevOps?: BoolFilter | boolean
    volunteerFinancesAndAccounts?: BoolFilter | boolean
    volunteerFrontend?: BoolFilter | boolean
    volunteerLawyer?: BoolFilter | boolean
    volunteerMarketing?: BoolFilter | boolean
    volunteerProjectManager?: BoolFilter | boolean
    volunteerQa?: BoolFilter | boolean
    volunteerSecurity?: BoolFilter | boolean
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }

  export type SupporterOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    comment?: SortOrder
    associationMember?: SortOrder
    benefactorCampaign?: SortOrder
    benefactorPlatform?: SortOrder
    companyOtherText?: SortOrder
    companySponsor?: SortOrder
    companyVolunteer?: SortOrder
    partnerBussiness?: SortOrder
    partnerNpo?: SortOrder
    partnerOtherText?: SortOrder
    roleAssociationMember?: SortOrder
    roleBenefactor?: SortOrder
    roleCompany?: SortOrder
    rolePartner?: SortOrder
    roleVolunteer?: SortOrder
    volunteerBackend?: SortOrder
    volunteerDesigner?: SortOrder
    volunteerDevOps?: SortOrder
    volunteerFinancesAndAccounts?: SortOrder
    volunteerFrontend?: SortOrder
    volunteerLawyer?: SortOrder
    volunteerMarketing?: SortOrder
    volunteerProjectManager?: SortOrder
    volunteerQa?: SortOrder
    volunteerSecurity?: SortOrder
    person?: PersonOrderByWithRelationInput
  }

  export type SupporterWhereUniqueInput = {
    id?: string
  }

  export type SupporterOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    comment?: SortOrder
    associationMember?: SortOrder
    benefactorCampaign?: SortOrder
    benefactorPlatform?: SortOrder
    companyOtherText?: SortOrder
    companySponsor?: SortOrder
    companyVolunteer?: SortOrder
    partnerBussiness?: SortOrder
    partnerNpo?: SortOrder
    partnerOtherText?: SortOrder
    roleAssociationMember?: SortOrder
    roleBenefactor?: SortOrder
    roleCompany?: SortOrder
    rolePartner?: SortOrder
    roleVolunteer?: SortOrder
    volunteerBackend?: SortOrder
    volunteerDesigner?: SortOrder
    volunteerDevOps?: SortOrder
    volunteerFinancesAndAccounts?: SortOrder
    volunteerFrontend?: SortOrder
    volunteerLawyer?: SortOrder
    volunteerMarketing?: SortOrder
    volunteerProjectManager?: SortOrder
    volunteerQa?: SortOrder
    volunteerSecurity?: SortOrder
    _count?: SupporterCountOrderByAggregateInput
    _max?: SupporterMaxOrderByAggregateInput
    _min?: SupporterMinOrderByAggregateInput
  }

  export type SupporterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SupporterScalarWhereWithAggregatesInput>
    OR?: Enumerable<SupporterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SupporterScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    personId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    comment?: StringNullableWithAggregatesFilter | string | null
    associationMember?: BoolWithAggregatesFilter | boolean
    benefactorCampaign?: BoolWithAggregatesFilter | boolean
    benefactorPlatform?: BoolWithAggregatesFilter | boolean
    companyOtherText?: StringNullableWithAggregatesFilter | string | null
    companySponsor?: BoolWithAggregatesFilter | boolean
    companyVolunteer?: BoolWithAggregatesFilter | boolean
    partnerBussiness?: BoolWithAggregatesFilter | boolean
    partnerNpo?: BoolWithAggregatesFilter | boolean
    partnerOtherText?: StringNullableWithAggregatesFilter | string | null
    roleAssociationMember?: BoolWithAggregatesFilter | boolean
    roleBenefactor?: BoolWithAggregatesFilter | boolean
    roleCompany?: BoolWithAggregatesFilter | boolean
    rolePartner?: BoolWithAggregatesFilter | boolean
    roleVolunteer?: BoolWithAggregatesFilter | boolean
    volunteerBackend?: BoolWithAggregatesFilter | boolean
    volunteerDesigner?: BoolWithAggregatesFilter | boolean
    volunteerDevOps?: BoolWithAggregatesFilter | boolean
    volunteerFinancesAndAccounts?: BoolWithAggregatesFilter | boolean
    volunteerFrontend?: BoolWithAggregatesFilter | boolean
    volunteerLawyer?: BoolWithAggregatesFilter | boolean
    volunteerMarketing?: BoolWithAggregatesFilter | boolean
    volunteerProjectManager?: BoolWithAggregatesFilter | boolean
    volunteerQa?: BoolWithAggregatesFilter | boolean
    volunteerSecurity?: BoolWithAggregatesFilter | boolean
  }

  export type CityWhereInput = {
    AND?: Enumerable<CityWhereInput>
    OR?: Enumerable<CityWhereInput>
    NOT?: Enumerable<CityWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    postalCode?: IntFilter | number
    countryId?: StringFilter | string
    countryCode?: XOR<CountryRelationFilter, CountryWhereInput>
    beneficiaries?: BeneficiaryListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    postalCode?: SortOrder
    countryId?: SortOrder
    countryCode?: CountryOrderByWithRelationInput
    beneficiaries?: BeneficiaryOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = {
    id?: string
    postalCode?: number
  }

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    postalCode?: SortOrder
    countryId?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CityScalarWhereWithAggregatesInput>
    OR?: Enumerable<CityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CityScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    postalCode?: IntWithAggregatesFilter | number
    countryId?: StringWithAggregatesFilter | string
  }

  export type CountryWhereInput = {
    AND?: Enumerable<CountryWhereInput>
    OR?: Enumerable<CountryWhereInput>
    NOT?: Enumerable<CountryWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    countryCode?: StringFilter | string
    cities?: CityListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    countryCode?: SortOrder
    cities?: CityOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = {
    id?: string
    countryCode?: string
  }

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    countryCode?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CountryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CountryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CountryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    countryCode?: StringWithAggregatesFilter | string
  }

  export type VaultWhereInput = {
    AND?: Enumerable<VaultWhereInput>
    OR?: Enumerable<VaultWhereInput>
    NOT?: Enumerable<VaultWhereInput>
    id?: StringFilter | string
    currency?: EnumCurrencyFilter | Currency
    amount?: IntFilter | number
    campaignId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    expenses?: ExpenseListRelationFilter
    sourceTransfers?: TransferListRelationFilter
    targetTransfers?: TransferListRelationFilter
    donations?: DonationListRelationFilter
    withdraws?: WithdrawalListRelationFilter
    recurringDonations?: RecurringDonationListRelationFilter
  }

  export type VaultOrderByWithRelationInput = {
    id?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    expenses?: ExpenseOrderByRelationAggregateInput
    sourceTransfers?: TransferOrderByRelationAggregateInput
    targetTransfers?: TransferOrderByRelationAggregateInput
    donations?: DonationOrderByRelationAggregateInput
    withdraws?: WithdrawalOrderByRelationAggregateInput
    recurringDonations?: RecurringDonationOrderByRelationAggregateInput
  }

  export type VaultWhereUniqueInput = {
    id?: string
  }

  export type VaultOrderByWithAggregationInput = {
    id?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VaultCountOrderByAggregateInput
    _avg?: VaultAvgOrderByAggregateInput
    _max?: VaultMaxOrderByAggregateInput
    _min?: VaultMinOrderByAggregateInput
    _sum?: VaultSumOrderByAggregateInput
  }

  export type VaultScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VaultScalarWhereWithAggregatesInput>
    OR?: Enumerable<VaultScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VaultScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    currency?: EnumCurrencyWithAggregatesFilter | Currency
    amount?: IntWithAggregatesFilter | number
    campaignId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type DonationWhereInput = {
    AND?: Enumerable<DonationWhereInput>
    OR?: Enumerable<DonationWhereInput>
    NOT?: Enumerable<DonationWhereInput>
    id?: StringFilter | string
    type?: EnumDonationTypeFilter | DonationType
    status?: EnumDonationStatusFilter | DonationStatus
    provider?: EnumPaymentProviderFilter | PaymentProvider
    personId?: StringNullableFilter | string | null
    currency?: EnumCurrencyFilter | Currency
    amount?: IntFilter | number
    targetVaultId?: StringFilter | string
    extCustomerId?: StringFilter | string
    extPaymentIntentId?: StringFilter | string
    extPaymentMethodId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    targetVault?: XOR<VaultRelationFilter, VaultWhereInput>
    person?: XOR<PersonRelationFilter, PersonWhereInput> | null
  }

  export type DonationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    personId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    targetVaultId?: SortOrder
    extCustomerId?: SortOrder
    extPaymentIntentId?: SortOrder
    extPaymentMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    targetVault?: VaultOrderByWithRelationInput
    person?: PersonOrderByWithRelationInput
  }

  export type DonationWhereUniqueInput = {
    id?: string
    extPaymentIntentId?: string
  }

  export type DonationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    personId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    targetVaultId?: SortOrder
    extCustomerId?: SortOrder
    extPaymentIntentId?: SortOrder
    extPaymentMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DonationCountOrderByAggregateInput
    _avg?: DonationAvgOrderByAggregateInput
    _max?: DonationMaxOrderByAggregateInput
    _min?: DonationMinOrderByAggregateInput
    _sum?: DonationSumOrderByAggregateInput
  }

  export type DonationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DonationScalarWhereWithAggregatesInput>
    OR?: Enumerable<DonationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DonationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumDonationTypeWithAggregatesFilter | DonationType
    status?: EnumDonationStatusWithAggregatesFilter | DonationStatus
    provider?: EnumPaymentProviderWithAggregatesFilter | PaymentProvider
    personId?: StringNullableWithAggregatesFilter | string | null
    currency?: EnumCurrencyWithAggregatesFilter | Currency
    amount?: IntWithAggregatesFilter | number
    targetVaultId?: StringWithAggregatesFilter | string
    extCustomerId?: StringWithAggregatesFilter | string
    extPaymentIntentId?: StringWithAggregatesFilter | string
    extPaymentMethodId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type RecurringDonationWhereInput = {
    AND?: Enumerable<RecurringDonationWhereInput>
    OR?: Enumerable<RecurringDonationWhereInput>
    NOT?: Enumerable<RecurringDonationWhereInput>
    id?: StringFilter | string
    status?: EnumRecurringDonationStatusFilter | RecurringDonationStatus
    vaultId?: StringFilter | string
    personId?: StringFilter | string
    currency?: EnumCurrencyFilter | Currency
    amount?: IntFilter | number
    extSubscriptionId?: StringFilter | string
    extCustomerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    sourceVault?: XOR<VaultRelationFilter, VaultWhereInput>
    person?: XOR<PersonRelationFilter, PersonWhereInput>
  }

  export type RecurringDonationOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    vaultId?: SortOrder
    personId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    extSubscriptionId?: SortOrder
    extCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sourceVault?: VaultOrderByWithRelationInput
    person?: PersonOrderByWithRelationInput
  }

  export type RecurringDonationWhereUniqueInput = {
    id?: string
  }

  export type RecurringDonationOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    vaultId?: SortOrder
    personId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    extSubscriptionId?: SortOrder
    extCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecurringDonationCountOrderByAggregateInput
    _avg?: RecurringDonationAvgOrderByAggregateInput
    _max?: RecurringDonationMaxOrderByAggregateInput
    _min?: RecurringDonationMinOrderByAggregateInput
    _sum?: RecurringDonationSumOrderByAggregateInput
  }

  export type RecurringDonationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RecurringDonationScalarWhereWithAggregatesInput>
    OR?: Enumerable<RecurringDonationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RecurringDonationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    status?: EnumRecurringDonationStatusWithAggregatesFilter | RecurringDonationStatus
    vaultId?: StringWithAggregatesFilter | string
    personId?: StringWithAggregatesFilter | string
    currency?: EnumCurrencyWithAggregatesFilter | Currency
    amount?: IntWithAggregatesFilter | number
    extSubscriptionId?: StringWithAggregatesFilter | string
    extCustomerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type TransferWhereInput = {
    AND?: Enumerable<TransferWhereInput>
    OR?: Enumerable<TransferWhereInput>
    NOT?: Enumerable<TransferWhereInput>
    id?: StringFilter | string
    status?: EnumTransferStatusFilter | TransferStatus
    currency?: EnumCurrencyFilter | Currency
    amount?: IntFilter | number
    reason?: StringFilter | string
    sourceVaultId?: StringFilter | string
    sourceCampaignId?: StringFilter | string
    targetVaultId?: StringFilter | string
    targetCampaignId?: StringFilter | string
    approvedById?: StringNullableFilter | string | null
    documentId?: StringNullableFilter | string | null
    targetDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    approvedBy?: XOR<PersonRelationFilter, PersonWhereInput> | null
    sourceVault?: XOR<VaultRelationFilter, VaultWhereInput>
    sourceCampaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    targetVault?: XOR<VaultRelationFilter, VaultWhereInput>
    targetCampaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type TransferOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    sourceVaultId?: SortOrder
    sourceCampaignId?: SortOrder
    targetVaultId?: SortOrder
    targetCampaignId?: SortOrder
    approvedById?: SortOrder
    documentId?: SortOrder
    targetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedBy?: PersonOrderByWithRelationInput
    sourceVault?: VaultOrderByWithRelationInput
    sourceCampaign?: CampaignOrderByWithRelationInput
    targetVault?: VaultOrderByWithRelationInput
    targetCampaign?: CampaignOrderByWithRelationInput
  }

  export type TransferWhereUniqueInput = {
    id?: string
  }

  export type TransferOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    sourceVaultId?: SortOrder
    sourceCampaignId?: SortOrder
    targetVaultId?: SortOrder
    targetCampaignId?: SortOrder
    approvedById?: SortOrder
    documentId?: SortOrder
    targetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferCountOrderByAggregateInput
    _avg?: TransferAvgOrderByAggregateInput
    _max?: TransferMaxOrderByAggregateInput
    _min?: TransferMinOrderByAggregateInput
    _sum?: TransferSumOrderByAggregateInput
  }

  export type TransferScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TransferScalarWhereWithAggregatesInput>
    OR?: Enumerable<TransferScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TransferScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    status?: EnumTransferStatusWithAggregatesFilter | TransferStatus
    currency?: EnumCurrencyWithAggregatesFilter | Currency
    amount?: IntWithAggregatesFilter | number
    reason?: StringWithAggregatesFilter | string
    sourceVaultId?: StringWithAggregatesFilter | string
    sourceCampaignId?: StringWithAggregatesFilter | string
    targetVaultId?: StringWithAggregatesFilter | string
    targetCampaignId?: StringWithAggregatesFilter | string
    approvedById?: StringNullableWithAggregatesFilter | string | null
    documentId?: StringNullableWithAggregatesFilter | string | null
    targetDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type WithdrawalWhereInput = {
    AND?: Enumerable<WithdrawalWhereInput>
    OR?: Enumerable<WithdrawalWhereInput>
    NOT?: Enumerable<WithdrawalWhereInput>
    id?: StringFilter | string
    status?: EnumWithdrawStatusFilter | WithdrawStatus
    currency?: EnumCurrencyFilter | Currency
    amount?: IntFilter | number
    reason?: StringFilter | string
    sourceVaultId?: StringFilter | string
    sourceCampaignId?: StringFilter | string
    bankAccountId?: StringFilter | string
    documentId?: StringNullableFilter | string | null
    approvedById?: StringNullableFilter | string | null
    targetDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    approvedBy?: XOR<PersonRelationFilter, PersonWhereInput> | null
    sourceVault?: XOR<VaultRelationFilter, VaultWhereInput>
    sourceCampaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    bankAccount?: XOR<BankAccountRelationFilter, BankAccountWhereInput>
  }

  export type WithdrawalOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    sourceVaultId?: SortOrder
    sourceCampaignId?: SortOrder
    bankAccountId?: SortOrder
    documentId?: SortOrder
    approvedById?: SortOrder
    targetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedBy?: PersonOrderByWithRelationInput
    sourceVault?: VaultOrderByWithRelationInput
    sourceCampaign?: CampaignOrderByWithRelationInput
    bankAccount?: BankAccountOrderByWithRelationInput
  }

  export type WithdrawalWhereUniqueInput = {
    id?: string
  }

  export type WithdrawalOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    sourceVaultId?: SortOrder
    sourceCampaignId?: SortOrder
    bankAccountId?: SortOrder
    documentId?: SortOrder
    approvedById?: SortOrder
    targetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WithdrawalCountOrderByAggregateInput
    _avg?: WithdrawalAvgOrderByAggregateInput
    _max?: WithdrawalMaxOrderByAggregateInput
    _min?: WithdrawalMinOrderByAggregateInput
    _sum?: WithdrawalSumOrderByAggregateInput
  }

  export type WithdrawalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WithdrawalScalarWhereWithAggregatesInput>
    OR?: Enumerable<WithdrawalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WithdrawalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    status?: EnumWithdrawStatusWithAggregatesFilter | WithdrawStatus
    currency?: EnumCurrencyWithAggregatesFilter | Currency
    amount?: IntWithAggregatesFilter | number
    reason?: StringWithAggregatesFilter | string
    sourceVaultId?: StringWithAggregatesFilter | string
    sourceCampaignId?: StringWithAggregatesFilter | string
    bankAccountId?: StringWithAggregatesFilter | string
    documentId?: StringNullableWithAggregatesFilter | string | null
    approvedById?: StringNullableWithAggregatesFilter | string | null
    targetDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type BankAccountWhereInput = {
    AND?: Enumerable<BankAccountWhereInput>
    OR?: Enumerable<BankAccountWhereInput>
    NOT?: Enumerable<BankAccountWhereInput>
    id?: StringFilter | string
    status?: EnumBankAccountStatusFilter | BankAccountStatus
    ibanNumber?: StringFilter | string
    accountHolderName?: StringFilter | string
    accountHolderType?: EnumAccountHolderTypeFilter | AccountHolderType
    bankName?: StringNullableFilter | string | null
    bankIdCode?: StringNullableFilter | string | null
    fingerprint?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    withdraws?: WithdrawalListRelationFilter
  }

  export type BankAccountOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    ibanNumber?: SortOrder
    accountHolderName?: SortOrder
    accountHolderType?: SortOrder
    bankName?: SortOrder
    bankIdCode?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    withdraws?: WithdrawalOrderByRelationAggregateInput
  }

  export type BankAccountWhereUniqueInput = {
    id?: string
  }

  export type BankAccountOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    ibanNumber?: SortOrder
    accountHolderName?: SortOrder
    accountHolderType?: SortOrder
    bankName?: SortOrder
    bankIdCode?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BankAccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<BankAccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BankAccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    status?: EnumBankAccountStatusWithAggregatesFilter | BankAccountStatus
    ibanNumber?: StringWithAggregatesFilter | string
    accountHolderName?: StringWithAggregatesFilter | string
    accountHolderType?: EnumAccountHolderTypeWithAggregatesFilter | AccountHolderType
    bankName?: StringNullableWithAggregatesFilter | string | null
    bankIdCode?: StringNullableWithAggregatesFilter | string | null
    fingerprint?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ExpenseWhereInput = {
    AND?: Enumerable<ExpenseWhereInput>
    OR?: Enumerable<ExpenseWhereInput>
    NOT?: Enumerable<ExpenseWhereInput>
    id?: StringFilter | string
    type?: EnumExpenseTypeFilter | ExpenseType
    currency?: EnumCurrencyFilter | Currency
    amount?: IntFilter | number
    description?: StringNullableFilter | string | null
    vaultId?: StringFilter | string
    documentId?: StringNullableFilter | string | null
    approvedById?: StringNullableFilter | string | null
    vault?: XOR<VaultRelationFilter, VaultWhereInput>
    approvedBy?: XOR<PersonRelationFilter, PersonWhereInput> | null
    document?: XOR<DocumentRelationFilter, DocumentWhereInput> | null
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    vaultId?: SortOrder
    documentId?: SortOrder
    approvedById?: SortOrder
    vault?: VaultOrderByWithRelationInput
    approvedBy?: PersonOrderByWithRelationInput
    document?: DocumentOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = {
    id?: string
  }

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    vaultId?: SortOrder
    documentId?: SortOrder
    approvedById?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExpenseScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExpenseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExpenseScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumExpenseTypeWithAggregatesFilter | ExpenseType
    currency?: EnumCurrencyWithAggregatesFilter | Currency
    amount?: IntWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
    vaultId?: StringWithAggregatesFilter | string
    documentId?: StringNullableWithAggregatesFilter | string | null
    approvedById?: StringNullableWithAggregatesFilter | string | null
  }

  export type DocumentWhereInput = {
    AND?: Enumerable<DocumentWhereInput>
    OR?: Enumerable<DocumentWhereInput>
    NOT?: Enumerable<DocumentWhereInput>
    id?: StringFilter | string
    type?: EnumDocumentTypeFilter | DocumentType
    name?: StringFilter | string
    filename?: StringFilter | string
    filetype?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    sourceUrl?: StringFilter | string
    ownerId?: StringFilter | string
    owner?: XOR<PersonRelationFilter, PersonWhereInput>
    expenses?: ExpenseListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    filename?: SortOrder
    filetype?: SortOrder
    description?: SortOrder
    sourceUrl?: SortOrder
    ownerId?: SortOrder
    owner?: PersonOrderByWithRelationInput
    expenses?: ExpenseOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = {
    id?: string
  }

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    filename?: SortOrder
    filetype?: SortOrder
    description?: SortOrder
    sourceUrl?: SortOrder
    ownerId?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumDocumentTypeWithAggregatesFilter | DocumentType
    name?: StringWithAggregatesFilter | string
    filename?: StringWithAggregatesFilter | string
    filetype?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    sourceUrl?: StringWithAggregatesFilter | string
    ownerId?: StringWithAggregatesFilter | string
  }

  export type PersonCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationCreateNestedManyWithoutPersonInput
    expenses?: ExpenseCreateNestedManyWithoutApprovedByInput
    documents?: DocumentCreateNestedManyWithoutOwnerInput
    transfers?: TransferCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationUncheckedCreateNestedManyWithoutPersonInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutApprovedByInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterUncheckedCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorUncheckedCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUpdateManyWithoutPersonInput
    expenses?: ExpenseUpdateManyWithoutApprovedByInput
    documents?: DocumentUpdateManyWithoutOwnerInput
    transfers?: TransferUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUpdateManyWithoutApprovedByInput
    supporters?: SupporterUpdateManyWithoutPersonInput
    benefactors?: BenefactorUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUncheckedUpdateManyWithoutPersonInput
    expenses?: ExpenseUncheckedUpdateManyWithoutApprovedByInput
    documents?: DocumentUncheckedUpdateManyWithoutOwnerInput
    transfers?: TransferUncheckedUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedUpdateManyWithoutApprovedByInput
    supporters?: SupporterUncheckedUpdateManyWithoutPersonInput
    benefactors?: BenefactorUncheckedUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutPersonInput
  }

  export type PersonCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
  }

  export type PersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyCreateInput = {
    id?: string
    companyName: string
    companyNumber: string
    legalPersonName?: string | null
    countryCode?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    companyName: string
    companyNumber: string
    legalPersonName?: string | null
    countryCode?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyNumber?: StringFieldUpdateOperationsInput | string
    legalPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficiaries?: BeneficiaryUpdateManyWithoutCompanyInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyNumber?: StringFieldUpdateOperationsInput | string
    legalPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCompanyInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    companyName: string
    companyNumber: string
    legalPersonName?: string | null
    countryCode?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyNumber?: StringFieldUpdateOperationsInput | string
    legalPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyNumber?: StringFieldUpdateOperationsInput | string
    legalPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CoordinatorCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    person: PersonCreateNestedOneWithoutCoordinatorsInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCoordinatorInput
  }

  export type CoordinatorUncheckedCreateInput = {
    id?: string
    personId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCoordinatorInput
  }

  export type CoordinatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneRequiredWithoutCoordinatorsInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCoordinatorInput
  }

  export type CoordinatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCoordinatorInput
  }

  export type CoordinatorCreateManyInput = {
    id?: string
    personId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CoordinatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CoordinatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BenefactorCreateInput = {
    id?: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    person: PersonCreateNestedOneWithoutBenefactorsInput
  }

  export type BenefactorUncheckedCreateInput = {
    id?: string
    personId: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BenefactorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneRequiredWithoutBenefactorsInput
  }

  export type BenefactorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BenefactorCreateManyInput = {
    id?: string
    personId: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BenefactorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BenefactorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BeneficiaryCreateInput = {
    id?: string
    type: BeneficiaryType
    countryCode: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
    city: CityCreateNestedOneWithoutBeneficiariesInput
    coordinator: CoordinatorCreateNestedOneWithoutBeneficiariesInput
    person?: PersonCreateNestedOneWithoutBeneficiariesInput
    company?: CompanyCreateNestedOneWithoutBeneficiariesInput
    campaigns?: CampaignCreateNestedManyWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateInput = {
    id?: string
    type: BeneficiaryType
    personId?: string | null
    companyId?: string | null
    coordinatorId: string
    countryCode: string
    cityId: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
    campaigns?: CampaignUncheckedCreateNestedManyWithoutBeneficiariesInput
  }

  export type BeneficiaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    countryCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
    city?: CityUpdateOneRequiredWithoutBeneficiariesInput
    coordinator?: CoordinatorUpdateOneRequiredWithoutBeneficiariesInput
    person?: PersonUpdateOneWithoutBeneficiariesInput
    company?: CompanyUpdateOneWithoutBeneficiariesInput
    campaigns?: CampaignUpdateManyWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorId?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
    campaigns?: CampaignUncheckedUpdateManyWithoutBeneficiariesInput
  }

  export type BeneficiaryCreateManyInput = {
    id?: string
    type: BeneficiaryType
    personId?: string | null
    companyId?: string | null
    coordinatorId: string
    countryCode: string
    cityId: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
  }

  export type BeneficiaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    countryCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
  }

  export type BeneficiaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorId?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
  }

  export type CampaignTypeCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parent?: CampaignTypeCreateNestedOneWithoutChildrenInput
    children?: CampaignTypeCreateNestedManyWithoutParentInput
    campaigns?: CampaignCreateNestedManyWithoutCampaignTypesInput
  }

  export type CampaignTypeUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    children?: CampaignTypeUncheckedCreateNestedManyWithoutParentInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCampaignTypesInput
  }

  export type CampaignTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: CampaignTypeUpdateOneWithoutChildrenInput
    children?: CampaignTypeUpdateManyWithoutParentInput
    campaigns?: CampaignUpdateManyWithoutCampaignTypesInput
  }

  export type CampaignTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CampaignTypeUncheckedUpdateManyWithoutParentInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCampaignTypesInput
  }

  export type CampaignTypeCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
  }

  export type CampaignTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignCreateInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutCampaignsInput
    beneficiaries: BeneficiaryCreateNestedOneWithoutCampaignsInput
    campaignTypes: CampaignTypeCreateNestedOneWithoutCampaignsInput
    vaults?: VaultCreateNestedManyWithoutCampaignInput
    incomingTransfers?: TransferCreateNestedManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferCreateNestedManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    beneficiaryId: string
    campaignTypeId: string
    approvedById?: string | null
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    vaults?: VaultUncheckedCreateNestedManyWithoutCampaignInput
    incomingTransfers?: TransferUncheckedCreateNestedManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUncheckedCreateNestedManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutCampaignsInput
    beneficiaries?: BeneficiaryUpdateOneRequiredWithoutCampaignsInput
    campaignTypes?: CampaignTypeUpdateOneRequiredWithoutCampaignsInput
    vaults?: VaultUpdateManyWithoutCampaignInput
    incomingTransfers?: TransferUpdateManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUpdateManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUpdateManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    beneficiaryId?: StringFieldUpdateOperationsInput | string
    campaignTypeId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vaults?: VaultUncheckedUpdateManyWithoutCampaignInput
    incomingTransfers?: TransferUncheckedUpdateManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUncheckedUpdateManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutSourceCampaignInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    beneficiaryId: string
    campaignTypeId: string
    approvedById?: string | null
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    beneficiaryId?: StringFieldUpdateOperationsInput | string
    campaignTypeId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InfoRequestCreateInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    person: PersonCreateNestedOneWithoutInfoRequestsInput
  }

  export type InfoRequestUncheckedCreateInput = {
    id?: string
    personId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type InfoRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneRequiredWithoutInfoRequestsInput
  }

  export type InfoRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InfoRequestCreateManyInput = {
    id?: string
    personId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type InfoRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InfoRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupporterCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    comment?: string | null
    associationMember?: boolean
    benefactorCampaign?: boolean
    benefactorPlatform?: boolean
    companyOtherText?: string | null
    companySponsor?: boolean
    companyVolunteer?: boolean
    partnerBussiness?: boolean
    partnerNpo?: boolean
    partnerOtherText?: string | null
    roleAssociationMember?: boolean
    roleBenefactor?: boolean
    roleCompany?: boolean
    rolePartner?: boolean
    roleVolunteer?: boolean
    volunteerBackend?: boolean
    volunteerDesigner?: boolean
    volunteerDevOps?: boolean
    volunteerFinancesAndAccounts?: boolean
    volunteerFrontend?: boolean
    volunteerLawyer?: boolean
    volunteerMarketing?: boolean
    volunteerProjectManager?: boolean
    volunteerQa?: boolean
    volunteerSecurity?: boolean
    person: PersonCreateNestedOneWithoutSupportersInput
  }

  export type SupporterUncheckedCreateInput = {
    id?: string
    personId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    comment?: string | null
    associationMember?: boolean
    benefactorCampaign?: boolean
    benefactorPlatform?: boolean
    companyOtherText?: string | null
    companySponsor?: boolean
    companyVolunteer?: boolean
    partnerBussiness?: boolean
    partnerNpo?: boolean
    partnerOtherText?: string | null
    roleAssociationMember?: boolean
    roleBenefactor?: boolean
    roleCompany?: boolean
    rolePartner?: boolean
    roleVolunteer?: boolean
    volunteerBackend?: boolean
    volunteerDesigner?: boolean
    volunteerDevOps?: boolean
    volunteerFinancesAndAccounts?: boolean
    volunteerFrontend?: boolean
    volunteerLawyer?: boolean
    volunteerMarketing?: boolean
    volunteerProjectManager?: boolean
    volunteerQa?: boolean
    volunteerSecurity?: boolean
  }

  export type SupporterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    associationMember?: BoolFieldUpdateOperationsInput | boolean
    benefactorCampaign?: BoolFieldUpdateOperationsInput | boolean
    benefactorPlatform?: BoolFieldUpdateOperationsInput | boolean
    companyOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    companySponsor?: BoolFieldUpdateOperationsInput | boolean
    companyVolunteer?: BoolFieldUpdateOperationsInput | boolean
    partnerBussiness?: BoolFieldUpdateOperationsInput | boolean
    partnerNpo?: BoolFieldUpdateOperationsInput | boolean
    partnerOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    roleAssociationMember?: BoolFieldUpdateOperationsInput | boolean
    roleBenefactor?: BoolFieldUpdateOperationsInput | boolean
    roleCompany?: BoolFieldUpdateOperationsInput | boolean
    rolePartner?: BoolFieldUpdateOperationsInput | boolean
    roleVolunteer?: BoolFieldUpdateOperationsInput | boolean
    volunteerBackend?: BoolFieldUpdateOperationsInput | boolean
    volunteerDesigner?: BoolFieldUpdateOperationsInput | boolean
    volunteerDevOps?: BoolFieldUpdateOperationsInput | boolean
    volunteerFinancesAndAccounts?: BoolFieldUpdateOperationsInput | boolean
    volunteerFrontend?: BoolFieldUpdateOperationsInput | boolean
    volunteerLawyer?: BoolFieldUpdateOperationsInput | boolean
    volunteerMarketing?: BoolFieldUpdateOperationsInput | boolean
    volunteerProjectManager?: BoolFieldUpdateOperationsInput | boolean
    volunteerQa?: BoolFieldUpdateOperationsInput | boolean
    volunteerSecurity?: BoolFieldUpdateOperationsInput | boolean
    person?: PersonUpdateOneRequiredWithoutSupportersInput
  }

  export type SupporterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    associationMember?: BoolFieldUpdateOperationsInput | boolean
    benefactorCampaign?: BoolFieldUpdateOperationsInput | boolean
    benefactorPlatform?: BoolFieldUpdateOperationsInput | boolean
    companyOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    companySponsor?: BoolFieldUpdateOperationsInput | boolean
    companyVolunteer?: BoolFieldUpdateOperationsInput | boolean
    partnerBussiness?: BoolFieldUpdateOperationsInput | boolean
    partnerNpo?: BoolFieldUpdateOperationsInput | boolean
    partnerOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    roleAssociationMember?: BoolFieldUpdateOperationsInput | boolean
    roleBenefactor?: BoolFieldUpdateOperationsInput | boolean
    roleCompany?: BoolFieldUpdateOperationsInput | boolean
    rolePartner?: BoolFieldUpdateOperationsInput | boolean
    roleVolunteer?: BoolFieldUpdateOperationsInput | boolean
    volunteerBackend?: BoolFieldUpdateOperationsInput | boolean
    volunteerDesigner?: BoolFieldUpdateOperationsInput | boolean
    volunteerDevOps?: BoolFieldUpdateOperationsInput | boolean
    volunteerFinancesAndAccounts?: BoolFieldUpdateOperationsInput | boolean
    volunteerFrontend?: BoolFieldUpdateOperationsInput | boolean
    volunteerLawyer?: BoolFieldUpdateOperationsInput | boolean
    volunteerMarketing?: BoolFieldUpdateOperationsInput | boolean
    volunteerProjectManager?: BoolFieldUpdateOperationsInput | boolean
    volunteerQa?: BoolFieldUpdateOperationsInput | boolean
    volunteerSecurity?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SupporterCreateManyInput = {
    id?: string
    personId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    comment?: string | null
    associationMember?: boolean
    benefactorCampaign?: boolean
    benefactorPlatform?: boolean
    companyOtherText?: string | null
    companySponsor?: boolean
    companyVolunteer?: boolean
    partnerBussiness?: boolean
    partnerNpo?: boolean
    partnerOtherText?: string | null
    roleAssociationMember?: boolean
    roleBenefactor?: boolean
    roleCompany?: boolean
    rolePartner?: boolean
    roleVolunteer?: boolean
    volunteerBackend?: boolean
    volunteerDesigner?: boolean
    volunteerDevOps?: boolean
    volunteerFinancesAndAccounts?: boolean
    volunteerFrontend?: boolean
    volunteerLawyer?: boolean
    volunteerMarketing?: boolean
    volunteerProjectManager?: boolean
    volunteerQa?: boolean
    volunteerSecurity?: boolean
  }

  export type SupporterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    associationMember?: BoolFieldUpdateOperationsInput | boolean
    benefactorCampaign?: BoolFieldUpdateOperationsInput | boolean
    benefactorPlatform?: BoolFieldUpdateOperationsInput | boolean
    companyOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    companySponsor?: BoolFieldUpdateOperationsInput | boolean
    companyVolunteer?: BoolFieldUpdateOperationsInput | boolean
    partnerBussiness?: BoolFieldUpdateOperationsInput | boolean
    partnerNpo?: BoolFieldUpdateOperationsInput | boolean
    partnerOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    roleAssociationMember?: BoolFieldUpdateOperationsInput | boolean
    roleBenefactor?: BoolFieldUpdateOperationsInput | boolean
    roleCompany?: BoolFieldUpdateOperationsInput | boolean
    rolePartner?: BoolFieldUpdateOperationsInput | boolean
    roleVolunteer?: BoolFieldUpdateOperationsInput | boolean
    volunteerBackend?: BoolFieldUpdateOperationsInput | boolean
    volunteerDesigner?: BoolFieldUpdateOperationsInput | boolean
    volunteerDevOps?: BoolFieldUpdateOperationsInput | boolean
    volunteerFinancesAndAccounts?: BoolFieldUpdateOperationsInput | boolean
    volunteerFrontend?: BoolFieldUpdateOperationsInput | boolean
    volunteerLawyer?: BoolFieldUpdateOperationsInput | boolean
    volunteerMarketing?: BoolFieldUpdateOperationsInput | boolean
    volunteerProjectManager?: BoolFieldUpdateOperationsInput | boolean
    volunteerQa?: BoolFieldUpdateOperationsInput | boolean
    volunteerSecurity?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SupporterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    associationMember?: BoolFieldUpdateOperationsInput | boolean
    benefactorCampaign?: BoolFieldUpdateOperationsInput | boolean
    benefactorPlatform?: BoolFieldUpdateOperationsInput | boolean
    companyOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    companySponsor?: BoolFieldUpdateOperationsInput | boolean
    companyVolunteer?: BoolFieldUpdateOperationsInput | boolean
    partnerBussiness?: BoolFieldUpdateOperationsInput | boolean
    partnerNpo?: BoolFieldUpdateOperationsInput | boolean
    partnerOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    roleAssociationMember?: BoolFieldUpdateOperationsInput | boolean
    roleBenefactor?: BoolFieldUpdateOperationsInput | boolean
    roleCompany?: BoolFieldUpdateOperationsInput | boolean
    rolePartner?: BoolFieldUpdateOperationsInput | boolean
    roleVolunteer?: BoolFieldUpdateOperationsInput | boolean
    volunteerBackend?: BoolFieldUpdateOperationsInput | boolean
    volunteerDesigner?: BoolFieldUpdateOperationsInput | boolean
    volunteerDevOps?: BoolFieldUpdateOperationsInput | boolean
    volunteerFinancesAndAccounts?: BoolFieldUpdateOperationsInput | boolean
    volunteerFrontend?: BoolFieldUpdateOperationsInput | boolean
    volunteerLawyer?: BoolFieldUpdateOperationsInput | boolean
    volunteerMarketing?: BoolFieldUpdateOperationsInput | boolean
    volunteerProjectManager?: BoolFieldUpdateOperationsInput | boolean
    volunteerQa?: BoolFieldUpdateOperationsInput | boolean
    volunteerSecurity?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CityCreateInput = {
    id?: string
    name: string
    postalCode: number
    countryCode: CountryCreateNestedOneWithoutCitiesInput
    // beneficiaries?: BeneficiaryCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    postalCode: number
    countryId: string
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: IntFieldUpdateOperationsInput | number
    countryCode?: CountryUpdateOneRequiredWithoutCitiesInput
    beneficiaries?: BeneficiaryUpdateManyWithoutCityInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: IntFieldUpdateOperationsInput | number
    countryId?: StringFieldUpdateOperationsInput | string
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCityInput
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
    postalCode: number
    countryId: string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: IntFieldUpdateOperationsInput | number
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: IntFieldUpdateOperationsInput | number
    countryId?: StringFieldUpdateOperationsInput | string
  }

  export type CountryCreateInput = {
    id?: string
    name: string
    countryCode: string
    cities?: CityCreateNestedManyWithoutCountryCodeInput
  }

  export type CountryUncheckedCreateInput = {
    id?: string
    name: string
    countryCode: string
    cities?: CityUncheckedCreateNestedManyWithoutCountryCodeInput
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    cities?: CityUpdateManyWithoutCountryCodeInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutCountryCodeInput
  }

  export type CountryCreateManyInput = {
    id?: string
    name: string
    countryCode: string
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
  }

  export type VaultCreateInput = {
    id?: string
    currency?: Currency
    amount?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutVaultsInput
    expenses?: ExpenseCreateNestedManyWithoutVaultInput
    sourceTransfers?: TransferCreateNestedManyWithoutSourceVaultInput
    targetTransfers?: TransferCreateNestedManyWithoutTargetVaultInput
    donations?: DonationCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalCreateNestedManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultUncheckedCreateInput = {
    id?: string
    currency?: Currency
    amount?: number
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVaultInput
    sourceTransfers?: TransferUncheckedCreateNestedManyWithoutSourceVaultInput
    targetTransfers?: TransferUncheckedCreateNestedManyWithoutTargetVaultInput
    donations?: DonationUncheckedCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedCreateNestedManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutVaultsInput
    expenses?: ExpenseUpdateManyWithoutVaultInput
    sourceTransfers?: TransferUpdateManyWithoutSourceVaultInput
    targetTransfers?: TransferUpdateManyWithoutTargetVaultInput
    donations?: DonationUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUpdateManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUpdateManyWithoutSourceVaultInput
  }

  export type VaultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutVaultInput
    sourceTransfers?: TransferUncheckedUpdateManyWithoutSourceVaultInput
    targetTransfers?: TransferUncheckedUpdateManyWithoutTargetVaultInput
    donations?: DonationUncheckedUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedUpdateManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutSourceVaultInput
  }

  export type VaultCreateManyInput = {
    id?: string
    currency?: Currency
    amount?: number
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type VaultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VaultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DonationCreateInput = {
    id?: string
    type: DonationType
    status?: DonationStatus
    provider?: PaymentProvider
    currency?: Currency
    amount?: number
    extCustomerId: string
    extPaymentIntentId: string
    extPaymentMethodId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    targetVault: VaultCreateNestedOneWithoutDonationsInput
    person?: PersonCreateNestedOneWithoutDonationInput
  }

  export type DonationUncheckedCreateInput = {
    id?: string
    type: DonationType
    status?: DonationStatus
    provider?: PaymentProvider
    personId?: string | null
    currency?: Currency
    amount?: number
    targetVaultId: string
    extCustomerId: string
    extPaymentIntentId: string
    extPaymentMethodId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type DonationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDonationTypeFieldUpdateOperationsInput | DonationType
    status?: EnumDonationStatusFieldUpdateOperationsInput | DonationStatus
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | PaymentProvider
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extCustomerId?: StringFieldUpdateOperationsInput | string
    extPaymentIntentId?: StringFieldUpdateOperationsInput | string
    extPaymentMethodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetVault?: VaultUpdateOneRequiredWithoutDonationsInput
    person?: PersonUpdateOneWithoutDonationInput
  }

  export type DonationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDonationTypeFieldUpdateOperationsInput | DonationType
    status?: EnumDonationStatusFieldUpdateOperationsInput | DonationStatus
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | PaymentProvider
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    targetVaultId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: StringFieldUpdateOperationsInput | string
    extPaymentIntentId?: StringFieldUpdateOperationsInput | string
    extPaymentMethodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DonationCreateManyInput = {
    id?: string
    type: DonationType
    status?: DonationStatus
    provider?: PaymentProvider
    personId?: string | null
    currency?: Currency
    amount?: number
    targetVaultId: string
    extCustomerId: string
    extPaymentIntentId: string
    extPaymentMethodId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type DonationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDonationTypeFieldUpdateOperationsInput | DonationType
    status?: EnumDonationStatusFieldUpdateOperationsInput | DonationStatus
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | PaymentProvider
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extCustomerId?: StringFieldUpdateOperationsInput | string
    extPaymentIntentId?: StringFieldUpdateOperationsInput | string
    extPaymentMethodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DonationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDonationTypeFieldUpdateOperationsInput | DonationType
    status?: EnumDonationStatusFieldUpdateOperationsInput | DonationStatus
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | PaymentProvider
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    targetVaultId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: StringFieldUpdateOperationsInput | string
    extPaymentIntentId?: StringFieldUpdateOperationsInput | string
    extPaymentMethodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecurringDonationCreateInput = {
    id?: string
    status: RecurringDonationStatus
    currency?: Currency
    amount?: number
    extSubscriptionId: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    sourceVault: VaultCreateNestedOneWithoutRecurringDonationsInput
    person: PersonCreateNestedOneWithoutRecurringDonationsInput
  }

  export type RecurringDonationUncheckedCreateInput = {
    id?: string
    status: RecurringDonationStatus
    vaultId: string
    personId: string
    currency?: Currency
    amount?: number
    extSubscriptionId: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RecurringDonationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRecurringDonationStatusFieldUpdateOperationsInput | RecurringDonationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extSubscriptionId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceVault?: VaultUpdateOneRequiredWithoutRecurringDonationsInput
    person?: PersonUpdateOneRequiredWithoutRecurringDonationsInput
  }

  export type RecurringDonationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRecurringDonationStatusFieldUpdateOperationsInput | RecurringDonationStatus
    vaultId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extSubscriptionId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecurringDonationCreateManyInput = {
    id?: string
    status: RecurringDonationStatus
    vaultId: string
    personId: string
    currency?: Currency
    amount?: number
    extSubscriptionId: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RecurringDonationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRecurringDonationStatusFieldUpdateOperationsInput | RecurringDonationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extSubscriptionId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecurringDonationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRecurringDonationStatusFieldUpdateOperationsInput | RecurringDonationStatus
    vaultId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extSubscriptionId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferCreateInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutTransfersInput
    sourceVault: VaultCreateNestedOneWithoutSourceTransfersInput
    sourceCampaign: CampaignCreateNestedOneWithoutOutgoingTransfersInput
    targetVault: VaultCreateNestedOneWithoutTargetTransfersInput
    targetCampaign: CampaignCreateNestedOneWithoutIncomingTransfersInput
  }

  export type TransferUncheckedCreateInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    targetVaultId: string
    targetCampaignId: string
    approvedById?: string | null
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutTransfersInput
    sourceVault?: VaultUpdateOneRequiredWithoutSourceTransfersInput
    sourceCampaign?: CampaignUpdateOneRequiredWithoutOutgoingTransfersInput
    targetVault?: VaultUpdateOneRequiredWithoutTargetTransfersInput
    targetCampaign?: CampaignUpdateOneRequiredWithoutIncomingTransfersInput
  }

  export type TransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: StringFieldUpdateOperationsInput | string
    targetCampaignId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferCreateManyInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    targetVaultId: string
    targetCampaignId: string
    approvedById?: string | null
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: StringFieldUpdateOperationsInput | string
    targetCampaignId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalCreateInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutWithdrawalsInput
    sourceVault: VaultCreateNestedOneWithoutWithdrawsInput
    sourceCampaign: CampaignCreateNestedOneWithoutWithdrawalsInput
    bankAccount: BankAccountCreateNestedOneWithoutWithdrawsInput
  }

  export type WithdrawalUncheckedCreateInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    bankAccountId: string
    documentId?: string | null
    approvedById?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutWithdrawalsInput
    sourceVault?: VaultUpdateOneRequiredWithoutWithdrawsInput
    sourceCampaign?: CampaignUpdateOneRequiredWithoutWithdrawalsInput
    bankAccount?: BankAccountUpdateOneRequiredWithoutWithdrawsInput
  }

  export type WithdrawalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalCreateManyInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    bankAccountId: string
    documentId?: string | null
    approvedById?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BankAccountCreateInput = {
    id?: string
    status?: BankAccountStatus
    ibanNumber: string
    accountHolderName: string
    accountHolderType: AccountHolderType
    bankName?: string | null
    bankIdCode?: string | null
    fingerprint?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    withdraws?: WithdrawalCreateNestedManyWithoutBankAccountInput
  }

  export type BankAccountUncheckedCreateInput = {
    id?: string
    status?: BankAccountStatus
    ibanNumber: string
    accountHolderName: string
    accountHolderType: AccountHolderType
    bankName?: string | null
    bankIdCode?: string | null
    fingerprint?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    withdraws?: WithdrawalUncheckedCreateNestedManyWithoutBankAccountInput
  }

  export type BankAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBankAccountStatusFieldUpdateOperationsInput | BankAccountStatus
    ibanNumber?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    accountHolderType?: EnumAccountHolderTypeFieldUpdateOperationsInput | AccountHolderType
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankIdCode?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdraws?: WithdrawalUpdateManyWithoutBankAccountInput
  }

  export type BankAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBankAccountStatusFieldUpdateOperationsInput | BankAccountStatus
    ibanNumber?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    accountHolderType?: EnumAccountHolderTypeFieldUpdateOperationsInput | AccountHolderType
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankIdCode?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdraws?: WithdrawalUncheckedUpdateManyWithoutBankAccountInput
  }

  export type BankAccountCreateManyInput = {
    id?: string
    status?: BankAccountStatus
    ibanNumber: string
    accountHolderName: string
    accountHolderType: AccountHolderType
    bankName?: string | null
    bankIdCode?: string | null
    fingerprint?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BankAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBankAccountStatusFieldUpdateOperationsInput | BankAccountStatus
    ibanNumber?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    accountHolderType?: EnumAccountHolderTypeFieldUpdateOperationsInput | AccountHolderType
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankIdCode?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BankAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBankAccountStatusFieldUpdateOperationsInput | BankAccountStatus
    ibanNumber?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    accountHolderType?: EnumAccountHolderTypeFieldUpdateOperationsInput | AccountHolderType
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankIdCode?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExpenseCreateInput = {
    id?: string
    type: ExpenseType
    currency?: Currency
    amount?: number
    description?: string | null
    vault: VaultCreateNestedOneWithoutExpensesInput
    approvedBy?: PersonCreateNestedOneWithoutExpensesInput
    document?: DocumentCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    type: ExpenseType
    currency?: Currency
    amount?: number
    description?: string | null
    vaultId: string
    documentId?: string | null
    approvedById?: string | null
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | ExpenseType
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vault?: VaultUpdateOneRequiredWithoutExpensesInput
    approvedBy?: PersonUpdateOneWithoutExpensesInput
    document?: DocumentUpdateOneWithoutExpensesInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | ExpenseType
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vaultId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseCreateManyInput = {
    id?: string
    type: ExpenseType
    currency?: Currency
    amount?: number
    description?: string | null
    vaultId: string
    documentId?: string | null
    approvedById?: string | null
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | ExpenseType
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | ExpenseType
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vaultId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateInput = {
    id?: string
    type: DocumentType
    name: string
    filename: string
    filetype?: string | null
    description?: string | null
    sourceUrl: string
    owner: PersonCreateNestedOneWithoutDocumentsInput
    expenses?: ExpenseCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    type: DocumentType
    name: string
    filename: string
    filetype?: string | null
    description?: string | null
    sourceUrl: string
    ownerId: string
    expenses?: ExpenseUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    filetype?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: StringFieldUpdateOperationsInput | string
    owner?: PersonUpdateOneRequiredWithoutDocumentsInput
    expenses?: ExpenseUpdateManyWithoutDocumentInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    filetype?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    expenses?: ExpenseUncheckedUpdateManyWithoutDocumentInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    type: DocumentType
    name: string
    filename: string
    filetype?: string | null
    description?: string | null
    sourceUrl: string
    ownerId: string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    filetype?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    filetype?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type DonationListRelationFilter = {
    every?: DonationWhereInput
    some?: DonationWhereInput
    none?: DonationWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type TransferListRelationFilter = {
    every?: TransferWhereInput
    some?: TransferWhereInput
    none?: TransferWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type SupporterListRelationFilter = {
    every?: SupporterWhereInput
    some?: SupporterWhereInput
    none?: SupporterWhereInput
  }

  export type BenefactorListRelationFilter = {
    every?: BenefactorWhereInput
    some?: BenefactorWhereInput
    none?: BenefactorWhereInput
  }

  export type WithdrawalListRelationFilter = {
    every?: WithdrawalWhereInput
    some?: WithdrawalWhereInput
    none?: WithdrawalWhereInput
  }

  export type BeneficiaryListRelationFilter = {
    every?: BeneficiaryWhereInput
    some?: BeneficiaryWhereInput
    none?: BeneficiaryWhereInput
  }

  export type InfoRequestListRelationFilter = {
    every?: InfoRequestWhereInput
    some?: InfoRequestWhereInput
    none?: InfoRequestWhereInput
  }

  export type CoordinatorListRelationFilter = {
    every?: CoordinatorWhereInput
    some?: CoordinatorWhereInput
    none?: CoordinatorWhereInput
  }

  export type RecurringDonationListRelationFilter = {
    every?: RecurringDonationWhereInput
    some?: RecurringDonationWhereInput
    none?: RecurringDonationWhereInput
  }

  export type DonationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupporterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BenefactorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WithdrawalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BeneficiaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InfoRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoordinatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecurringDonationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailConfirmed?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    newsletter?: SortOrder
    address?: SortOrder
    birthday?: SortOrder
    personalNumber?: SortOrder
    keycloakId?: SortOrder
    stripeCustomerId?: SortOrder
  }

  export type PersonMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailConfirmed?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    newsletter?: SortOrder
    address?: SortOrder
    birthday?: SortOrder
    personalNumber?: SortOrder
    keycloakId?: SortOrder
    stripeCustomerId?: SortOrder
  }

  export type PersonMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailConfirmed?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    newsletter?: SortOrder
    address?: SortOrder
    birthday?: SortOrder
    personalNumber?: SortOrder
    keycloakId?: SortOrder
    stripeCustomerId?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    companyNumber?: SortOrder
    legalPersonName?: SortOrder
    countryCode?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    companyNumber?: SortOrder
    legalPersonName?: SortOrder
    countryCode?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    companyNumber?: SortOrder
    legalPersonName?: SortOrder
    countryCode?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonRelationFilter = {
    is?: PersonWhereInput | null
    isNot?: PersonWhereInput | null
  }

  export type CoordinatorCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoordinatorMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoordinatorMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BenefactorCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    extCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BenefactorMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    extCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BenefactorMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    extCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBeneficiaryTypeFilter = {
    equals?: BeneficiaryType
    in?: Enumerable<BeneficiaryType>
    notIn?: Enumerable<BeneficiaryType>
    not?: NestedEnumBeneficiaryTypeFilter | BeneficiaryType
  }
  export type JsonNullableFilter =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type EnumPersonRelationFilter = {
    equals?: PersonRelation
    in?: Enumerable<PersonRelation>
    notIn?: Enumerable<PersonRelation>
    not?: NestedEnumPersonRelationFilter | PersonRelation
  }

  export type CityRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type CoordinatorRelationFilter = {
    is?: CoordinatorWhereInput
    isNot?: CoordinatorWhereInput
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type BeneficiaryCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    personId?: SortOrder
    companyId?: SortOrder
    coordinatorId?: SortOrder
    countryCode?: SortOrder
    cityId?: SortOrder
    description?: SortOrder
    publicData?: SortOrder
    privateData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coordinatorRelation?: SortOrder
  }

  export type BeneficiaryMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    personId?: SortOrder
    companyId?: SortOrder
    coordinatorId?: SortOrder
    countryCode?: SortOrder
    cityId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coordinatorRelation?: SortOrder
  }

  export type BeneficiaryMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    personId?: SortOrder
    companyId?: SortOrder
    coordinatorId?: SortOrder
    countryCode?: SortOrder
    cityId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coordinatorRelation?: SortOrder
  }

  export type EnumBeneficiaryTypeWithAggregatesFilter = {
    equals?: BeneficiaryType
    in?: Enumerable<BeneficiaryType>
    notIn?: Enumerable<BeneficiaryType>
    not?: NestedEnumBeneficiaryTypeWithAggregatesFilter | BeneficiaryType
    _count?: NestedIntFilter
    _min?: NestedEnumBeneficiaryTypeFilter
    _max?: NestedEnumBeneficiaryTypeFilter
  }
  export type JsonNullableWithAggregatesFilter =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type EnumPersonRelationWithAggregatesFilter = {
    equals?: PersonRelation
    in?: Enumerable<PersonRelation>
    notIn?: Enumerable<PersonRelation>
    not?: NestedEnumPersonRelationWithAggregatesFilter | PersonRelation
    _count?: NestedIntFilter
    _min?: NestedEnumPersonRelationFilter
    _max?: NestedEnumPersonRelationFilter
  }

  export type CampaignTypeRelationFilter = {
    is?: CampaignTypeWhereInput | null
    isNot?: CampaignTypeWhereInput | null
  }

  export type CampaignTypeListRelationFilter = {
    every?: CampaignTypeWhereInput
    some?: CampaignTypeWhereInput
    none?: CampaignTypeWhereInput
  }

  export type CampaignTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
  }

  export type CampaignTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
  }

  export type CampaignTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
  }

  export type EnumCampaignStateFilter = {
    equals?: CampaignState
    in?: Enumerable<CampaignState>
    notIn?: Enumerable<CampaignState>
    not?: NestedEnumCampaignStateFilter | CampaignState
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type EnumCurrencyFilter = {
    equals?: Currency
    in?: Enumerable<Currency>
    notIn?: Enumerable<Currency>
    not?: NestedEnumCurrencyFilter | Currency
  }

  export type BeneficiaryRelationFilter = {
    is?: BeneficiaryWhereInput
    isNot?: BeneficiaryWhereInput
  }

  export type VaultListRelationFilter = {
    every?: VaultWhereInput
    some?: VaultWhereInput
    none?: VaultWhereInput
  }

  export type VaultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    essence?: SortOrder
    coordinatorId?: SortOrder
    beneficiaryId?: SortOrder
    campaignTypeId?: SortOrder
    approvedById?: SortOrder
    description?: SortOrder
    targetAmount?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    targetAmount?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    essence?: SortOrder
    coordinatorId?: SortOrder
    beneficiaryId?: SortOrder
    campaignTypeId?: SortOrder
    approvedById?: SortOrder
    description?: SortOrder
    targetAmount?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    essence?: SortOrder
    coordinatorId?: SortOrder
    beneficiaryId?: SortOrder
    campaignTypeId?: SortOrder
    approvedById?: SortOrder
    description?: SortOrder
    targetAmount?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    targetAmount?: SortOrder
  }

  export type EnumCampaignStateWithAggregatesFilter = {
    equals?: CampaignState
    in?: Enumerable<CampaignState>
    notIn?: Enumerable<CampaignState>
    not?: NestedEnumCampaignStateWithAggregatesFilter | CampaignState
    _count?: NestedIntFilter
    _min?: NestedEnumCampaignStateFilter
    _max?: NestedEnumCampaignStateFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type EnumCurrencyWithAggregatesFilter = {
    equals?: Currency
    in?: Enumerable<Currency>
    notIn?: Enumerable<Currency>
    not?: NestedEnumCurrencyWithAggregatesFilter | Currency
    _count?: NestedIntFilter
    _min?: NestedEnumCurrencyFilter
    _max?: NestedEnumCurrencyFilter
  }

  export type InfoRequestCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type InfoRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type InfoRequestMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type SupporterCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    comment?: SortOrder
    associationMember?: SortOrder
    benefactorCampaign?: SortOrder
    benefactorPlatform?: SortOrder
    companyOtherText?: SortOrder
    companySponsor?: SortOrder
    companyVolunteer?: SortOrder
    partnerBussiness?: SortOrder
    partnerNpo?: SortOrder
    partnerOtherText?: SortOrder
    roleAssociationMember?: SortOrder
    roleBenefactor?: SortOrder
    roleCompany?: SortOrder
    rolePartner?: SortOrder
    roleVolunteer?: SortOrder
    volunteerBackend?: SortOrder
    volunteerDesigner?: SortOrder
    volunteerDevOps?: SortOrder
    volunteerFinancesAndAccounts?: SortOrder
    volunteerFrontend?: SortOrder
    volunteerLawyer?: SortOrder
    volunteerMarketing?: SortOrder
    volunteerProjectManager?: SortOrder
    volunteerQa?: SortOrder
    volunteerSecurity?: SortOrder
  }

  export type SupporterMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    comment?: SortOrder
    associationMember?: SortOrder
    benefactorCampaign?: SortOrder
    benefactorPlatform?: SortOrder
    companyOtherText?: SortOrder
    companySponsor?: SortOrder
    companyVolunteer?: SortOrder
    partnerBussiness?: SortOrder
    partnerNpo?: SortOrder
    partnerOtherText?: SortOrder
    roleAssociationMember?: SortOrder
    roleBenefactor?: SortOrder
    roleCompany?: SortOrder
    rolePartner?: SortOrder
    roleVolunteer?: SortOrder
    volunteerBackend?: SortOrder
    volunteerDesigner?: SortOrder
    volunteerDevOps?: SortOrder
    volunteerFinancesAndAccounts?: SortOrder
    volunteerFrontend?: SortOrder
    volunteerLawyer?: SortOrder
    volunteerMarketing?: SortOrder
    volunteerProjectManager?: SortOrder
    volunteerQa?: SortOrder
    volunteerSecurity?: SortOrder
  }

  export type SupporterMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    comment?: SortOrder
    associationMember?: SortOrder
    benefactorCampaign?: SortOrder
    benefactorPlatform?: SortOrder
    companyOtherText?: SortOrder
    companySponsor?: SortOrder
    companyVolunteer?: SortOrder
    partnerBussiness?: SortOrder
    partnerNpo?: SortOrder
    partnerOtherText?: SortOrder
    roleAssociationMember?: SortOrder
    roleBenefactor?: SortOrder
    roleCompany?: SortOrder
    rolePartner?: SortOrder
    roleVolunteer?: SortOrder
    volunteerBackend?: SortOrder
    volunteerDesigner?: SortOrder
    volunteerDevOps?: SortOrder
    volunteerFinancesAndAccounts?: SortOrder
    volunteerFrontend?: SortOrder
    volunteerLawyer?: SortOrder
    volunteerMarketing?: SortOrder
    volunteerProjectManager?: SortOrder
    volunteerQa?: SortOrder
    volunteerSecurity?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    postalCode?: SortOrder
    countryId?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    postalCode?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    postalCode?: SortOrder
    countryId?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    postalCode?: SortOrder
    countryId?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    postalCode?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryCode?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryCode?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryCode?: SortOrder
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type VaultCountOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VaultAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type VaultMaxOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VaultMinOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VaultSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumDonationTypeFilter = {
    equals?: DonationType
    in?: Enumerable<DonationType>
    notIn?: Enumerable<DonationType>
    not?: NestedEnumDonationTypeFilter | DonationType
  }

  export type EnumDonationStatusFilter = {
    equals?: DonationStatus
    in?: Enumerable<DonationStatus>
    notIn?: Enumerable<DonationStatus>
    not?: NestedEnumDonationStatusFilter | DonationStatus
  }

  export type EnumPaymentProviderFilter = {
    equals?: PaymentProvider
    in?: Enumerable<PaymentProvider>
    notIn?: Enumerable<PaymentProvider>
    not?: NestedEnumPaymentProviderFilter | PaymentProvider
  }

  export type VaultRelationFilter = {
    is?: VaultWhereInput
    isNot?: VaultWhereInput
  }

  export type DonationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    personId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    targetVaultId?: SortOrder
    extCustomerId?: SortOrder
    extPaymentIntentId?: SortOrder
    extPaymentMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DonationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    personId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    targetVaultId?: SortOrder
    extCustomerId?: SortOrder
    extPaymentIntentId?: SortOrder
    extPaymentMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    personId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    targetVaultId?: SortOrder
    extCustomerId?: SortOrder
    extPaymentIntentId?: SortOrder
    extPaymentMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumDonationTypeWithAggregatesFilter = {
    equals?: DonationType
    in?: Enumerable<DonationType>
    notIn?: Enumerable<DonationType>
    not?: NestedEnumDonationTypeWithAggregatesFilter | DonationType
    _count?: NestedIntFilter
    _min?: NestedEnumDonationTypeFilter
    _max?: NestedEnumDonationTypeFilter
  }

  export type EnumDonationStatusWithAggregatesFilter = {
    equals?: DonationStatus
    in?: Enumerable<DonationStatus>
    notIn?: Enumerable<DonationStatus>
    not?: NestedEnumDonationStatusWithAggregatesFilter | DonationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumDonationStatusFilter
    _max?: NestedEnumDonationStatusFilter
  }

  export type EnumPaymentProviderWithAggregatesFilter = {
    equals?: PaymentProvider
    in?: Enumerable<PaymentProvider>
    notIn?: Enumerable<PaymentProvider>
    not?: NestedEnumPaymentProviderWithAggregatesFilter | PaymentProvider
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentProviderFilter
    _max?: NestedEnumPaymentProviderFilter
  }

  export type EnumRecurringDonationStatusFilter = {
    equals?: RecurringDonationStatus
    in?: Enumerable<RecurringDonationStatus>
    notIn?: Enumerable<RecurringDonationStatus>
    not?: NestedEnumRecurringDonationStatusFilter | RecurringDonationStatus
  }

  export type RecurringDonationCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    vaultId?: SortOrder
    personId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    extSubscriptionId?: SortOrder
    extCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringDonationAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RecurringDonationMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    vaultId?: SortOrder
    personId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    extSubscriptionId?: SortOrder
    extCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringDonationMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    vaultId?: SortOrder
    personId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    extSubscriptionId?: SortOrder
    extCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringDonationSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumRecurringDonationStatusWithAggregatesFilter = {
    equals?: RecurringDonationStatus
    in?: Enumerable<RecurringDonationStatus>
    notIn?: Enumerable<RecurringDonationStatus>
    not?: NestedEnumRecurringDonationStatusWithAggregatesFilter | RecurringDonationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumRecurringDonationStatusFilter
    _max?: NestedEnumRecurringDonationStatusFilter
  }

  export type EnumTransferStatusFilter = {
    equals?: TransferStatus
    in?: Enumerable<TransferStatus>
    notIn?: Enumerable<TransferStatus>
    not?: NestedEnumTransferStatusFilter | TransferStatus
  }

  export type TransferCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    sourceVaultId?: SortOrder
    sourceCampaignId?: SortOrder
    targetVaultId?: SortOrder
    targetCampaignId?: SortOrder
    approvedById?: SortOrder
    documentId?: SortOrder
    targetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransferMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    sourceVaultId?: SortOrder
    sourceCampaignId?: SortOrder
    targetVaultId?: SortOrder
    targetCampaignId?: SortOrder
    approvedById?: SortOrder
    documentId?: SortOrder
    targetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    sourceVaultId?: SortOrder
    sourceCampaignId?: SortOrder
    targetVaultId?: SortOrder
    targetCampaignId?: SortOrder
    approvedById?: SortOrder
    documentId?: SortOrder
    targetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransferStatusWithAggregatesFilter = {
    equals?: TransferStatus
    in?: Enumerable<TransferStatus>
    notIn?: Enumerable<TransferStatus>
    not?: NestedEnumTransferStatusWithAggregatesFilter | TransferStatus
    _count?: NestedIntFilter
    _min?: NestedEnumTransferStatusFilter
    _max?: NestedEnumTransferStatusFilter
  }

  export type EnumWithdrawStatusFilter = {
    equals?: WithdrawStatus
    in?: Enumerable<WithdrawStatus>
    notIn?: Enumerable<WithdrawStatus>
    not?: NestedEnumWithdrawStatusFilter | WithdrawStatus
  }

  export type BankAccountRelationFilter = {
    is?: BankAccountWhereInput
    isNot?: BankAccountWhereInput
  }

  export type WithdrawalCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    sourceVaultId?: SortOrder
    sourceCampaignId?: SortOrder
    bankAccountId?: SortOrder
    documentId?: SortOrder
    approvedById?: SortOrder
    targetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WithdrawalAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WithdrawalMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    sourceVaultId?: SortOrder
    sourceCampaignId?: SortOrder
    bankAccountId?: SortOrder
    documentId?: SortOrder
    approvedById?: SortOrder
    targetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WithdrawalMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    sourceVaultId?: SortOrder
    sourceCampaignId?: SortOrder
    bankAccountId?: SortOrder
    documentId?: SortOrder
    approvedById?: SortOrder
    targetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WithdrawalSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumWithdrawStatusWithAggregatesFilter = {
    equals?: WithdrawStatus
    in?: Enumerable<WithdrawStatus>
    notIn?: Enumerable<WithdrawStatus>
    not?: NestedEnumWithdrawStatusWithAggregatesFilter | WithdrawStatus
    _count?: NestedIntFilter
    _min?: NestedEnumWithdrawStatusFilter
    _max?: NestedEnumWithdrawStatusFilter
  }

  export type EnumBankAccountStatusFilter = {
    equals?: BankAccountStatus
    in?: Enumerable<BankAccountStatus>
    notIn?: Enumerable<BankAccountStatus>
    not?: NestedEnumBankAccountStatusFilter | BankAccountStatus
  }

  export type EnumAccountHolderTypeFilter = {
    equals?: AccountHolderType
    in?: Enumerable<AccountHolderType>
    notIn?: Enumerable<AccountHolderType>
    not?: NestedEnumAccountHolderTypeFilter | AccountHolderType
  }

  export type BankAccountCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    ibanNumber?: SortOrder
    accountHolderName?: SortOrder
    accountHolderType?: SortOrder
    bankName?: SortOrder
    bankIdCode?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    ibanNumber?: SortOrder
    accountHolderName?: SortOrder
    accountHolderType?: SortOrder
    bankName?: SortOrder
    bankIdCode?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    ibanNumber?: SortOrder
    accountHolderName?: SortOrder
    accountHolderType?: SortOrder
    bankName?: SortOrder
    bankIdCode?: SortOrder
    fingerprint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBankAccountStatusWithAggregatesFilter = {
    equals?: BankAccountStatus
    in?: Enumerable<BankAccountStatus>
    notIn?: Enumerable<BankAccountStatus>
    not?: NestedEnumBankAccountStatusWithAggregatesFilter | BankAccountStatus
    _count?: NestedIntFilter
    _min?: NestedEnumBankAccountStatusFilter
    _max?: NestedEnumBankAccountStatusFilter
  }

  export type EnumAccountHolderTypeWithAggregatesFilter = {
    equals?: AccountHolderType
    in?: Enumerable<AccountHolderType>
    notIn?: Enumerable<AccountHolderType>
    not?: NestedEnumAccountHolderTypeWithAggregatesFilter | AccountHolderType
    _count?: NestedIntFilter
    _min?: NestedEnumAccountHolderTypeFilter
    _max?: NestedEnumAccountHolderTypeFilter
  }

  export type EnumExpenseTypeFilter = {
    equals?: ExpenseType
    in?: Enumerable<ExpenseType>
    notIn?: Enumerable<ExpenseType>
    not?: NestedEnumExpenseTypeFilter | ExpenseType
  }

  export type DocumentRelationFilter = {
    is?: DocumentWhereInput | null
    isNot?: DocumentWhereInput | null
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    vaultId?: SortOrder
    documentId?: SortOrder
    approvedById?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    vaultId?: SortOrder
    documentId?: SortOrder
    approvedById?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    vaultId?: SortOrder
    documentId?: SortOrder
    approvedById?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumExpenseTypeWithAggregatesFilter = {
    equals?: ExpenseType
    in?: Enumerable<ExpenseType>
    notIn?: Enumerable<ExpenseType>
    not?: NestedEnumExpenseTypeWithAggregatesFilter | ExpenseType
    _count?: NestedIntFilter
    _min?: NestedEnumExpenseTypeFilter
    _max?: NestedEnumExpenseTypeFilter
  }

  export type EnumDocumentTypeFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeFilter | DocumentType
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    filename?: SortOrder
    filetype?: SortOrder
    description?: SortOrder
    sourceUrl?: SortOrder
    ownerId?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    filename?: SortOrder
    filetype?: SortOrder
    description?: SortOrder
    sourceUrl?: SortOrder
    ownerId?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    filename?: SortOrder
    filetype?: SortOrder
    description?: SortOrder
    sourceUrl?: SortOrder
    ownerId?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeWithAggregatesFilter | DocumentType
    _count?: NestedIntFilter
    _min?: NestedEnumDocumentTypeFilter
    _max?: NestedEnumDocumentTypeFilter
  }

  export type DonationCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<DonationCreateWithoutPersonInput>, Enumerable<DonationUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<DonationCreateOrConnectWithoutPersonInput>
    createMany?: DonationCreateManyPersonInputEnvelope
    connect?: Enumerable<DonationWhereUniqueInput>
  }

  export type ExpenseCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutApprovedByInput>, Enumerable<ExpenseUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutApprovedByInput>
    createMany?: ExpenseCreateManyApprovedByInputEnvelope
    connect?: Enumerable<ExpenseWhereUniqueInput>
  }

  export type DocumentCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutOwnerInput>, Enumerable<DocumentUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutOwnerInput>
    createMany?: DocumentCreateManyOwnerInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type TransferCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<TransferCreateWithoutApprovedByInput>, Enumerable<TransferUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutApprovedByInput>
    createMany?: TransferCreateManyApprovedByInputEnvelope
    connect?: Enumerable<TransferWhereUniqueInput>
  }

  export type CampaignCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutApprovedByInput>, Enumerable<CampaignUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutApprovedByInput>
    createMany?: CampaignCreateManyApprovedByInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type SupporterCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<SupporterCreateWithoutPersonInput>, Enumerable<SupporterUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<SupporterCreateOrConnectWithoutPersonInput>
    createMany?: SupporterCreateManyPersonInputEnvelope
    connect?: Enumerable<SupporterWhereUniqueInput>
  }

  export type BenefactorCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<BenefactorCreateWithoutPersonInput>, Enumerable<BenefactorUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<BenefactorCreateOrConnectWithoutPersonInput>
    createMany?: BenefactorCreateManyPersonInputEnvelope
    connect?: Enumerable<BenefactorWhereUniqueInput>
  }

  export type WithdrawalCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutApprovedByInput>, Enumerable<WithdrawalUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutApprovedByInput>
    createMany?: WithdrawalCreateManyApprovedByInputEnvelope
    connect?: Enumerable<WithdrawalWhereUniqueInput>
  }

  export type BeneficiaryCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutPersonInput>, Enumerable<BeneficiaryUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutPersonInput>
    createMany?: BeneficiaryCreateManyPersonInputEnvelope
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
  }

  export type InfoRequestCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<InfoRequestCreateWithoutPersonInput>, Enumerable<InfoRequestUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<InfoRequestCreateOrConnectWithoutPersonInput>
    createMany?: InfoRequestCreateManyPersonInputEnvelope
    connect?: Enumerable<InfoRequestWhereUniqueInput>
  }

  export type CoordinatorCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<CoordinatorCreateWithoutPersonInput>, Enumerable<CoordinatorUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<CoordinatorCreateOrConnectWithoutPersonInput>
    createMany?: CoordinatorCreateManyPersonInputEnvelope
    connect?: Enumerable<CoordinatorWhereUniqueInput>
  }

  export type RecurringDonationCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<RecurringDonationCreateWithoutPersonInput>, Enumerable<RecurringDonationUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<RecurringDonationCreateOrConnectWithoutPersonInput>
    createMany?: RecurringDonationCreateManyPersonInputEnvelope
    connect?: Enumerable<RecurringDonationWhereUniqueInput>
  }

  export type DonationUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<DonationCreateWithoutPersonInput>, Enumerable<DonationUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<DonationCreateOrConnectWithoutPersonInput>
    createMany?: DonationCreateManyPersonInputEnvelope
    connect?: Enumerable<DonationWhereUniqueInput>
  }

  export type ExpenseUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutApprovedByInput>, Enumerable<ExpenseUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutApprovedByInput>
    createMany?: ExpenseCreateManyApprovedByInputEnvelope
    connect?: Enumerable<ExpenseWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutOwnerInput>, Enumerable<DocumentUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutOwnerInput>
    createMany?: DocumentCreateManyOwnerInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type TransferUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<TransferCreateWithoutApprovedByInput>, Enumerable<TransferUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutApprovedByInput>
    createMany?: TransferCreateManyApprovedByInputEnvelope
    connect?: Enumerable<TransferWhereUniqueInput>
  }

  export type CampaignUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutApprovedByInput>, Enumerable<CampaignUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutApprovedByInput>
    createMany?: CampaignCreateManyApprovedByInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type SupporterUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<SupporterCreateWithoutPersonInput>, Enumerable<SupporterUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<SupporterCreateOrConnectWithoutPersonInput>
    createMany?: SupporterCreateManyPersonInputEnvelope
    connect?: Enumerable<SupporterWhereUniqueInput>
  }

  export type BenefactorUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<BenefactorCreateWithoutPersonInput>, Enumerable<BenefactorUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<BenefactorCreateOrConnectWithoutPersonInput>
    createMany?: BenefactorCreateManyPersonInputEnvelope
    connect?: Enumerable<BenefactorWhereUniqueInput>
  }

  export type WithdrawalUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutApprovedByInput>, Enumerable<WithdrawalUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutApprovedByInput>
    createMany?: WithdrawalCreateManyApprovedByInputEnvelope
    connect?: Enumerable<WithdrawalWhereUniqueInput>
  }

  export type BeneficiaryUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutPersonInput>, Enumerable<BeneficiaryUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutPersonInput>
    createMany?: BeneficiaryCreateManyPersonInputEnvelope
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
  }

  export type InfoRequestUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<InfoRequestCreateWithoutPersonInput>, Enumerable<InfoRequestUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<InfoRequestCreateOrConnectWithoutPersonInput>
    createMany?: InfoRequestCreateManyPersonInputEnvelope
    connect?: Enumerable<InfoRequestWhereUniqueInput>
  }

  export type CoordinatorUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<CoordinatorCreateWithoutPersonInput>, Enumerable<CoordinatorUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<CoordinatorCreateOrConnectWithoutPersonInput>
    createMany?: CoordinatorCreateManyPersonInputEnvelope
    connect?: Enumerable<CoordinatorWhereUniqueInput>
  }

  export type RecurringDonationUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<Enumerable<RecurringDonationCreateWithoutPersonInput>, Enumerable<RecurringDonationUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<RecurringDonationCreateOrConnectWithoutPersonInput>
    createMany?: RecurringDonationCreateManyPersonInputEnvelope
    connect?: Enumerable<RecurringDonationWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DonationUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<DonationCreateWithoutPersonInput>, Enumerable<DonationUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<DonationCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<DonationUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: DonationCreateManyPersonInputEnvelope
    set?: Enumerable<DonationWhereUniqueInput>
    disconnect?: Enumerable<DonationWhereUniqueInput>
    delete?: Enumerable<DonationWhereUniqueInput>
    connect?: Enumerable<DonationWhereUniqueInput>
    update?: Enumerable<DonationUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<DonationUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<DonationScalarWhereInput>
  }

  export type ExpenseUpdateManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutApprovedByInput>, Enumerable<ExpenseUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutApprovedByInput>
    upsert?: Enumerable<ExpenseUpsertWithWhereUniqueWithoutApprovedByInput>
    createMany?: ExpenseCreateManyApprovedByInputEnvelope
    set?: Enumerable<ExpenseWhereUniqueInput>
    disconnect?: Enumerable<ExpenseWhereUniqueInput>
    delete?: Enumerable<ExpenseWhereUniqueInput>
    connect?: Enumerable<ExpenseWhereUniqueInput>
    update?: Enumerable<ExpenseUpdateWithWhereUniqueWithoutApprovedByInput>
    updateMany?: Enumerable<ExpenseUpdateManyWithWhereWithoutApprovedByInput>
    deleteMany?: Enumerable<ExpenseScalarWhereInput>
  }

  export type DocumentUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutOwnerInput>, Enumerable<DocumentUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: DocumentCreateManyOwnerInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type TransferUpdateManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<TransferCreateWithoutApprovedByInput>, Enumerable<TransferUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutApprovedByInput>
    upsert?: Enumerable<TransferUpsertWithWhereUniqueWithoutApprovedByInput>
    createMany?: TransferCreateManyApprovedByInputEnvelope
    set?: Enumerable<TransferWhereUniqueInput>
    disconnect?: Enumerable<TransferWhereUniqueInput>
    delete?: Enumerable<TransferWhereUniqueInput>
    connect?: Enumerable<TransferWhereUniqueInput>
    update?: Enumerable<TransferUpdateWithWhereUniqueWithoutApprovedByInput>
    updateMany?: Enumerable<TransferUpdateManyWithWhereWithoutApprovedByInput>
    deleteMany?: Enumerable<TransferScalarWhereInput>
  }

  export type CampaignUpdateManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutApprovedByInput>, Enumerable<CampaignUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutApprovedByInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutApprovedByInput>
    createMany?: CampaignCreateManyApprovedByInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutApprovedByInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutApprovedByInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type SupporterUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<SupporterCreateWithoutPersonInput>, Enumerable<SupporterUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<SupporterCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<SupporterUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: SupporterCreateManyPersonInputEnvelope
    set?: Enumerable<SupporterWhereUniqueInput>
    disconnect?: Enumerable<SupporterWhereUniqueInput>
    delete?: Enumerable<SupporterWhereUniqueInput>
    connect?: Enumerable<SupporterWhereUniqueInput>
    update?: Enumerable<SupporterUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<SupporterUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<SupporterScalarWhereInput>
  }

  export type BenefactorUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<BenefactorCreateWithoutPersonInput>, Enumerable<BenefactorUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<BenefactorCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<BenefactorUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: BenefactorCreateManyPersonInputEnvelope
    set?: Enumerable<BenefactorWhereUniqueInput>
    disconnect?: Enumerable<BenefactorWhereUniqueInput>
    delete?: Enumerable<BenefactorWhereUniqueInput>
    connect?: Enumerable<BenefactorWhereUniqueInput>
    update?: Enumerable<BenefactorUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<BenefactorUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<BenefactorScalarWhereInput>
  }

  export type WithdrawalUpdateManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutApprovedByInput>, Enumerable<WithdrawalUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutApprovedByInput>
    upsert?: Enumerable<WithdrawalUpsertWithWhereUniqueWithoutApprovedByInput>
    createMany?: WithdrawalCreateManyApprovedByInputEnvelope
    set?: Enumerable<WithdrawalWhereUniqueInput>
    disconnect?: Enumerable<WithdrawalWhereUniqueInput>
    delete?: Enumerable<WithdrawalWhereUniqueInput>
    connect?: Enumerable<WithdrawalWhereUniqueInput>
    update?: Enumerable<WithdrawalUpdateWithWhereUniqueWithoutApprovedByInput>
    updateMany?: Enumerable<WithdrawalUpdateManyWithWhereWithoutApprovedByInput>
    deleteMany?: Enumerable<WithdrawalScalarWhereInput>
  }

  export type BeneficiaryUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutPersonInput>, Enumerable<BeneficiaryUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<BeneficiaryUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: BeneficiaryCreateManyPersonInputEnvelope
    set?: Enumerable<BeneficiaryWhereUniqueInput>
    disconnect?: Enumerable<BeneficiaryWhereUniqueInput>
    delete?: Enumerable<BeneficiaryWhereUniqueInput>
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
    update?: Enumerable<BeneficiaryUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<BeneficiaryUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<BeneficiaryScalarWhereInput>
  }

  export type InfoRequestUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<InfoRequestCreateWithoutPersonInput>, Enumerable<InfoRequestUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<InfoRequestCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<InfoRequestUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: InfoRequestCreateManyPersonInputEnvelope
    set?: Enumerable<InfoRequestWhereUniqueInput>
    disconnect?: Enumerable<InfoRequestWhereUniqueInput>
    delete?: Enumerable<InfoRequestWhereUniqueInput>
    connect?: Enumerable<InfoRequestWhereUniqueInput>
    update?: Enumerable<InfoRequestUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<InfoRequestUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<InfoRequestScalarWhereInput>
  }

  export type CoordinatorUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<CoordinatorCreateWithoutPersonInput>, Enumerable<CoordinatorUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<CoordinatorCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<CoordinatorUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: CoordinatorCreateManyPersonInputEnvelope
    set?: Enumerable<CoordinatorWhereUniqueInput>
    disconnect?: Enumerable<CoordinatorWhereUniqueInput>
    delete?: Enumerable<CoordinatorWhereUniqueInput>
    connect?: Enumerable<CoordinatorWhereUniqueInput>
    update?: Enumerable<CoordinatorUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<CoordinatorUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<CoordinatorScalarWhereInput>
  }

  export type RecurringDonationUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<RecurringDonationCreateWithoutPersonInput>, Enumerable<RecurringDonationUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<RecurringDonationCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<RecurringDonationUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: RecurringDonationCreateManyPersonInputEnvelope
    set?: Enumerable<RecurringDonationWhereUniqueInput>
    disconnect?: Enumerable<RecurringDonationWhereUniqueInput>
    delete?: Enumerable<RecurringDonationWhereUniqueInput>
    connect?: Enumerable<RecurringDonationWhereUniqueInput>
    update?: Enumerable<RecurringDonationUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<RecurringDonationUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<RecurringDonationScalarWhereInput>
  }

  export type DonationUncheckedUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<DonationCreateWithoutPersonInput>, Enumerable<DonationUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<DonationCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<DonationUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: DonationCreateManyPersonInputEnvelope
    set?: Enumerable<DonationWhereUniqueInput>
    disconnect?: Enumerable<DonationWhereUniqueInput>
    delete?: Enumerable<DonationWhereUniqueInput>
    connect?: Enumerable<DonationWhereUniqueInput>
    update?: Enumerable<DonationUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<DonationUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<DonationScalarWhereInput>
  }

  export type ExpenseUncheckedUpdateManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutApprovedByInput>, Enumerable<ExpenseUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutApprovedByInput>
    upsert?: Enumerable<ExpenseUpsertWithWhereUniqueWithoutApprovedByInput>
    createMany?: ExpenseCreateManyApprovedByInputEnvelope
    set?: Enumerable<ExpenseWhereUniqueInput>
    disconnect?: Enumerable<ExpenseWhereUniqueInput>
    delete?: Enumerable<ExpenseWhereUniqueInput>
    connect?: Enumerable<ExpenseWhereUniqueInput>
    update?: Enumerable<ExpenseUpdateWithWhereUniqueWithoutApprovedByInput>
    updateMany?: Enumerable<ExpenseUpdateManyWithWhereWithoutApprovedByInput>
    deleteMany?: Enumerable<ExpenseScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutOwnerInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutOwnerInput>, Enumerable<DocumentUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: DocumentCreateManyOwnerInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type TransferUncheckedUpdateManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<TransferCreateWithoutApprovedByInput>, Enumerable<TransferUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutApprovedByInput>
    upsert?: Enumerable<TransferUpsertWithWhereUniqueWithoutApprovedByInput>
    createMany?: TransferCreateManyApprovedByInputEnvelope
    set?: Enumerable<TransferWhereUniqueInput>
    disconnect?: Enumerable<TransferWhereUniqueInput>
    delete?: Enumerable<TransferWhereUniqueInput>
    connect?: Enumerable<TransferWhereUniqueInput>
    update?: Enumerable<TransferUpdateWithWhereUniqueWithoutApprovedByInput>
    updateMany?: Enumerable<TransferUpdateManyWithWhereWithoutApprovedByInput>
    deleteMany?: Enumerable<TransferScalarWhereInput>
  }

  export type CampaignUncheckedUpdateManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutApprovedByInput>, Enumerable<CampaignUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutApprovedByInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutApprovedByInput>
    createMany?: CampaignCreateManyApprovedByInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutApprovedByInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutApprovedByInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type SupporterUncheckedUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<SupporterCreateWithoutPersonInput>, Enumerable<SupporterUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<SupporterCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<SupporterUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: SupporterCreateManyPersonInputEnvelope
    set?: Enumerable<SupporterWhereUniqueInput>
    disconnect?: Enumerable<SupporterWhereUniqueInput>
    delete?: Enumerable<SupporterWhereUniqueInput>
    connect?: Enumerable<SupporterWhereUniqueInput>
    update?: Enumerable<SupporterUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<SupporterUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<SupporterScalarWhereInput>
  }

  export type BenefactorUncheckedUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<BenefactorCreateWithoutPersonInput>, Enumerable<BenefactorUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<BenefactorCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<BenefactorUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: BenefactorCreateManyPersonInputEnvelope
    set?: Enumerable<BenefactorWhereUniqueInput>
    disconnect?: Enumerable<BenefactorWhereUniqueInput>
    delete?: Enumerable<BenefactorWhereUniqueInput>
    connect?: Enumerable<BenefactorWhereUniqueInput>
    update?: Enumerable<BenefactorUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<BenefactorUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<BenefactorScalarWhereInput>
  }

  export type WithdrawalUncheckedUpdateManyWithoutApprovedByInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutApprovedByInput>, Enumerable<WithdrawalUncheckedCreateWithoutApprovedByInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutApprovedByInput>
    upsert?: Enumerable<WithdrawalUpsertWithWhereUniqueWithoutApprovedByInput>
    createMany?: WithdrawalCreateManyApprovedByInputEnvelope
    set?: Enumerable<WithdrawalWhereUniqueInput>
    disconnect?: Enumerable<WithdrawalWhereUniqueInput>
    delete?: Enumerable<WithdrawalWhereUniqueInput>
    connect?: Enumerable<WithdrawalWhereUniqueInput>
    update?: Enumerable<WithdrawalUpdateWithWhereUniqueWithoutApprovedByInput>
    updateMany?: Enumerable<WithdrawalUpdateManyWithWhereWithoutApprovedByInput>
    deleteMany?: Enumerable<WithdrawalScalarWhereInput>
  }

  export type BeneficiaryUncheckedUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutPersonInput>, Enumerable<BeneficiaryUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<BeneficiaryUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: BeneficiaryCreateManyPersonInputEnvelope
    set?: Enumerable<BeneficiaryWhereUniqueInput>
    disconnect?: Enumerable<BeneficiaryWhereUniqueInput>
    delete?: Enumerable<BeneficiaryWhereUniqueInput>
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
    update?: Enumerable<BeneficiaryUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<BeneficiaryUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<BeneficiaryScalarWhereInput>
  }

  export type InfoRequestUncheckedUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<InfoRequestCreateWithoutPersonInput>, Enumerable<InfoRequestUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<InfoRequestCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<InfoRequestUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: InfoRequestCreateManyPersonInputEnvelope
    set?: Enumerable<InfoRequestWhereUniqueInput>
    disconnect?: Enumerable<InfoRequestWhereUniqueInput>
    delete?: Enumerable<InfoRequestWhereUniqueInput>
    connect?: Enumerable<InfoRequestWhereUniqueInput>
    update?: Enumerable<InfoRequestUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<InfoRequestUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<InfoRequestScalarWhereInput>
  }

  export type CoordinatorUncheckedUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<CoordinatorCreateWithoutPersonInput>, Enumerable<CoordinatorUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<CoordinatorCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<CoordinatorUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: CoordinatorCreateManyPersonInputEnvelope
    set?: Enumerable<CoordinatorWhereUniqueInput>
    disconnect?: Enumerable<CoordinatorWhereUniqueInput>
    delete?: Enumerable<CoordinatorWhereUniqueInput>
    connect?: Enumerable<CoordinatorWhereUniqueInput>
    update?: Enumerable<CoordinatorUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<CoordinatorUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<CoordinatorScalarWhereInput>
  }

  export type RecurringDonationUncheckedUpdateManyWithoutPersonInput = {
    create?: XOR<Enumerable<RecurringDonationCreateWithoutPersonInput>, Enumerable<RecurringDonationUncheckedCreateWithoutPersonInput>>
    connectOrCreate?: Enumerable<RecurringDonationCreateOrConnectWithoutPersonInput>
    upsert?: Enumerable<RecurringDonationUpsertWithWhereUniqueWithoutPersonInput>
    createMany?: RecurringDonationCreateManyPersonInputEnvelope
    set?: Enumerable<RecurringDonationWhereUniqueInput>
    disconnect?: Enumerable<RecurringDonationWhereUniqueInput>
    delete?: Enumerable<RecurringDonationWhereUniqueInput>
    connect?: Enumerable<RecurringDonationWhereUniqueInput>
    update?: Enumerable<RecurringDonationUpdateWithWhereUniqueWithoutPersonInput>
    updateMany?: Enumerable<RecurringDonationUpdateManyWithWhereWithoutPersonInput>
    deleteMany?: Enumerable<RecurringDonationScalarWhereInput>
  }

  export type BeneficiaryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutCompanyInput>, Enumerable<BeneficiaryUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutCompanyInput>
    createMany?: BeneficiaryCreateManyCompanyInputEnvelope
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
  }

  export type BeneficiaryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutCompanyInput>, Enumerable<BeneficiaryUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutCompanyInput>
    createMany?: BeneficiaryCreateManyCompanyInputEnvelope
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
  }

  export type BeneficiaryUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutCompanyInput>, Enumerable<BeneficiaryUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<BeneficiaryUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: BeneficiaryCreateManyCompanyInputEnvelope
    set?: Enumerable<BeneficiaryWhereUniqueInput>
    disconnect?: Enumerable<BeneficiaryWhereUniqueInput>
    delete?: Enumerable<BeneficiaryWhereUniqueInput>
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
    update?: Enumerable<BeneficiaryUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<BeneficiaryUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<BeneficiaryScalarWhereInput>
  }

  export type BeneficiaryUncheckedUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutCompanyInput>, Enumerable<BeneficiaryUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<BeneficiaryUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: BeneficiaryCreateManyCompanyInputEnvelope
    set?: Enumerable<BeneficiaryWhereUniqueInput>
    disconnect?: Enumerable<BeneficiaryWhereUniqueInput>
    delete?: Enumerable<BeneficiaryWhereUniqueInput>
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
    update?: Enumerable<BeneficiaryUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<BeneficiaryUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<BeneficiaryScalarWhereInput>
  }

  export type PersonCreateNestedOneWithoutCoordinatorsInput = {
    create?: XOR<PersonCreateWithoutCoordinatorsInput, PersonUncheckedCreateWithoutCoordinatorsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutCoordinatorsInput
    connect?: PersonWhereUniqueInput
  }

  export type BeneficiaryCreateNestedManyWithoutCoordinatorInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutCoordinatorInput>, Enumerable<BeneficiaryUncheckedCreateWithoutCoordinatorInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutCoordinatorInput>
    createMany?: BeneficiaryCreateManyCoordinatorInputEnvelope
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
  }

  export type BeneficiaryUncheckedCreateNestedManyWithoutCoordinatorInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutCoordinatorInput>, Enumerable<BeneficiaryUncheckedCreateWithoutCoordinatorInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutCoordinatorInput>
    createMany?: BeneficiaryCreateManyCoordinatorInputEnvelope
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
  }

  export type PersonUpdateOneRequiredWithoutCoordinatorsInput = {
    create?: XOR<PersonCreateWithoutCoordinatorsInput, PersonUncheckedCreateWithoutCoordinatorsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutCoordinatorsInput
    upsert?: PersonUpsertWithoutCoordinatorsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutCoordinatorsInput, PersonUncheckedUpdateWithoutCoordinatorsInput>
  }

  export type BeneficiaryUpdateManyWithoutCoordinatorInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutCoordinatorInput>, Enumerable<BeneficiaryUncheckedCreateWithoutCoordinatorInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutCoordinatorInput>
    upsert?: Enumerable<BeneficiaryUpsertWithWhereUniqueWithoutCoordinatorInput>
    createMany?: BeneficiaryCreateManyCoordinatorInputEnvelope
    set?: Enumerable<BeneficiaryWhereUniqueInput>
    disconnect?: Enumerable<BeneficiaryWhereUniqueInput>
    delete?: Enumerable<BeneficiaryWhereUniqueInput>
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
    update?: Enumerable<BeneficiaryUpdateWithWhereUniqueWithoutCoordinatorInput>
    updateMany?: Enumerable<BeneficiaryUpdateManyWithWhereWithoutCoordinatorInput>
    deleteMany?: Enumerable<BeneficiaryScalarWhereInput>
  }

  export type BeneficiaryUncheckedUpdateManyWithoutCoordinatorInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutCoordinatorInput>, Enumerable<BeneficiaryUncheckedCreateWithoutCoordinatorInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutCoordinatorInput>
    upsert?: Enumerable<BeneficiaryUpsertWithWhereUniqueWithoutCoordinatorInput>
    createMany?: BeneficiaryCreateManyCoordinatorInputEnvelope
    set?: Enumerable<BeneficiaryWhereUniqueInput>
    disconnect?: Enumerable<BeneficiaryWhereUniqueInput>
    delete?: Enumerable<BeneficiaryWhereUniqueInput>
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
    update?: Enumerable<BeneficiaryUpdateWithWhereUniqueWithoutCoordinatorInput>
    updateMany?: Enumerable<BeneficiaryUpdateManyWithWhereWithoutCoordinatorInput>
    deleteMany?: Enumerable<BeneficiaryScalarWhereInput>
  }

  export type PersonCreateNestedOneWithoutBenefactorsInput = {
    create?: XOR<PersonCreateWithoutBenefactorsInput, PersonUncheckedCreateWithoutBenefactorsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutBenefactorsInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutBenefactorsInput = {
    create?: XOR<PersonCreateWithoutBenefactorsInput, PersonUncheckedCreateWithoutBenefactorsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutBenefactorsInput
    upsert?: PersonUpsertWithoutBenefactorsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutBenefactorsInput, PersonUncheckedUpdateWithoutBenefactorsInput>
  }

  export type CityCreateNestedOneWithoutBeneficiariesInput = {
    create?: XOR<CityCreateWithoutBeneficiariesInput, CityUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: CityCreateOrConnectWithoutBeneficiariesInput
    connect?: CityWhereUniqueInput
  }

  export type CoordinatorCreateNestedOneWithoutBeneficiariesInput = {
    create?: XOR<CoordinatorCreateWithoutBeneficiariesInput, CoordinatorUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: CoordinatorCreateOrConnectWithoutBeneficiariesInput
    connect?: CoordinatorWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutBeneficiariesInput = {
    create?: XOR<PersonCreateWithoutBeneficiariesInput, PersonUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutBeneficiariesInput
    connect?: PersonWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutBeneficiariesInput = {
    create?: XOR<CompanyCreateWithoutBeneficiariesInput, CompanyUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBeneficiariesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutBeneficiariesInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutBeneficiariesInput>, Enumerable<CampaignUncheckedCreateWithoutBeneficiariesInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutBeneficiariesInput>
    createMany?: CampaignCreateManyBeneficiariesInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type CampaignUncheckedCreateNestedManyWithoutBeneficiariesInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutBeneficiariesInput>, Enumerable<CampaignUncheckedCreateWithoutBeneficiariesInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutBeneficiariesInput>
    createMany?: CampaignCreateManyBeneficiariesInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type EnumBeneficiaryTypeFieldUpdateOperationsInput = {
    set?: BeneficiaryType
  }

  export type EnumPersonRelationFieldUpdateOperationsInput = {
    set?: PersonRelation
  }

  export type CityUpdateOneRequiredWithoutBeneficiariesInput = {
    create?: XOR<CityCreateWithoutBeneficiariesInput, CityUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: CityCreateOrConnectWithoutBeneficiariesInput
    upsert?: CityUpsertWithoutBeneficiariesInput
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutBeneficiariesInput, CityUncheckedUpdateWithoutBeneficiariesInput>
  }

  export type CoordinatorUpdateOneRequiredWithoutBeneficiariesInput = {
    create?: XOR<CoordinatorCreateWithoutBeneficiariesInput, CoordinatorUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: CoordinatorCreateOrConnectWithoutBeneficiariesInput
    upsert?: CoordinatorUpsertWithoutBeneficiariesInput
    connect?: CoordinatorWhereUniqueInput
    update?: XOR<CoordinatorUpdateWithoutBeneficiariesInput, CoordinatorUncheckedUpdateWithoutBeneficiariesInput>
  }

  export type PersonUpdateOneWithoutBeneficiariesInput = {
    create?: XOR<PersonCreateWithoutBeneficiariesInput, PersonUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutBeneficiariesInput
    upsert?: PersonUpsertWithoutBeneficiariesInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutBeneficiariesInput, PersonUncheckedUpdateWithoutBeneficiariesInput>
  }

  export type CompanyUpdateOneWithoutBeneficiariesInput = {
    create?: XOR<CompanyCreateWithoutBeneficiariesInput, CompanyUncheckedCreateWithoutBeneficiariesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBeneficiariesInput
    upsert?: CompanyUpsertWithoutBeneficiariesInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutBeneficiariesInput, CompanyUncheckedUpdateWithoutBeneficiariesInput>
  }

  export type CampaignUpdateManyWithoutBeneficiariesInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutBeneficiariesInput>, Enumerable<CampaignUncheckedCreateWithoutBeneficiariesInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutBeneficiariesInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutBeneficiariesInput>
    createMany?: CampaignCreateManyBeneficiariesInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutBeneficiariesInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutBeneficiariesInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type CampaignUncheckedUpdateManyWithoutBeneficiariesInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutBeneficiariesInput>, Enumerable<CampaignUncheckedCreateWithoutBeneficiariesInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutBeneficiariesInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutBeneficiariesInput>
    createMany?: CampaignCreateManyBeneficiariesInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutBeneficiariesInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutBeneficiariesInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type CampaignTypeCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CampaignTypeCreateWithoutChildrenInput, CampaignTypeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CampaignTypeCreateOrConnectWithoutChildrenInput
    connect?: CampaignTypeWhereUniqueInput
  }

  export type CampaignTypeCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<CampaignTypeCreateWithoutParentInput>, Enumerable<CampaignTypeUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CampaignTypeCreateOrConnectWithoutParentInput>
    createMany?: CampaignTypeCreateManyParentInputEnvelope
    connect?: Enumerable<CampaignTypeWhereUniqueInput>
  }

  export type CampaignCreateNestedManyWithoutCampaignTypesInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutCampaignTypesInput>, Enumerable<CampaignUncheckedCreateWithoutCampaignTypesInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutCampaignTypesInput>
    createMany?: CampaignCreateManyCampaignTypesInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type CampaignTypeUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<CampaignTypeCreateWithoutParentInput>, Enumerable<CampaignTypeUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CampaignTypeCreateOrConnectWithoutParentInput>
    createMany?: CampaignTypeCreateManyParentInputEnvelope
    connect?: Enumerable<CampaignTypeWhereUniqueInput>
  }

  export type CampaignUncheckedCreateNestedManyWithoutCampaignTypesInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutCampaignTypesInput>, Enumerable<CampaignUncheckedCreateWithoutCampaignTypesInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutCampaignTypesInput>
    createMany?: CampaignCreateManyCampaignTypesInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type CampaignTypeUpdateOneWithoutChildrenInput = {
    create?: XOR<CampaignTypeCreateWithoutChildrenInput, CampaignTypeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CampaignTypeCreateOrConnectWithoutChildrenInput
    upsert?: CampaignTypeUpsertWithoutChildrenInput
    disconnect?: boolean
    delete?: boolean
    connect?: CampaignTypeWhereUniqueInput
    update?: XOR<CampaignTypeUpdateWithoutChildrenInput, CampaignTypeUncheckedUpdateWithoutChildrenInput>
  }

  export type CampaignTypeUpdateManyWithoutParentInput = {
    create?: XOR<Enumerable<CampaignTypeCreateWithoutParentInput>, Enumerable<CampaignTypeUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CampaignTypeCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<CampaignTypeUpsertWithWhereUniqueWithoutParentInput>
    createMany?: CampaignTypeCreateManyParentInputEnvelope
    set?: Enumerable<CampaignTypeWhereUniqueInput>
    disconnect?: Enumerable<CampaignTypeWhereUniqueInput>
    delete?: Enumerable<CampaignTypeWhereUniqueInput>
    connect?: Enumerable<CampaignTypeWhereUniqueInput>
    update?: Enumerable<CampaignTypeUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<CampaignTypeUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<CampaignTypeScalarWhereInput>
  }

  export type CampaignUpdateManyWithoutCampaignTypesInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutCampaignTypesInput>, Enumerable<CampaignUncheckedCreateWithoutCampaignTypesInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutCampaignTypesInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutCampaignTypesInput>
    createMany?: CampaignCreateManyCampaignTypesInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutCampaignTypesInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutCampaignTypesInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type CampaignTypeUncheckedUpdateManyWithoutParentInput = {
    create?: XOR<Enumerable<CampaignTypeCreateWithoutParentInput>, Enumerable<CampaignTypeUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CampaignTypeCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<CampaignTypeUpsertWithWhereUniqueWithoutParentInput>
    createMany?: CampaignTypeCreateManyParentInputEnvelope
    set?: Enumerable<CampaignTypeWhereUniqueInput>
    disconnect?: Enumerable<CampaignTypeWhereUniqueInput>
    delete?: Enumerable<CampaignTypeWhereUniqueInput>
    connect?: Enumerable<CampaignTypeWhereUniqueInput>
    update?: Enumerable<CampaignTypeUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<CampaignTypeUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<CampaignTypeScalarWhereInput>
  }

  export type CampaignUncheckedUpdateManyWithoutCampaignTypesInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutCampaignTypesInput>, Enumerable<CampaignUncheckedCreateWithoutCampaignTypesInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutCampaignTypesInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutCampaignTypesInput>
    createMany?: CampaignCreateManyCampaignTypesInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutCampaignTypesInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutCampaignTypesInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type PersonCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<PersonCreateWithoutCampaignsInput, PersonUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutCampaignsInput
    connect?: PersonWhereUniqueInput
  }

  export type BeneficiaryCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<BeneficiaryCreateWithoutCampaignsInput, BeneficiaryUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutCampaignsInput
    connect?: BeneficiaryWhereUniqueInput
  }

  export type CampaignTypeCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<CampaignTypeCreateWithoutCampaignsInput, CampaignTypeUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: CampaignTypeCreateOrConnectWithoutCampaignsInput
    connect?: CampaignTypeWhereUniqueInput
  }

  export type VaultCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<VaultCreateWithoutCampaignInput>, Enumerable<VaultUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<VaultCreateOrConnectWithoutCampaignInput>
    createMany?: VaultCreateManyCampaignInputEnvelope
    connect?: Enumerable<VaultWhereUniqueInput>
  }

  export type TransferCreateNestedManyWithoutTargetCampaignInput = {
    create?: XOR<Enumerable<TransferCreateWithoutTargetCampaignInput>, Enumerable<TransferUncheckedCreateWithoutTargetCampaignInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutTargetCampaignInput>
    createMany?: TransferCreateManyTargetCampaignInputEnvelope
    connect?: Enumerable<TransferWhereUniqueInput>
  }

  export type TransferCreateNestedManyWithoutSourceCampaignInput = {
    create?: XOR<Enumerable<TransferCreateWithoutSourceCampaignInput>, Enumerable<TransferUncheckedCreateWithoutSourceCampaignInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutSourceCampaignInput>
    createMany?: TransferCreateManySourceCampaignInputEnvelope
    connect?: Enumerable<TransferWhereUniqueInput>
  }

  export type WithdrawalCreateNestedManyWithoutSourceCampaignInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutSourceCampaignInput>, Enumerable<WithdrawalUncheckedCreateWithoutSourceCampaignInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutSourceCampaignInput>
    createMany?: WithdrawalCreateManySourceCampaignInputEnvelope
    connect?: Enumerable<WithdrawalWhereUniqueInput>
  }

  export type VaultUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<VaultCreateWithoutCampaignInput>, Enumerable<VaultUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<VaultCreateOrConnectWithoutCampaignInput>
    createMany?: VaultCreateManyCampaignInputEnvelope
    connect?: Enumerable<VaultWhereUniqueInput>
  }

  export type TransferUncheckedCreateNestedManyWithoutTargetCampaignInput = {
    create?: XOR<Enumerable<TransferCreateWithoutTargetCampaignInput>, Enumerable<TransferUncheckedCreateWithoutTargetCampaignInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutTargetCampaignInput>
    createMany?: TransferCreateManyTargetCampaignInputEnvelope
    connect?: Enumerable<TransferWhereUniqueInput>
  }

  export type TransferUncheckedCreateNestedManyWithoutSourceCampaignInput = {
    create?: XOR<Enumerable<TransferCreateWithoutSourceCampaignInput>, Enumerable<TransferUncheckedCreateWithoutSourceCampaignInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutSourceCampaignInput>
    createMany?: TransferCreateManySourceCampaignInputEnvelope
    connect?: Enumerable<TransferWhereUniqueInput>
  }

  export type WithdrawalUncheckedCreateNestedManyWithoutSourceCampaignInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutSourceCampaignInput>, Enumerable<WithdrawalUncheckedCreateWithoutSourceCampaignInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutSourceCampaignInput>
    createMany?: WithdrawalCreateManySourceCampaignInputEnvelope
    connect?: Enumerable<WithdrawalWhereUniqueInput>
  }

  export type EnumCampaignStateFieldUpdateOperationsInput = {
    set?: CampaignState
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCurrencyFieldUpdateOperationsInput = {
    set?: Currency
  }

  export type PersonUpdateOneWithoutCampaignsInput = {
    create?: XOR<PersonCreateWithoutCampaignsInput, PersonUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutCampaignsInput
    upsert?: PersonUpsertWithoutCampaignsInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutCampaignsInput, PersonUncheckedUpdateWithoutCampaignsInput>
  }

  export type BeneficiaryUpdateOneRequiredWithoutCampaignsInput = {
    create?: XOR<BeneficiaryCreateWithoutCampaignsInput, BeneficiaryUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: BeneficiaryCreateOrConnectWithoutCampaignsInput
    upsert?: BeneficiaryUpsertWithoutCampaignsInput
    connect?: BeneficiaryWhereUniqueInput
    update?: XOR<BeneficiaryUpdateWithoutCampaignsInput, BeneficiaryUncheckedUpdateWithoutCampaignsInput>
  }

  export type CampaignTypeUpdateOneRequiredWithoutCampaignsInput = {
    create?: XOR<CampaignTypeCreateWithoutCampaignsInput, CampaignTypeUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: CampaignTypeCreateOrConnectWithoutCampaignsInput
    upsert?: CampaignTypeUpsertWithoutCampaignsInput
    connect?: CampaignTypeWhereUniqueInput
    update?: XOR<CampaignTypeUpdateWithoutCampaignsInput, CampaignTypeUncheckedUpdateWithoutCampaignsInput>
  }

  export type VaultUpdateManyWithoutCampaignInput = {
    create?: XOR<Enumerable<VaultCreateWithoutCampaignInput>, Enumerable<VaultUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<VaultCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<VaultUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: VaultCreateManyCampaignInputEnvelope
    set?: Enumerable<VaultWhereUniqueInput>
    disconnect?: Enumerable<VaultWhereUniqueInput>
    delete?: Enumerable<VaultWhereUniqueInput>
    connect?: Enumerable<VaultWhereUniqueInput>
    update?: Enumerable<VaultUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<VaultUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<VaultScalarWhereInput>
  }

  export type TransferUpdateManyWithoutTargetCampaignInput = {
    create?: XOR<Enumerable<TransferCreateWithoutTargetCampaignInput>, Enumerable<TransferUncheckedCreateWithoutTargetCampaignInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutTargetCampaignInput>
    upsert?: Enumerable<TransferUpsertWithWhereUniqueWithoutTargetCampaignInput>
    createMany?: TransferCreateManyTargetCampaignInputEnvelope
    set?: Enumerable<TransferWhereUniqueInput>
    disconnect?: Enumerable<TransferWhereUniqueInput>
    delete?: Enumerable<TransferWhereUniqueInput>
    connect?: Enumerable<TransferWhereUniqueInput>
    update?: Enumerable<TransferUpdateWithWhereUniqueWithoutTargetCampaignInput>
    updateMany?: Enumerable<TransferUpdateManyWithWhereWithoutTargetCampaignInput>
    deleteMany?: Enumerable<TransferScalarWhereInput>
  }

  export type TransferUpdateManyWithoutSourceCampaignInput = {
    create?: XOR<Enumerable<TransferCreateWithoutSourceCampaignInput>, Enumerable<TransferUncheckedCreateWithoutSourceCampaignInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutSourceCampaignInput>
    upsert?: Enumerable<TransferUpsertWithWhereUniqueWithoutSourceCampaignInput>
    createMany?: TransferCreateManySourceCampaignInputEnvelope
    set?: Enumerable<TransferWhereUniqueInput>
    disconnect?: Enumerable<TransferWhereUniqueInput>
    delete?: Enumerable<TransferWhereUniqueInput>
    connect?: Enumerable<TransferWhereUniqueInput>
    update?: Enumerable<TransferUpdateWithWhereUniqueWithoutSourceCampaignInput>
    updateMany?: Enumerable<TransferUpdateManyWithWhereWithoutSourceCampaignInput>
    deleteMany?: Enumerable<TransferScalarWhereInput>
  }

  export type WithdrawalUpdateManyWithoutSourceCampaignInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutSourceCampaignInput>, Enumerable<WithdrawalUncheckedCreateWithoutSourceCampaignInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutSourceCampaignInput>
    upsert?: Enumerable<WithdrawalUpsertWithWhereUniqueWithoutSourceCampaignInput>
    createMany?: WithdrawalCreateManySourceCampaignInputEnvelope
    set?: Enumerable<WithdrawalWhereUniqueInput>
    disconnect?: Enumerable<WithdrawalWhereUniqueInput>
    delete?: Enumerable<WithdrawalWhereUniqueInput>
    connect?: Enumerable<WithdrawalWhereUniqueInput>
    update?: Enumerable<WithdrawalUpdateWithWhereUniqueWithoutSourceCampaignInput>
    updateMany?: Enumerable<WithdrawalUpdateManyWithWhereWithoutSourceCampaignInput>
    deleteMany?: Enumerable<WithdrawalScalarWhereInput>
  }

  export type VaultUncheckedUpdateManyWithoutCampaignInput = {
    create?: XOR<Enumerable<VaultCreateWithoutCampaignInput>, Enumerable<VaultUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<VaultCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<VaultUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: VaultCreateManyCampaignInputEnvelope
    set?: Enumerable<VaultWhereUniqueInput>
    disconnect?: Enumerable<VaultWhereUniqueInput>
    delete?: Enumerable<VaultWhereUniqueInput>
    connect?: Enumerable<VaultWhereUniqueInput>
    update?: Enumerable<VaultUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<VaultUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<VaultScalarWhereInput>
  }

  export type TransferUncheckedUpdateManyWithoutTargetCampaignInput = {
    create?: XOR<Enumerable<TransferCreateWithoutTargetCampaignInput>, Enumerable<TransferUncheckedCreateWithoutTargetCampaignInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutTargetCampaignInput>
    upsert?: Enumerable<TransferUpsertWithWhereUniqueWithoutTargetCampaignInput>
    createMany?: TransferCreateManyTargetCampaignInputEnvelope
    set?: Enumerable<TransferWhereUniqueInput>
    disconnect?: Enumerable<TransferWhereUniqueInput>
    delete?: Enumerable<TransferWhereUniqueInput>
    connect?: Enumerable<TransferWhereUniqueInput>
    update?: Enumerable<TransferUpdateWithWhereUniqueWithoutTargetCampaignInput>
    updateMany?: Enumerable<TransferUpdateManyWithWhereWithoutTargetCampaignInput>
    deleteMany?: Enumerable<TransferScalarWhereInput>
  }

  export type TransferUncheckedUpdateManyWithoutSourceCampaignInput = {
    create?: XOR<Enumerable<TransferCreateWithoutSourceCampaignInput>, Enumerable<TransferUncheckedCreateWithoutSourceCampaignInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutSourceCampaignInput>
    upsert?: Enumerable<TransferUpsertWithWhereUniqueWithoutSourceCampaignInput>
    createMany?: TransferCreateManySourceCampaignInputEnvelope
    set?: Enumerable<TransferWhereUniqueInput>
    disconnect?: Enumerable<TransferWhereUniqueInput>
    delete?: Enumerable<TransferWhereUniqueInput>
    connect?: Enumerable<TransferWhereUniqueInput>
    update?: Enumerable<TransferUpdateWithWhereUniqueWithoutSourceCampaignInput>
    updateMany?: Enumerable<TransferUpdateManyWithWhereWithoutSourceCampaignInput>
    deleteMany?: Enumerable<TransferScalarWhereInput>
  }

  export type WithdrawalUncheckedUpdateManyWithoutSourceCampaignInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutSourceCampaignInput>, Enumerable<WithdrawalUncheckedCreateWithoutSourceCampaignInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutSourceCampaignInput>
    upsert?: Enumerable<WithdrawalUpsertWithWhereUniqueWithoutSourceCampaignInput>
    createMany?: WithdrawalCreateManySourceCampaignInputEnvelope
    set?: Enumerable<WithdrawalWhereUniqueInput>
    disconnect?: Enumerable<WithdrawalWhereUniqueInput>
    delete?: Enumerable<WithdrawalWhereUniqueInput>
    connect?: Enumerable<WithdrawalWhereUniqueInput>
    update?: Enumerable<WithdrawalUpdateWithWhereUniqueWithoutSourceCampaignInput>
    updateMany?: Enumerable<WithdrawalUpdateManyWithWhereWithoutSourceCampaignInput>
    deleteMany?: Enumerable<WithdrawalScalarWhereInput>
  }

  export type PersonCreateNestedOneWithoutInfoRequestsInput = {
    create?: XOR<PersonCreateWithoutInfoRequestsInput, PersonUncheckedCreateWithoutInfoRequestsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutInfoRequestsInput
    connect?: PersonWhereUniqueInput
  }

  export type PersonUpdateOneRequiredWithoutInfoRequestsInput = {
    create?: XOR<PersonCreateWithoutInfoRequestsInput, PersonUncheckedCreateWithoutInfoRequestsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutInfoRequestsInput
    upsert?: PersonUpsertWithoutInfoRequestsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutInfoRequestsInput, PersonUncheckedUpdateWithoutInfoRequestsInput>
  }

  export type PersonCreateNestedOneWithoutSupportersInput = {
    create?: XOR<PersonCreateWithoutSupportersInput, PersonUncheckedCreateWithoutSupportersInput>
    connectOrCreate?: PersonCreateOrConnectWithoutSupportersInput
    connect?: PersonWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PersonUpdateOneRequiredWithoutSupportersInput = {
    create?: XOR<PersonCreateWithoutSupportersInput, PersonUncheckedCreateWithoutSupportersInput>
    connectOrCreate?: PersonCreateOrConnectWithoutSupportersInput
    upsert?: PersonUpsertWithoutSupportersInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutSupportersInput, PersonUncheckedUpdateWithoutSupportersInput>
  }

  export type CountryCreateNestedOneWithoutCitiesInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    connect?: CountryWhereUniqueInput
  }

  export type BeneficiaryCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutCityInput>, Enumerable<BeneficiaryUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutCityInput>
    createMany?: BeneficiaryCreateManyCityInputEnvelope
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
  }

  export type BeneficiaryUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutCityInput>, Enumerable<BeneficiaryUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutCityInput>
    createMany?: BeneficiaryCreateManyCityInputEnvelope
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CountryUpdateOneRequiredWithoutCitiesInput = {
    create?: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: CountryCreateOrConnectWithoutCitiesInput
    upsert?: CountryUpsertWithoutCitiesInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
  }

  export type BeneficiaryUpdateManyWithoutCityInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutCityInput>, Enumerable<BeneficiaryUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<BeneficiaryUpsertWithWhereUniqueWithoutCityInput>
    createMany?: BeneficiaryCreateManyCityInputEnvelope
    set?: Enumerable<BeneficiaryWhereUniqueInput>
    disconnect?: Enumerable<BeneficiaryWhereUniqueInput>
    delete?: Enumerable<BeneficiaryWhereUniqueInput>
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
    update?: Enumerable<BeneficiaryUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<BeneficiaryUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<BeneficiaryScalarWhereInput>
  }

  export type BeneficiaryUncheckedUpdateManyWithoutCityInput = {
    create?: XOR<Enumerable<BeneficiaryCreateWithoutCityInput>, Enumerable<BeneficiaryUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<BeneficiaryCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<BeneficiaryUpsertWithWhereUniqueWithoutCityInput>
    createMany?: BeneficiaryCreateManyCityInputEnvelope
    set?: Enumerable<BeneficiaryWhereUniqueInput>
    disconnect?: Enumerable<BeneficiaryWhereUniqueInput>
    delete?: Enumerable<BeneficiaryWhereUniqueInput>
    connect?: Enumerable<BeneficiaryWhereUniqueInput>
    update?: Enumerable<BeneficiaryUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<BeneficiaryUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<BeneficiaryScalarWhereInput>
  }

  export type CityCreateNestedManyWithoutCountryCodeInput = {
    create?: XOR<Enumerable<CityCreateWithoutCountryCodeInput>, Enumerable<CityUncheckedCreateWithoutCountryCodeInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutCountryCodeInput>
    createMany?: CityCreateManyCountryCodeInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type CityUncheckedCreateNestedManyWithoutCountryCodeInput = {
    create?: XOR<Enumerable<CityCreateWithoutCountryCodeInput>, Enumerable<CityUncheckedCreateWithoutCountryCodeInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutCountryCodeInput>
    createMany?: CityCreateManyCountryCodeInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type CityUpdateManyWithoutCountryCodeInput = {
    create?: XOR<Enumerable<CityCreateWithoutCountryCodeInput>, Enumerable<CityUncheckedCreateWithoutCountryCodeInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutCountryCodeInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutCountryCodeInput>
    createMany?: CityCreateManyCountryCodeInputEnvelope
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    connect?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutCountryCodeInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutCountryCodeInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type CityUncheckedUpdateManyWithoutCountryCodeInput = {
    create?: XOR<Enumerable<CityCreateWithoutCountryCodeInput>, Enumerable<CityUncheckedCreateWithoutCountryCodeInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutCountryCodeInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutCountryCodeInput>
    createMany?: CityCreateManyCountryCodeInputEnvelope
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    connect?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutCountryCodeInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutCountryCodeInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type CampaignCreateNestedOneWithoutVaultsInput = {
    create?: XOR<CampaignCreateWithoutVaultsInput, CampaignUncheckedCreateWithoutVaultsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutVaultsInput
    connect?: CampaignWhereUniqueInput
  }

  export type ExpenseCreateNestedManyWithoutVaultInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutVaultInput>, Enumerable<ExpenseUncheckedCreateWithoutVaultInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutVaultInput>
    createMany?: ExpenseCreateManyVaultInputEnvelope
    connect?: Enumerable<ExpenseWhereUniqueInput>
  }

  export type TransferCreateNestedManyWithoutSourceVaultInput = {
    create?: XOR<Enumerable<TransferCreateWithoutSourceVaultInput>, Enumerable<TransferUncheckedCreateWithoutSourceVaultInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutSourceVaultInput>
    createMany?: TransferCreateManySourceVaultInputEnvelope
    connect?: Enumerable<TransferWhereUniqueInput>
  }

  export type TransferCreateNestedManyWithoutTargetVaultInput = {
    create?: XOR<Enumerable<TransferCreateWithoutTargetVaultInput>, Enumerable<TransferUncheckedCreateWithoutTargetVaultInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutTargetVaultInput>
    createMany?: TransferCreateManyTargetVaultInputEnvelope
    connect?: Enumerable<TransferWhereUniqueInput>
  }

  export type DonationCreateNestedManyWithoutTargetVaultInput = {
    create?: XOR<Enumerable<DonationCreateWithoutTargetVaultInput>, Enumerable<DonationUncheckedCreateWithoutTargetVaultInput>>
    connectOrCreate?: Enumerable<DonationCreateOrConnectWithoutTargetVaultInput>
    createMany?: DonationCreateManyTargetVaultInputEnvelope
    connect?: Enumerable<DonationWhereUniqueInput>
  }

  export type WithdrawalCreateNestedManyWithoutSourceVaultInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutSourceVaultInput>, Enumerable<WithdrawalUncheckedCreateWithoutSourceVaultInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutSourceVaultInput>
    createMany?: WithdrawalCreateManySourceVaultInputEnvelope
    connect?: Enumerable<WithdrawalWhereUniqueInput>
  }

  export type RecurringDonationCreateNestedManyWithoutSourceVaultInput = {
    create?: XOR<Enumerable<RecurringDonationCreateWithoutSourceVaultInput>, Enumerable<RecurringDonationUncheckedCreateWithoutSourceVaultInput>>
    connectOrCreate?: Enumerable<RecurringDonationCreateOrConnectWithoutSourceVaultInput>
    createMany?: RecurringDonationCreateManySourceVaultInputEnvelope
    connect?: Enumerable<RecurringDonationWhereUniqueInput>
  }

  export type ExpenseUncheckedCreateNestedManyWithoutVaultInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutVaultInput>, Enumerable<ExpenseUncheckedCreateWithoutVaultInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutVaultInput>
    createMany?: ExpenseCreateManyVaultInputEnvelope
    connect?: Enumerable<ExpenseWhereUniqueInput>
  }

  export type TransferUncheckedCreateNestedManyWithoutSourceVaultInput = {
    create?: XOR<Enumerable<TransferCreateWithoutSourceVaultInput>, Enumerable<TransferUncheckedCreateWithoutSourceVaultInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutSourceVaultInput>
    createMany?: TransferCreateManySourceVaultInputEnvelope
    connect?: Enumerable<TransferWhereUniqueInput>
  }

  export type TransferUncheckedCreateNestedManyWithoutTargetVaultInput = {
    create?: XOR<Enumerable<TransferCreateWithoutTargetVaultInput>, Enumerable<TransferUncheckedCreateWithoutTargetVaultInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutTargetVaultInput>
    createMany?: TransferCreateManyTargetVaultInputEnvelope
    connect?: Enumerable<TransferWhereUniqueInput>
  }

  export type DonationUncheckedCreateNestedManyWithoutTargetVaultInput = {
    create?: XOR<Enumerable<DonationCreateWithoutTargetVaultInput>, Enumerable<DonationUncheckedCreateWithoutTargetVaultInput>>
    connectOrCreate?: Enumerable<DonationCreateOrConnectWithoutTargetVaultInput>
    createMany?: DonationCreateManyTargetVaultInputEnvelope
    connect?: Enumerable<DonationWhereUniqueInput>
  }

  export type WithdrawalUncheckedCreateNestedManyWithoutSourceVaultInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutSourceVaultInput>, Enumerable<WithdrawalUncheckedCreateWithoutSourceVaultInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutSourceVaultInput>
    createMany?: WithdrawalCreateManySourceVaultInputEnvelope
    connect?: Enumerable<WithdrawalWhereUniqueInput>
  }

  export type RecurringDonationUncheckedCreateNestedManyWithoutSourceVaultInput = {
    create?: XOR<Enumerable<RecurringDonationCreateWithoutSourceVaultInput>, Enumerable<RecurringDonationUncheckedCreateWithoutSourceVaultInput>>
    connectOrCreate?: Enumerable<RecurringDonationCreateOrConnectWithoutSourceVaultInput>
    createMany?: RecurringDonationCreateManySourceVaultInputEnvelope
    connect?: Enumerable<RecurringDonationWhereUniqueInput>
  }

  export type CampaignUpdateOneRequiredWithoutVaultsInput = {
    create?: XOR<CampaignCreateWithoutVaultsInput, CampaignUncheckedCreateWithoutVaultsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutVaultsInput
    upsert?: CampaignUpsertWithoutVaultsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutVaultsInput, CampaignUncheckedUpdateWithoutVaultsInput>
  }

  export type ExpenseUpdateManyWithoutVaultInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutVaultInput>, Enumerable<ExpenseUncheckedCreateWithoutVaultInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutVaultInput>
    upsert?: Enumerable<ExpenseUpsertWithWhereUniqueWithoutVaultInput>
    createMany?: ExpenseCreateManyVaultInputEnvelope
    set?: Enumerable<ExpenseWhereUniqueInput>
    disconnect?: Enumerable<ExpenseWhereUniqueInput>
    delete?: Enumerable<ExpenseWhereUniqueInput>
    connect?: Enumerable<ExpenseWhereUniqueInput>
    update?: Enumerable<ExpenseUpdateWithWhereUniqueWithoutVaultInput>
    updateMany?: Enumerable<ExpenseUpdateManyWithWhereWithoutVaultInput>
    deleteMany?: Enumerable<ExpenseScalarWhereInput>
  }

  export type TransferUpdateManyWithoutSourceVaultInput = {
    create?: XOR<Enumerable<TransferCreateWithoutSourceVaultInput>, Enumerable<TransferUncheckedCreateWithoutSourceVaultInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutSourceVaultInput>
    upsert?: Enumerable<TransferUpsertWithWhereUniqueWithoutSourceVaultInput>
    createMany?: TransferCreateManySourceVaultInputEnvelope
    set?: Enumerable<TransferWhereUniqueInput>
    disconnect?: Enumerable<TransferWhereUniqueInput>
    delete?: Enumerable<TransferWhereUniqueInput>
    connect?: Enumerable<TransferWhereUniqueInput>
    update?: Enumerable<TransferUpdateWithWhereUniqueWithoutSourceVaultInput>
    updateMany?: Enumerable<TransferUpdateManyWithWhereWithoutSourceVaultInput>
    deleteMany?: Enumerable<TransferScalarWhereInput>
  }

  export type TransferUpdateManyWithoutTargetVaultInput = {
    create?: XOR<Enumerable<TransferCreateWithoutTargetVaultInput>, Enumerable<TransferUncheckedCreateWithoutTargetVaultInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutTargetVaultInput>
    upsert?: Enumerable<TransferUpsertWithWhereUniqueWithoutTargetVaultInput>
    createMany?: TransferCreateManyTargetVaultInputEnvelope
    set?: Enumerable<TransferWhereUniqueInput>
    disconnect?: Enumerable<TransferWhereUniqueInput>
    delete?: Enumerable<TransferWhereUniqueInput>
    connect?: Enumerable<TransferWhereUniqueInput>
    update?: Enumerable<TransferUpdateWithWhereUniqueWithoutTargetVaultInput>
    updateMany?: Enumerable<TransferUpdateManyWithWhereWithoutTargetVaultInput>
    deleteMany?: Enumerable<TransferScalarWhereInput>
  }

  export type DonationUpdateManyWithoutTargetVaultInput = {
    create?: XOR<Enumerable<DonationCreateWithoutTargetVaultInput>, Enumerable<DonationUncheckedCreateWithoutTargetVaultInput>>
    connectOrCreate?: Enumerable<DonationCreateOrConnectWithoutTargetVaultInput>
    upsert?: Enumerable<DonationUpsertWithWhereUniqueWithoutTargetVaultInput>
    createMany?: DonationCreateManyTargetVaultInputEnvelope
    set?: Enumerable<DonationWhereUniqueInput>
    disconnect?: Enumerable<DonationWhereUniqueInput>
    delete?: Enumerable<DonationWhereUniqueInput>
    connect?: Enumerable<DonationWhereUniqueInput>
    update?: Enumerable<DonationUpdateWithWhereUniqueWithoutTargetVaultInput>
    updateMany?: Enumerable<DonationUpdateManyWithWhereWithoutTargetVaultInput>
    deleteMany?: Enumerable<DonationScalarWhereInput>
  }

  export type WithdrawalUpdateManyWithoutSourceVaultInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutSourceVaultInput>, Enumerable<WithdrawalUncheckedCreateWithoutSourceVaultInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutSourceVaultInput>
    upsert?: Enumerable<WithdrawalUpsertWithWhereUniqueWithoutSourceVaultInput>
    createMany?: WithdrawalCreateManySourceVaultInputEnvelope
    set?: Enumerable<WithdrawalWhereUniqueInput>
    disconnect?: Enumerable<WithdrawalWhereUniqueInput>
    delete?: Enumerable<WithdrawalWhereUniqueInput>
    connect?: Enumerable<WithdrawalWhereUniqueInput>
    update?: Enumerable<WithdrawalUpdateWithWhereUniqueWithoutSourceVaultInput>
    updateMany?: Enumerable<WithdrawalUpdateManyWithWhereWithoutSourceVaultInput>
    deleteMany?: Enumerable<WithdrawalScalarWhereInput>
  }

  export type RecurringDonationUpdateManyWithoutSourceVaultInput = {
    create?: XOR<Enumerable<RecurringDonationCreateWithoutSourceVaultInput>, Enumerable<RecurringDonationUncheckedCreateWithoutSourceVaultInput>>
    connectOrCreate?: Enumerable<RecurringDonationCreateOrConnectWithoutSourceVaultInput>
    upsert?: Enumerable<RecurringDonationUpsertWithWhereUniqueWithoutSourceVaultInput>
    createMany?: RecurringDonationCreateManySourceVaultInputEnvelope
    set?: Enumerable<RecurringDonationWhereUniqueInput>
    disconnect?: Enumerable<RecurringDonationWhereUniqueInput>
    delete?: Enumerable<RecurringDonationWhereUniqueInput>
    connect?: Enumerable<RecurringDonationWhereUniqueInput>
    update?: Enumerable<RecurringDonationUpdateWithWhereUniqueWithoutSourceVaultInput>
    updateMany?: Enumerable<RecurringDonationUpdateManyWithWhereWithoutSourceVaultInput>
    deleteMany?: Enumerable<RecurringDonationScalarWhereInput>
  }

  export type ExpenseUncheckedUpdateManyWithoutVaultInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutVaultInput>, Enumerable<ExpenseUncheckedCreateWithoutVaultInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutVaultInput>
    upsert?: Enumerable<ExpenseUpsertWithWhereUniqueWithoutVaultInput>
    createMany?: ExpenseCreateManyVaultInputEnvelope
    set?: Enumerable<ExpenseWhereUniqueInput>
    disconnect?: Enumerable<ExpenseWhereUniqueInput>
    delete?: Enumerable<ExpenseWhereUniqueInput>
    connect?: Enumerable<ExpenseWhereUniqueInput>
    update?: Enumerable<ExpenseUpdateWithWhereUniqueWithoutVaultInput>
    updateMany?: Enumerable<ExpenseUpdateManyWithWhereWithoutVaultInput>
    deleteMany?: Enumerable<ExpenseScalarWhereInput>
  }

  export type TransferUncheckedUpdateManyWithoutSourceVaultInput = {
    create?: XOR<Enumerable<TransferCreateWithoutSourceVaultInput>, Enumerable<TransferUncheckedCreateWithoutSourceVaultInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutSourceVaultInput>
    upsert?: Enumerable<TransferUpsertWithWhereUniqueWithoutSourceVaultInput>
    createMany?: TransferCreateManySourceVaultInputEnvelope
    set?: Enumerable<TransferWhereUniqueInput>
    disconnect?: Enumerable<TransferWhereUniqueInput>
    delete?: Enumerable<TransferWhereUniqueInput>
    connect?: Enumerable<TransferWhereUniqueInput>
    update?: Enumerable<TransferUpdateWithWhereUniqueWithoutSourceVaultInput>
    updateMany?: Enumerable<TransferUpdateManyWithWhereWithoutSourceVaultInput>
    deleteMany?: Enumerable<TransferScalarWhereInput>
  }

  export type TransferUncheckedUpdateManyWithoutTargetVaultInput = {
    create?: XOR<Enumerable<TransferCreateWithoutTargetVaultInput>, Enumerable<TransferUncheckedCreateWithoutTargetVaultInput>>
    connectOrCreate?: Enumerable<TransferCreateOrConnectWithoutTargetVaultInput>
    upsert?: Enumerable<TransferUpsertWithWhereUniqueWithoutTargetVaultInput>
    createMany?: TransferCreateManyTargetVaultInputEnvelope
    set?: Enumerable<TransferWhereUniqueInput>
    disconnect?: Enumerable<TransferWhereUniqueInput>
    delete?: Enumerable<TransferWhereUniqueInput>
    connect?: Enumerable<TransferWhereUniqueInput>
    update?: Enumerable<TransferUpdateWithWhereUniqueWithoutTargetVaultInput>
    updateMany?: Enumerable<TransferUpdateManyWithWhereWithoutTargetVaultInput>
    deleteMany?: Enumerable<TransferScalarWhereInput>
  }

  export type DonationUncheckedUpdateManyWithoutTargetVaultInput = {
    create?: XOR<Enumerable<DonationCreateWithoutTargetVaultInput>, Enumerable<DonationUncheckedCreateWithoutTargetVaultInput>>
    connectOrCreate?: Enumerable<DonationCreateOrConnectWithoutTargetVaultInput>
    upsert?: Enumerable<DonationUpsertWithWhereUniqueWithoutTargetVaultInput>
    createMany?: DonationCreateManyTargetVaultInputEnvelope
    set?: Enumerable<DonationWhereUniqueInput>
    disconnect?: Enumerable<DonationWhereUniqueInput>
    delete?: Enumerable<DonationWhereUniqueInput>
    connect?: Enumerable<DonationWhereUniqueInput>
    update?: Enumerable<DonationUpdateWithWhereUniqueWithoutTargetVaultInput>
    updateMany?: Enumerable<DonationUpdateManyWithWhereWithoutTargetVaultInput>
    deleteMany?: Enumerable<DonationScalarWhereInput>
  }

  export type WithdrawalUncheckedUpdateManyWithoutSourceVaultInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutSourceVaultInput>, Enumerable<WithdrawalUncheckedCreateWithoutSourceVaultInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutSourceVaultInput>
    upsert?: Enumerable<WithdrawalUpsertWithWhereUniqueWithoutSourceVaultInput>
    createMany?: WithdrawalCreateManySourceVaultInputEnvelope
    set?: Enumerable<WithdrawalWhereUniqueInput>
    disconnect?: Enumerable<WithdrawalWhereUniqueInput>
    delete?: Enumerable<WithdrawalWhereUniqueInput>
    connect?: Enumerable<WithdrawalWhereUniqueInput>
    update?: Enumerable<WithdrawalUpdateWithWhereUniqueWithoutSourceVaultInput>
    updateMany?: Enumerable<WithdrawalUpdateManyWithWhereWithoutSourceVaultInput>
    deleteMany?: Enumerable<WithdrawalScalarWhereInput>
  }

  export type RecurringDonationUncheckedUpdateManyWithoutSourceVaultInput = {
    create?: XOR<Enumerable<RecurringDonationCreateWithoutSourceVaultInput>, Enumerable<RecurringDonationUncheckedCreateWithoutSourceVaultInput>>
    connectOrCreate?: Enumerable<RecurringDonationCreateOrConnectWithoutSourceVaultInput>
    upsert?: Enumerable<RecurringDonationUpsertWithWhereUniqueWithoutSourceVaultInput>
    createMany?: RecurringDonationCreateManySourceVaultInputEnvelope
    set?: Enumerable<RecurringDonationWhereUniqueInput>
    disconnect?: Enumerable<RecurringDonationWhereUniqueInput>
    delete?: Enumerable<RecurringDonationWhereUniqueInput>
    connect?: Enumerable<RecurringDonationWhereUniqueInput>
    update?: Enumerable<RecurringDonationUpdateWithWhereUniqueWithoutSourceVaultInput>
    updateMany?: Enumerable<RecurringDonationUpdateManyWithWhereWithoutSourceVaultInput>
    deleteMany?: Enumerable<RecurringDonationScalarWhereInput>
  }

  export type VaultCreateNestedOneWithoutDonationsInput = {
    create?: XOR<VaultCreateWithoutDonationsInput, VaultUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: VaultCreateOrConnectWithoutDonationsInput
    connect?: VaultWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutDonationInput = {
    create?: XOR<PersonCreateWithoutDonationInput, PersonUncheckedCreateWithoutDonationInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDonationInput
    connect?: PersonWhereUniqueInput
  }

  export type EnumDonationTypeFieldUpdateOperationsInput = {
    set?: DonationType
  }

  export type EnumDonationStatusFieldUpdateOperationsInput = {
    set?: DonationStatus
  }

  export type EnumPaymentProviderFieldUpdateOperationsInput = {
    set?: PaymentProvider
  }

  export type VaultUpdateOneRequiredWithoutDonationsInput = {
    create?: XOR<VaultCreateWithoutDonationsInput, VaultUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: VaultCreateOrConnectWithoutDonationsInput
    upsert?: VaultUpsertWithoutDonationsInput
    connect?: VaultWhereUniqueInput
    update?: XOR<VaultUpdateWithoutDonationsInput, VaultUncheckedUpdateWithoutDonationsInput>
  }

  export type PersonUpdateOneWithoutDonationInput = {
    create?: XOR<PersonCreateWithoutDonationInput, PersonUncheckedCreateWithoutDonationInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDonationInput
    upsert?: PersonUpsertWithoutDonationInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutDonationInput, PersonUncheckedUpdateWithoutDonationInput>
  }

  export type VaultCreateNestedOneWithoutRecurringDonationsInput = {
    create?: XOR<VaultCreateWithoutRecurringDonationsInput, VaultUncheckedCreateWithoutRecurringDonationsInput>
    connectOrCreate?: VaultCreateOrConnectWithoutRecurringDonationsInput
    connect?: VaultWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutRecurringDonationsInput = {
    create?: XOR<PersonCreateWithoutRecurringDonationsInput, PersonUncheckedCreateWithoutRecurringDonationsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutRecurringDonationsInput
    connect?: PersonWhereUniqueInput
  }

  export type EnumRecurringDonationStatusFieldUpdateOperationsInput = {
    set?: RecurringDonationStatus
  }

  export type VaultUpdateOneRequiredWithoutRecurringDonationsInput = {
    create?: XOR<VaultCreateWithoutRecurringDonationsInput, VaultUncheckedCreateWithoutRecurringDonationsInput>
    connectOrCreate?: VaultCreateOrConnectWithoutRecurringDonationsInput
    upsert?: VaultUpsertWithoutRecurringDonationsInput
    connect?: VaultWhereUniqueInput
    update?: XOR<VaultUpdateWithoutRecurringDonationsInput, VaultUncheckedUpdateWithoutRecurringDonationsInput>
  }

  export type PersonUpdateOneRequiredWithoutRecurringDonationsInput = {
    create?: XOR<PersonCreateWithoutRecurringDonationsInput, PersonUncheckedCreateWithoutRecurringDonationsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutRecurringDonationsInput
    upsert?: PersonUpsertWithoutRecurringDonationsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutRecurringDonationsInput, PersonUncheckedUpdateWithoutRecurringDonationsInput>
  }

  export type PersonCreateNestedOneWithoutTransfersInput = {
    create?: XOR<PersonCreateWithoutTransfersInput, PersonUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: PersonCreateOrConnectWithoutTransfersInput
    connect?: PersonWhereUniqueInput
  }

  export type VaultCreateNestedOneWithoutSourceTransfersInput = {
    create?: XOR<VaultCreateWithoutSourceTransfersInput, VaultUncheckedCreateWithoutSourceTransfersInput>
    connectOrCreate?: VaultCreateOrConnectWithoutSourceTransfersInput
    connect?: VaultWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutOutgoingTransfersInput = {
    create?: XOR<CampaignCreateWithoutOutgoingTransfersInput, CampaignUncheckedCreateWithoutOutgoingTransfersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutOutgoingTransfersInput
    connect?: CampaignWhereUniqueInput
  }

  export type VaultCreateNestedOneWithoutTargetTransfersInput = {
    create?: XOR<VaultCreateWithoutTargetTransfersInput, VaultUncheckedCreateWithoutTargetTransfersInput>
    connectOrCreate?: VaultCreateOrConnectWithoutTargetTransfersInput
    connect?: VaultWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutIncomingTransfersInput = {
    create?: XOR<CampaignCreateWithoutIncomingTransfersInput, CampaignUncheckedCreateWithoutIncomingTransfersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutIncomingTransfersInput
    connect?: CampaignWhereUniqueInput
  }

  export type EnumTransferStatusFieldUpdateOperationsInput = {
    set?: TransferStatus
  }

  export type PersonUpdateOneWithoutTransfersInput = {
    create?: XOR<PersonCreateWithoutTransfersInput, PersonUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: PersonCreateOrConnectWithoutTransfersInput
    upsert?: PersonUpsertWithoutTransfersInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutTransfersInput, PersonUncheckedUpdateWithoutTransfersInput>
  }

  export type VaultUpdateOneRequiredWithoutSourceTransfersInput = {
    create?: XOR<VaultCreateWithoutSourceTransfersInput, VaultUncheckedCreateWithoutSourceTransfersInput>
    connectOrCreate?: VaultCreateOrConnectWithoutSourceTransfersInput
    upsert?: VaultUpsertWithoutSourceTransfersInput
    connect?: VaultWhereUniqueInput
    update?: XOR<VaultUpdateWithoutSourceTransfersInput, VaultUncheckedUpdateWithoutSourceTransfersInput>
  }

  export type CampaignUpdateOneRequiredWithoutOutgoingTransfersInput = {
    create?: XOR<CampaignCreateWithoutOutgoingTransfersInput, CampaignUncheckedCreateWithoutOutgoingTransfersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutOutgoingTransfersInput
    upsert?: CampaignUpsertWithoutOutgoingTransfersInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutOutgoingTransfersInput, CampaignUncheckedUpdateWithoutOutgoingTransfersInput>
  }

  export type VaultUpdateOneRequiredWithoutTargetTransfersInput = {
    create?: XOR<VaultCreateWithoutTargetTransfersInput, VaultUncheckedCreateWithoutTargetTransfersInput>
    connectOrCreate?: VaultCreateOrConnectWithoutTargetTransfersInput
    upsert?: VaultUpsertWithoutTargetTransfersInput
    connect?: VaultWhereUniqueInput
    update?: XOR<VaultUpdateWithoutTargetTransfersInput, VaultUncheckedUpdateWithoutTargetTransfersInput>
  }

  export type CampaignUpdateOneRequiredWithoutIncomingTransfersInput = {
    create?: XOR<CampaignCreateWithoutIncomingTransfersInput, CampaignUncheckedCreateWithoutIncomingTransfersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutIncomingTransfersInput
    upsert?: CampaignUpsertWithoutIncomingTransfersInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutIncomingTransfersInput, CampaignUncheckedUpdateWithoutIncomingTransfersInput>
  }

  export type PersonCreateNestedOneWithoutWithdrawalsInput = {
    create?: XOR<PersonCreateWithoutWithdrawalsInput, PersonUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutWithdrawalsInput
    connect?: PersonWhereUniqueInput
  }

  export type VaultCreateNestedOneWithoutWithdrawsInput = {
    create?: XOR<VaultCreateWithoutWithdrawsInput, VaultUncheckedCreateWithoutWithdrawsInput>
    connectOrCreate?: VaultCreateOrConnectWithoutWithdrawsInput
    connect?: VaultWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutWithdrawalsInput = {
    create?: XOR<CampaignCreateWithoutWithdrawalsInput, CampaignUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutWithdrawalsInput
    connect?: CampaignWhereUniqueInput
  }

  export type BankAccountCreateNestedOneWithoutWithdrawsInput = {
    create?: XOR<BankAccountCreateWithoutWithdrawsInput, BankAccountUncheckedCreateWithoutWithdrawsInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutWithdrawsInput
    connect?: BankAccountWhereUniqueInput
  }

  export type EnumWithdrawStatusFieldUpdateOperationsInput = {
    set?: WithdrawStatus
  }

  export type PersonUpdateOneWithoutWithdrawalsInput = {
    create?: XOR<PersonCreateWithoutWithdrawalsInput, PersonUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutWithdrawalsInput
    upsert?: PersonUpsertWithoutWithdrawalsInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutWithdrawalsInput, PersonUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type VaultUpdateOneRequiredWithoutWithdrawsInput = {
    create?: XOR<VaultCreateWithoutWithdrawsInput, VaultUncheckedCreateWithoutWithdrawsInput>
    connectOrCreate?: VaultCreateOrConnectWithoutWithdrawsInput
    upsert?: VaultUpsertWithoutWithdrawsInput
    connect?: VaultWhereUniqueInput
    update?: XOR<VaultUpdateWithoutWithdrawsInput, VaultUncheckedUpdateWithoutWithdrawsInput>
  }

  export type CampaignUpdateOneRequiredWithoutWithdrawalsInput = {
    create?: XOR<CampaignCreateWithoutWithdrawalsInput, CampaignUncheckedCreateWithoutWithdrawalsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutWithdrawalsInput
    upsert?: CampaignUpsertWithoutWithdrawalsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutWithdrawalsInput, CampaignUncheckedUpdateWithoutWithdrawalsInput>
  }

  export type BankAccountUpdateOneRequiredWithoutWithdrawsInput = {
    create?: XOR<BankAccountCreateWithoutWithdrawsInput, BankAccountUncheckedCreateWithoutWithdrawsInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutWithdrawsInput
    upsert?: BankAccountUpsertWithoutWithdrawsInput
    connect?: BankAccountWhereUniqueInput
    update?: XOR<BankAccountUpdateWithoutWithdrawsInput, BankAccountUncheckedUpdateWithoutWithdrawsInput>
  }

  export type WithdrawalCreateNestedManyWithoutBankAccountInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutBankAccountInput>, Enumerable<WithdrawalUncheckedCreateWithoutBankAccountInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutBankAccountInput>
    createMany?: WithdrawalCreateManyBankAccountInputEnvelope
    connect?: Enumerable<WithdrawalWhereUniqueInput>
  }

  export type WithdrawalUncheckedCreateNestedManyWithoutBankAccountInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutBankAccountInput>, Enumerable<WithdrawalUncheckedCreateWithoutBankAccountInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutBankAccountInput>
    createMany?: WithdrawalCreateManyBankAccountInputEnvelope
    connect?: Enumerable<WithdrawalWhereUniqueInput>
  }

  export type EnumBankAccountStatusFieldUpdateOperationsInput = {
    set?: BankAccountStatus
  }

  export type EnumAccountHolderTypeFieldUpdateOperationsInput = {
    set?: AccountHolderType
  }

  export type WithdrawalUpdateManyWithoutBankAccountInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutBankAccountInput>, Enumerable<WithdrawalUncheckedCreateWithoutBankAccountInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutBankAccountInput>
    upsert?: Enumerable<WithdrawalUpsertWithWhereUniqueWithoutBankAccountInput>
    createMany?: WithdrawalCreateManyBankAccountInputEnvelope
    set?: Enumerable<WithdrawalWhereUniqueInput>
    disconnect?: Enumerable<WithdrawalWhereUniqueInput>
    delete?: Enumerable<WithdrawalWhereUniqueInput>
    connect?: Enumerable<WithdrawalWhereUniqueInput>
    update?: Enumerable<WithdrawalUpdateWithWhereUniqueWithoutBankAccountInput>
    updateMany?: Enumerable<WithdrawalUpdateManyWithWhereWithoutBankAccountInput>
    deleteMany?: Enumerable<WithdrawalScalarWhereInput>
  }

  export type WithdrawalUncheckedUpdateManyWithoutBankAccountInput = {
    create?: XOR<Enumerable<WithdrawalCreateWithoutBankAccountInput>, Enumerable<WithdrawalUncheckedCreateWithoutBankAccountInput>>
    connectOrCreate?: Enumerable<WithdrawalCreateOrConnectWithoutBankAccountInput>
    upsert?: Enumerable<WithdrawalUpsertWithWhereUniqueWithoutBankAccountInput>
    createMany?: WithdrawalCreateManyBankAccountInputEnvelope
    set?: Enumerable<WithdrawalWhereUniqueInput>
    disconnect?: Enumerable<WithdrawalWhereUniqueInput>
    delete?: Enumerable<WithdrawalWhereUniqueInput>
    connect?: Enumerable<WithdrawalWhereUniqueInput>
    update?: Enumerable<WithdrawalUpdateWithWhereUniqueWithoutBankAccountInput>
    updateMany?: Enumerable<WithdrawalUpdateManyWithWhereWithoutBankAccountInput>
    deleteMany?: Enumerable<WithdrawalScalarWhereInput>
  }

  export type VaultCreateNestedOneWithoutExpensesInput = {
    create?: XOR<VaultCreateWithoutExpensesInput, VaultUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: VaultCreateOrConnectWithoutExpensesInput
    connect?: VaultWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutExpensesInput = {
    create?: XOR<PersonCreateWithoutExpensesInput, PersonUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutExpensesInput
    connect?: PersonWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutExpensesInput = {
    create?: XOR<DocumentCreateWithoutExpensesInput, DocumentUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutExpensesInput
    connect?: DocumentWhereUniqueInput
  }

  export type EnumExpenseTypeFieldUpdateOperationsInput = {
    set?: ExpenseType
  }

  export type VaultUpdateOneRequiredWithoutExpensesInput = {
    create?: XOR<VaultCreateWithoutExpensesInput, VaultUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: VaultCreateOrConnectWithoutExpensesInput
    upsert?: VaultUpsertWithoutExpensesInput
    connect?: VaultWhereUniqueInput
    update?: XOR<VaultUpdateWithoutExpensesInput, VaultUncheckedUpdateWithoutExpensesInput>
  }

  export type PersonUpdateOneWithoutExpensesInput = {
    create?: XOR<PersonCreateWithoutExpensesInput, PersonUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutExpensesInput
    upsert?: PersonUpsertWithoutExpensesInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutExpensesInput, PersonUncheckedUpdateWithoutExpensesInput>
  }

  export type DocumentUpdateOneWithoutExpensesInput = {
    create?: XOR<DocumentCreateWithoutExpensesInput, DocumentUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutExpensesInput
    upsert?: DocumentUpsertWithoutExpensesInput
    disconnect?: boolean
    delete?: boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutExpensesInput, DocumentUncheckedUpdateWithoutExpensesInput>
  }

  export type PersonCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<PersonCreateWithoutDocumentsInput, PersonUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDocumentsInput
    connect?: PersonWhereUniqueInput
  }

  export type ExpenseCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutDocumentInput>, Enumerable<ExpenseUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutDocumentInput>
    createMany?: ExpenseCreateManyDocumentInputEnvelope
    connect?: Enumerable<ExpenseWhereUniqueInput>
  }

  export type ExpenseUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutDocumentInput>, Enumerable<ExpenseUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutDocumentInput>
    createMany?: ExpenseCreateManyDocumentInputEnvelope
    connect?: Enumerable<ExpenseWhereUniqueInput>
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: DocumentType
  }

  export type PersonUpdateOneRequiredWithoutDocumentsInput = {
    create?: XOR<PersonCreateWithoutDocumentsInput, PersonUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PersonCreateOrConnectWithoutDocumentsInput
    upsert?: PersonUpsertWithoutDocumentsInput
    connect?: PersonWhereUniqueInput
    update?: XOR<PersonUpdateWithoutDocumentsInput, PersonUncheckedUpdateWithoutDocumentsInput>
  }

  export type ExpenseUpdateManyWithoutDocumentInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutDocumentInput>, Enumerable<ExpenseUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<ExpenseUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: ExpenseCreateManyDocumentInputEnvelope
    set?: Enumerable<ExpenseWhereUniqueInput>
    disconnect?: Enumerable<ExpenseWhereUniqueInput>
    delete?: Enumerable<ExpenseWhereUniqueInput>
    connect?: Enumerable<ExpenseWhereUniqueInput>
    update?: Enumerable<ExpenseUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<ExpenseUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<ExpenseScalarWhereInput>
  }

  export type ExpenseUncheckedUpdateManyWithoutDocumentInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutDocumentInput>, Enumerable<ExpenseUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<ExpenseUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: ExpenseCreateManyDocumentInputEnvelope
    set?: Enumerable<ExpenseWhereUniqueInput>
    disconnect?: Enumerable<ExpenseWhereUniqueInput>
    delete?: Enumerable<ExpenseWhereUniqueInput>
    connect?: Enumerable<ExpenseWhereUniqueInput>
    update?: Enumerable<ExpenseUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<ExpenseUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<ExpenseScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedEnumBeneficiaryTypeFilter = {
    equals?: BeneficiaryType
    in?: Enumerable<BeneficiaryType>
    notIn?: Enumerable<BeneficiaryType>
    not?: NestedEnumBeneficiaryTypeFilter | BeneficiaryType
  }

  export type NestedEnumPersonRelationFilter = {
    equals?: PersonRelation
    in?: Enumerable<PersonRelation>
    notIn?: Enumerable<PersonRelation>
    not?: NestedEnumPersonRelationFilter | PersonRelation
  }

  export type NestedEnumBeneficiaryTypeWithAggregatesFilter = {
    equals?: BeneficiaryType
    in?: Enumerable<BeneficiaryType>
    notIn?: Enumerable<BeneficiaryType>
    not?: NestedEnumBeneficiaryTypeWithAggregatesFilter | BeneficiaryType
    _count?: NestedIntFilter
    _min?: NestedEnumBeneficiaryTypeFilter
    _max?: NestedEnumBeneficiaryTypeFilter
  }
  export type NestedJsonNullableFilter =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type NestedEnumPersonRelationWithAggregatesFilter = {
    equals?: PersonRelation
    in?: Enumerable<PersonRelation>
    notIn?: Enumerable<PersonRelation>
    not?: NestedEnumPersonRelationWithAggregatesFilter | PersonRelation
    _count?: NestedIntFilter
    _min?: NestedEnumPersonRelationFilter
    _max?: NestedEnumPersonRelationFilter
  }

  export type NestedEnumCampaignStateFilter = {
    equals?: CampaignState
    in?: Enumerable<CampaignState>
    notIn?: Enumerable<CampaignState>
    not?: NestedEnumCampaignStateFilter | CampaignState
  }

  export type NestedEnumCurrencyFilter = {
    equals?: Currency
    in?: Enumerable<Currency>
    notIn?: Enumerable<Currency>
    not?: NestedEnumCurrencyFilter | Currency
  }

  export type NestedEnumCampaignStateWithAggregatesFilter = {
    equals?: CampaignState
    in?: Enumerable<CampaignState>
    notIn?: Enumerable<CampaignState>
    not?: NestedEnumCampaignStateWithAggregatesFilter | CampaignState
    _count?: NestedIntFilter
    _min?: NestedEnumCampaignStateFilter
    _max?: NestedEnumCampaignStateFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumCurrencyWithAggregatesFilter = {
    equals?: Currency
    in?: Enumerable<Currency>
    notIn?: Enumerable<Currency>
    not?: NestedEnumCurrencyWithAggregatesFilter | Currency
    _count?: NestedIntFilter
    _min?: NestedEnumCurrencyFilter
    _max?: NestedEnumCurrencyFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumDonationTypeFilter = {
    equals?: DonationType
    in?: Enumerable<DonationType>
    notIn?: Enumerable<DonationType>
    not?: NestedEnumDonationTypeFilter | DonationType
  }

  export type NestedEnumDonationStatusFilter = {
    equals?: DonationStatus
    in?: Enumerable<DonationStatus>
    notIn?: Enumerable<DonationStatus>
    not?: NestedEnumDonationStatusFilter | DonationStatus
  }

  export type NestedEnumPaymentProviderFilter = {
    equals?: PaymentProvider
    in?: Enumerable<PaymentProvider>
    notIn?: Enumerable<PaymentProvider>
    not?: NestedEnumPaymentProviderFilter | PaymentProvider
  }

  export type NestedEnumDonationTypeWithAggregatesFilter = {
    equals?: DonationType
    in?: Enumerable<DonationType>
    notIn?: Enumerable<DonationType>
    not?: NestedEnumDonationTypeWithAggregatesFilter | DonationType
    _count?: NestedIntFilter
    _min?: NestedEnumDonationTypeFilter
    _max?: NestedEnumDonationTypeFilter
  }

  export type NestedEnumDonationStatusWithAggregatesFilter = {
    equals?: DonationStatus
    in?: Enumerable<DonationStatus>
    notIn?: Enumerable<DonationStatus>
    not?: NestedEnumDonationStatusWithAggregatesFilter | DonationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumDonationStatusFilter
    _max?: NestedEnumDonationStatusFilter
  }

  export type NestedEnumPaymentProviderWithAggregatesFilter = {
    equals?: PaymentProvider
    in?: Enumerable<PaymentProvider>
    notIn?: Enumerable<PaymentProvider>
    not?: NestedEnumPaymentProviderWithAggregatesFilter | PaymentProvider
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentProviderFilter
    _max?: NestedEnumPaymentProviderFilter
  }

  export type NestedEnumRecurringDonationStatusFilter = {
    equals?: RecurringDonationStatus
    in?: Enumerable<RecurringDonationStatus>
    notIn?: Enumerable<RecurringDonationStatus>
    not?: NestedEnumRecurringDonationStatusFilter | RecurringDonationStatus
  }

  export type NestedEnumRecurringDonationStatusWithAggregatesFilter = {
    equals?: RecurringDonationStatus
    in?: Enumerable<RecurringDonationStatus>
    notIn?: Enumerable<RecurringDonationStatus>
    not?: NestedEnumRecurringDonationStatusWithAggregatesFilter | RecurringDonationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumRecurringDonationStatusFilter
    _max?: NestedEnumRecurringDonationStatusFilter
  }

  export type NestedEnumTransferStatusFilter = {
    equals?: TransferStatus
    in?: Enumerable<TransferStatus>
    notIn?: Enumerable<TransferStatus>
    not?: NestedEnumTransferStatusFilter | TransferStatus
  }

  export type NestedEnumTransferStatusWithAggregatesFilter = {
    equals?: TransferStatus
    in?: Enumerable<TransferStatus>
    notIn?: Enumerable<TransferStatus>
    not?: NestedEnumTransferStatusWithAggregatesFilter | TransferStatus
    _count?: NestedIntFilter
    _min?: NestedEnumTransferStatusFilter
    _max?: NestedEnumTransferStatusFilter
  }

  export type NestedEnumWithdrawStatusFilter = {
    equals?: WithdrawStatus
    in?: Enumerable<WithdrawStatus>
    notIn?: Enumerable<WithdrawStatus>
    not?: NestedEnumWithdrawStatusFilter | WithdrawStatus
  }

  export type NestedEnumWithdrawStatusWithAggregatesFilter = {
    equals?: WithdrawStatus
    in?: Enumerable<WithdrawStatus>
    notIn?: Enumerable<WithdrawStatus>
    not?: NestedEnumWithdrawStatusWithAggregatesFilter | WithdrawStatus
    _count?: NestedIntFilter
    _min?: NestedEnumWithdrawStatusFilter
    _max?: NestedEnumWithdrawStatusFilter
  }

  export type NestedEnumBankAccountStatusFilter = {
    equals?: BankAccountStatus
    in?: Enumerable<BankAccountStatus>
    notIn?: Enumerable<BankAccountStatus>
    not?: NestedEnumBankAccountStatusFilter | BankAccountStatus
  }

  export type NestedEnumAccountHolderTypeFilter = {
    equals?: AccountHolderType
    in?: Enumerable<AccountHolderType>
    notIn?: Enumerable<AccountHolderType>
    not?: NestedEnumAccountHolderTypeFilter | AccountHolderType
  }

  export type NestedEnumBankAccountStatusWithAggregatesFilter = {
    equals?: BankAccountStatus
    in?: Enumerable<BankAccountStatus>
    notIn?: Enumerable<BankAccountStatus>
    not?: NestedEnumBankAccountStatusWithAggregatesFilter | BankAccountStatus
    _count?: NestedIntFilter
    _min?: NestedEnumBankAccountStatusFilter
    _max?: NestedEnumBankAccountStatusFilter
  }

  export type NestedEnumAccountHolderTypeWithAggregatesFilter = {
    equals?: AccountHolderType
    in?: Enumerable<AccountHolderType>
    notIn?: Enumerable<AccountHolderType>
    not?: NestedEnumAccountHolderTypeWithAggregatesFilter | AccountHolderType
    _count?: NestedIntFilter
    _min?: NestedEnumAccountHolderTypeFilter
    _max?: NestedEnumAccountHolderTypeFilter
  }

  export type NestedEnumExpenseTypeFilter = {
    equals?: ExpenseType
    in?: Enumerable<ExpenseType>
    notIn?: Enumerable<ExpenseType>
    not?: NestedEnumExpenseTypeFilter | ExpenseType
  }

  export type NestedEnumExpenseTypeWithAggregatesFilter = {
    equals?: ExpenseType
    in?: Enumerable<ExpenseType>
    notIn?: Enumerable<ExpenseType>
    not?: NestedEnumExpenseTypeWithAggregatesFilter | ExpenseType
    _count?: NestedIntFilter
    _min?: NestedEnumExpenseTypeFilter
    _max?: NestedEnumExpenseTypeFilter
  }

  export type NestedEnumDocumentTypeFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeFilter | DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeWithAggregatesFilter | DocumentType
    _count?: NestedIntFilter
    _min?: NestedEnumDocumentTypeFilter
    _max?: NestedEnumDocumentTypeFilter
  }

  export type DonationCreateWithoutPersonInput = {
    id?: string
    type: DonationType
    status?: DonationStatus
    provider?: PaymentProvider
    currency?: Currency
    amount?: number
    extCustomerId: string
    extPaymentIntentId: string
    extPaymentMethodId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    targetVault: VaultCreateNestedOneWithoutDonationsInput
  }

  export type DonationUncheckedCreateWithoutPersonInput = {
    id?: string
    type: DonationType
    status?: DonationStatus
    provider?: PaymentProvider
    currency?: Currency
    amount?: number
    targetVaultId: string
    extCustomerId: string
    extPaymentIntentId: string
    extPaymentMethodId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type DonationCreateOrConnectWithoutPersonInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutPersonInput, DonationUncheckedCreateWithoutPersonInput>
  }

  export type DonationCreateManyPersonInputEnvelope = {
    data: Enumerable<DonationCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutApprovedByInput = {
    id?: string
    type: ExpenseType
    currency?: Currency
    amount?: number
    description?: string | null
    vault: VaultCreateNestedOneWithoutExpensesInput
    document?: DocumentCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutApprovedByInput = {
    id?: string
    type: ExpenseType
    currency?: Currency
    amount?: number
    description?: string | null
    vaultId: string
    documentId?: string | null
  }

  export type ExpenseCreateOrConnectWithoutApprovedByInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutApprovedByInput, ExpenseUncheckedCreateWithoutApprovedByInput>
  }

  export type ExpenseCreateManyApprovedByInputEnvelope = {
    data: Enumerable<ExpenseCreateManyApprovedByInput>
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutOwnerInput = {
    id?: string
    type: DocumentType
    name: string
    filename: string
    filetype?: string | null
    description?: string | null
    sourceUrl: string
    expenses?: ExpenseCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutOwnerInput = {
    id?: string
    type: DocumentType
    name: string
    filename: string
    filetype?: string | null
    description?: string | null
    sourceUrl: string
    expenses?: ExpenseUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutOwnerInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutOwnerInput, DocumentUncheckedCreateWithoutOwnerInput>
  }

  export type DocumentCreateManyOwnerInputEnvelope = {
    data: Enumerable<DocumentCreateManyOwnerInput>
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutApprovedByInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    sourceVault: VaultCreateNestedOneWithoutSourceTransfersInput
    sourceCampaign: CampaignCreateNestedOneWithoutOutgoingTransfersInput
    targetVault: VaultCreateNestedOneWithoutTargetTransfersInput
    targetCampaign: CampaignCreateNestedOneWithoutIncomingTransfersInput
  }

  export type TransferUncheckedCreateWithoutApprovedByInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    targetVaultId: string
    targetCampaignId: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TransferCreateOrConnectWithoutApprovedByInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutApprovedByInput, TransferUncheckedCreateWithoutApprovedByInput>
  }

  export type TransferCreateManyApprovedByInputEnvelope = {
    data: Enumerable<TransferCreateManyApprovedByInput>
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutApprovedByInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    beneficiaries: BeneficiaryCreateNestedOneWithoutCampaignsInput
    campaignTypes: CampaignTypeCreateNestedOneWithoutCampaignsInput
    vaults?: VaultCreateNestedManyWithoutCampaignInput
    incomingTransfers?: TransferCreateNestedManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferCreateNestedManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedCreateWithoutApprovedByInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    beneficiaryId: string
    campaignTypeId: string
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    vaults?: VaultUncheckedCreateNestedManyWithoutCampaignInput
    incomingTransfers?: TransferUncheckedCreateNestedManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUncheckedCreateNestedManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignCreateOrConnectWithoutApprovedByInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutApprovedByInput, CampaignUncheckedCreateWithoutApprovedByInput>
  }

  export type CampaignCreateManyApprovedByInputEnvelope = {
    data: Enumerable<CampaignCreateManyApprovedByInput>
    skipDuplicates?: boolean
  }

  export type SupporterCreateWithoutPersonInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    comment?: string | null
    associationMember?: boolean
    benefactorCampaign?: boolean
    benefactorPlatform?: boolean
    companyOtherText?: string | null
    companySponsor?: boolean
    companyVolunteer?: boolean
    partnerBussiness?: boolean
    partnerNpo?: boolean
    partnerOtherText?: string | null
    roleAssociationMember?: boolean
    roleBenefactor?: boolean
    roleCompany?: boolean
    rolePartner?: boolean
    roleVolunteer?: boolean
    volunteerBackend?: boolean
    volunteerDesigner?: boolean
    volunteerDevOps?: boolean
    volunteerFinancesAndAccounts?: boolean
    volunteerFrontend?: boolean
    volunteerLawyer?: boolean
    volunteerMarketing?: boolean
    volunteerProjectManager?: boolean
    volunteerQa?: boolean
    volunteerSecurity?: boolean
  }

  export type SupporterUncheckedCreateWithoutPersonInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    comment?: string | null
    associationMember?: boolean
    benefactorCampaign?: boolean
    benefactorPlatform?: boolean
    companyOtherText?: string | null
    companySponsor?: boolean
    companyVolunteer?: boolean
    partnerBussiness?: boolean
    partnerNpo?: boolean
    partnerOtherText?: string | null
    roleAssociationMember?: boolean
    roleBenefactor?: boolean
    roleCompany?: boolean
    rolePartner?: boolean
    roleVolunteer?: boolean
    volunteerBackend?: boolean
    volunteerDesigner?: boolean
    volunteerDevOps?: boolean
    volunteerFinancesAndAccounts?: boolean
    volunteerFrontend?: boolean
    volunteerLawyer?: boolean
    volunteerMarketing?: boolean
    volunteerProjectManager?: boolean
    volunteerQa?: boolean
    volunteerSecurity?: boolean
  }

  export type SupporterCreateOrConnectWithoutPersonInput = {
    where: SupporterWhereUniqueInput
    create: XOR<SupporterCreateWithoutPersonInput, SupporterUncheckedCreateWithoutPersonInput>
  }

  export type SupporterCreateManyPersonInputEnvelope = {
    data: Enumerable<SupporterCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type BenefactorCreateWithoutPersonInput = {
    id?: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BenefactorUncheckedCreateWithoutPersonInput = {
    id?: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BenefactorCreateOrConnectWithoutPersonInput = {
    where: BenefactorWhereUniqueInput
    create: XOR<BenefactorCreateWithoutPersonInput, BenefactorUncheckedCreateWithoutPersonInput>
  }

  export type BenefactorCreateManyPersonInputEnvelope = {
    data: Enumerable<BenefactorCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type WithdrawalCreateWithoutApprovedByInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    sourceVault: VaultCreateNestedOneWithoutWithdrawsInput
    sourceCampaign: CampaignCreateNestedOneWithoutWithdrawalsInput
    bankAccount: BankAccountCreateNestedOneWithoutWithdrawsInput
  }

  export type WithdrawalUncheckedCreateWithoutApprovedByInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    bankAccountId: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalCreateOrConnectWithoutApprovedByInput = {
    where: WithdrawalWhereUniqueInput
    create: XOR<WithdrawalCreateWithoutApprovedByInput, WithdrawalUncheckedCreateWithoutApprovedByInput>
  }

  export type WithdrawalCreateManyApprovedByInputEnvelope = {
    data: Enumerable<WithdrawalCreateManyApprovedByInput>
    skipDuplicates?: boolean
  }

  export type BeneficiaryCreateWithoutPersonInput = {
    id?: string
    type: BeneficiaryType
    countryCode: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
    city: CityCreateNestedOneWithoutBeneficiariesInput
    coordinator: CoordinatorCreateNestedOneWithoutBeneficiariesInput
    company?: CompanyCreateNestedOneWithoutBeneficiariesInput
    campaigns?: CampaignCreateNestedManyWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateWithoutPersonInput = {
    id?: string
    type: BeneficiaryType
    companyId?: string | null
    coordinatorId: string
    countryCode: string
    cityId: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
    campaigns?: CampaignUncheckedCreateNestedManyWithoutBeneficiariesInput
  }

  export type BeneficiaryCreateOrConnectWithoutPersonInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutPersonInput, BeneficiaryUncheckedCreateWithoutPersonInput>
  }

  export type BeneficiaryCreateManyPersonInputEnvelope = {
    data: Enumerable<BeneficiaryCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type InfoRequestCreateWithoutPersonInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type InfoRequestUncheckedCreateWithoutPersonInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type InfoRequestCreateOrConnectWithoutPersonInput = {
    where: InfoRequestWhereUniqueInput
    create: XOR<InfoRequestCreateWithoutPersonInput, InfoRequestUncheckedCreateWithoutPersonInput>
  }

  export type InfoRequestCreateManyPersonInputEnvelope = {
    data: Enumerable<InfoRequestCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type CoordinatorCreateWithoutPersonInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCoordinatorInput
  }

  export type CoordinatorUncheckedCreateWithoutPersonInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCoordinatorInput
  }

  export type CoordinatorCreateOrConnectWithoutPersonInput = {
    where: CoordinatorWhereUniqueInput
    create: XOR<CoordinatorCreateWithoutPersonInput, CoordinatorUncheckedCreateWithoutPersonInput>
  }

  export type CoordinatorCreateManyPersonInputEnvelope = {
    data: Enumerable<CoordinatorCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type RecurringDonationCreateWithoutPersonInput = {
    id?: string
    status: RecurringDonationStatus
    currency?: Currency
    amount?: number
    extSubscriptionId: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    sourceVault: VaultCreateNestedOneWithoutRecurringDonationsInput
  }

  export type RecurringDonationUncheckedCreateWithoutPersonInput = {
    id?: string
    status: RecurringDonationStatus
    vaultId: string
    currency?: Currency
    amount?: number
    extSubscriptionId: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RecurringDonationCreateOrConnectWithoutPersonInput = {
    where: RecurringDonationWhereUniqueInput
    create: XOR<RecurringDonationCreateWithoutPersonInput, RecurringDonationUncheckedCreateWithoutPersonInput>
  }

  export type RecurringDonationCreateManyPersonInputEnvelope = {
    data: Enumerable<RecurringDonationCreateManyPersonInput>
    skipDuplicates?: boolean
  }

  export type DonationUpsertWithWhereUniqueWithoutPersonInput = {
    where: DonationWhereUniqueInput
    update: XOR<DonationUpdateWithoutPersonInput, DonationUncheckedUpdateWithoutPersonInput>
    create: XOR<DonationCreateWithoutPersonInput, DonationUncheckedCreateWithoutPersonInput>
  }

  export type DonationUpdateWithWhereUniqueWithoutPersonInput = {
    where: DonationWhereUniqueInput
    data: XOR<DonationUpdateWithoutPersonInput, DonationUncheckedUpdateWithoutPersonInput>
  }

  export type DonationUpdateManyWithWhereWithoutPersonInput = {
    where: DonationScalarWhereInput
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyWithoutDonationInput>
  }

  export type DonationScalarWhereInput = {
    AND?: Enumerable<DonationScalarWhereInput>
    OR?: Enumerable<DonationScalarWhereInput>
    NOT?: Enumerable<DonationScalarWhereInput>
    id?: StringFilter | string
    type?: EnumDonationTypeFilter | DonationType
    status?: EnumDonationStatusFilter | DonationStatus
    provider?: EnumPaymentProviderFilter | PaymentProvider
    personId?: StringNullableFilter | string | null
    currency?: EnumCurrencyFilter | Currency
    amount?: IntFilter | number
    targetVaultId?: StringFilter | string
    extCustomerId?: StringFilter | string
    extPaymentIntentId?: StringFilter | string
    extPaymentMethodId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ExpenseUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutApprovedByInput, ExpenseUncheckedUpdateWithoutApprovedByInput>
    create: XOR<ExpenseCreateWithoutApprovedByInput, ExpenseUncheckedCreateWithoutApprovedByInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutApprovedByInput, ExpenseUncheckedUpdateWithoutApprovedByInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutApprovedByInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutExpensesInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: Enumerable<ExpenseScalarWhereInput>
    OR?: Enumerable<ExpenseScalarWhereInput>
    NOT?: Enumerable<ExpenseScalarWhereInput>
    id?: StringFilter | string
    type?: EnumExpenseTypeFilter | ExpenseType
    currency?: EnumCurrencyFilter | Currency
    amount?: IntFilter | number
    description?: StringNullableFilter | string | null
    vaultId?: StringFilter | string
    documentId?: StringNullableFilter | string | null
    approvedById?: StringNullableFilter | string | null
  }

  export type DocumentUpsertWithWhereUniqueWithoutOwnerInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutOwnerInput, DocumentUncheckedUpdateWithoutOwnerInput>
    create: XOR<DocumentCreateWithoutOwnerInput, DocumentUncheckedCreateWithoutOwnerInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutOwnerInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutOwnerInput, DocumentUncheckedUpdateWithoutOwnerInput>
  }

  export type DocumentUpdateManyWithWhereWithoutOwnerInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: Enumerable<DocumentScalarWhereInput>
    OR?: Enumerable<DocumentScalarWhereInput>
    NOT?: Enumerable<DocumentScalarWhereInput>
    id?: StringFilter | string
    type?: EnumDocumentTypeFilter | DocumentType
    name?: StringFilter | string
    filename?: StringFilter | string
    filetype?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    sourceUrl?: StringFilter | string
    ownerId?: StringFilter | string
  }

  export type TransferUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutApprovedByInput, TransferUncheckedUpdateWithoutApprovedByInput>
    create: XOR<TransferCreateWithoutApprovedByInput, TransferUncheckedCreateWithoutApprovedByInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutApprovedByInput, TransferUncheckedUpdateWithoutApprovedByInput>
  }

  export type TransferUpdateManyWithWhereWithoutApprovedByInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutTransfersInput>
  }

  export type TransferScalarWhereInput = {
    AND?: Enumerable<TransferScalarWhereInput>
    OR?: Enumerable<TransferScalarWhereInput>
    NOT?: Enumerable<TransferScalarWhereInput>
    id?: StringFilter | string
    status?: EnumTransferStatusFilter | TransferStatus
    currency?: EnumCurrencyFilter | Currency
    amount?: IntFilter | number
    reason?: StringFilter | string
    sourceVaultId?: StringFilter | string
    sourceCampaignId?: StringFilter | string
    targetVaultId?: StringFilter | string
    targetCampaignId?: StringFilter | string
    approvedById?: StringNullableFilter | string | null
    documentId?: StringNullableFilter | string | null
    targetDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CampaignUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutApprovedByInput, CampaignUncheckedUpdateWithoutApprovedByInput>
    create: XOR<CampaignCreateWithoutApprovedByInput, CampaignUncheckedCreateWithoutApprovedByInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutApprovedByInput, CampaignUncheckedUpdateWithoutApprovedByInput>
  }

  export type CampaignUpdateManyWithWhereWithoutApprovedByInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: Enumerable<CampaignScalarWhereInput>
    OR?: Enumerable<CampaignScalarWhereInput>
    NOT?: Enumerable<CampaignScalarWhereInput>
    id?: StringFilter | string
    state?: EnumCampaignStateFilter | CampaignState
    slug?: StringFilter | string
    title?: StringFilter | string
    essence?: StringFilter | string
    coordinatorId?: StringFilter | string
    beneficiaryId?: StringFilter | string
    campaignTypeId?: StringFilter | string
    approvedById?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    targetAmount?: IntNullableFilter | number | null
    currency?: EnumCurrencyFilter | Currency
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type SupporterUpsertWithWhereUniqueWithoutPersonInput = {
    where: SupporterWhereUniqueInput
    update: XOR<SupporterUpdateWithoutPersonInput, SupporterUncheckedUpdateWithoutPersonInput>
    create: XOR<SupporterCreateWithoutPersonInput, SupporterUncheckedCreateWithoutPersonInput>
  }

  export type SupporterUpdateWithWhereUniqueWithoutPersonInput = {
    where: SupporterWhereUniqueInput
    data: XOR<SupporterUpdateWithoutPersonInput, SupporterUncheckedUpdateWithoutPersonInput>
  }

  export type SupporterUpdateManyWithWhereWithoutPersonInput = {
    where: SupporterScalarWhereInput
    data: XOR<SupporterUpdateManyMutationInput, SupporterUncheckedUpdateManyWithoutSupportersInput>
  }

  export type SupporterScalarWhereInput = {
    AND?: Enumerable<SupporterScalarWhereInput>
    OR?: Enumerable<SupporterScalarWhereInput>
    NOT?: Enumerable<SupporterScalarWhereInput>
    id?: StringFilter | string
    personId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
    comment?: StringNullableFilter | string | null
    associationMember?: BoolFilter | boolean
    benefactorCampaign?: BoolFilter | boolean
    benefactorPlatform?: BoolFilter | boolean
    companyOtherText?: StringNullableFilter | string | null
    companySponsor?: BoolFilter | boolean
    companyVolunteer?: BoolFilter | boolean
    partnerBussiness?: BoolFilter | boolean
    partnerNpo?: BoolFilter | boolean
    partnerOtherText?: StringNullableFilter | string | null
    roleAssociationMember?: BoolFilter | boolean
    roleBenefactor?: BoolFilter | boolean
    roleCompany?: BoolFilter | boolean
    rolePartner?: BoolFilter | boolean
    roleVolunteer?: BoolFilter | boolean
    volunteerBackend?: BoolFilter | boolean
    volunteerDesigner?: BoolFilter | boolean
    volunteerDevOps?: BoolFilter | boolean
    volunteerFinancesAndAccounts?: BoolFilter | boolean
    volunteerFrontend?: BoolFilter | boolean
    volunteerLawyer?: BoolFilter | boolean
    volunteerMarketing?: BoolFilter | boolean
    volunteerProjectManager?: BoolFilter | boolean
    volunteerQa?: BoolFilter | boolean
    volunteerSecurity?: BoolFilter | boolean
  }

  export type BenefactorUpsertWithWhereUniqueWithoutPersonInput = {
    where: BenefactorWhereUniqueInput
    update: XOR<BenefactorUpdateWithoutPersonInput, BenefactorUncheckedUpdateWithoutPersonInput>
    create: XOR<BenefactorCreateWithoutPersonInput, BenefactorUncheckedCreateWithoutPersonInput>
  }

  export type BenefactorUpdateWithWhereUniqueWithoutPersonInput = {
    where: BenefactorWhereUniqueInput
    data: XOR<BenefactorUpdateWithoutPersonInput, BenefactorUncheckedUpdateWithoutPersonInput>
  }

  export type BenefactorUpdateManyWithWhereWithoutPersonInput = {
    where: BenefactorScalarWhereInput
    data: XOR<BenefactorUpdateManyMutationInput, BenefactorUncheckedUpdateManyWithoutBenefactorsInput>
  }

  export type BenefactorScalarWhereInput = {
    AND?: Enumerable<BenefactorScalarWhereInput>
    OR?: Enumerable<BenefactorScalarWhereInput>
    NOT?: Enumerable<BenefactorScalarWhereInput>
    id?: StringFilter | string
    personId?: StringFilter | string
    extCustomerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type WithdrawalUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: WithdrawalWhereUniqueInput
    update: XOR<WithdrawalUpdateWithoutApprovedByInput, WithdrawalUncheckedUpdateWithoutApprovedByInput>
    create: XOR<WithdrawalCreateWithoutApprovedByInput, WithdrawalUncheckedCreateWithoutApprovedByInput>
  }

  export type WithdrawalUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: WithdrawalWhereUniqueInput
    data: XOR<WithdrawalUpdateWithoutApprovedByInput, WithdrawalUncheckedUpdateWithoutApprovedByInput>
  }

  export type WithdrawalUpdateManyWithWhereWithoutApprovedByInput = {
    where: WithdrawalScalarWhereInput
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyWithoutWithdrawalsInput>
  }

  export type WithdrawalScalarWhereInput = {
    AND?: Enumerable<WithdrawalScalarWhereInput>
    OR?: Enumerable<WithdrawalScalarWhereInput>
    NOT?: Enumerable<WithdrawalScalarWhereInput>
    id?: StringFilter | string
    status?: EnumWithdrawStatusFilter | WithdrawStatus
    currency?: EnumCurrencyFilter | Currency
    amount?: IntFilter | number
    reason?: StringFilter | string
    sourceVaultId?: StringFilter | string
    sourceCampaignId?: StringFilter | string
    bankAccountId?: StringFilter | string
    documentId?: StringNullableFilter | string | null
    approvedById?: StringNullableFilter | string | null
    targetDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type BeneficiaryUpsertWithWhereUniqueWithoutPersonInput = {
    where: BeneficiaryWhereUniqueInput
    update: XOR<BeneficiaryUpdateWithoutPersonInput, BeneficiaryUncheckedUpdateWithoutPersonInput>
    create: XOR<BeneficiaryCreateWithoutPersonInput, BeneficiaryUncheckedCreateWithoutPersonInput>
  }

  export type BeneficiaryUpdateWithWhereUniqueWithoutPersonInput = {
    where: BeneficiaryWhereUniqueInput
    data: XOR<BeneficiaryUpdateWithoutPersonInput, BeneficiaryUncheckedUpdateWithoutPersonInput>
  }

  export type BeneficiaryUpdateManyWithWhereWithoutPersonInput = {
    where: BeneficiaryScalarWhereInput
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyWithoutBeneficiariesInput>
  }

  export type BeneficiaryScalarWhereInput = {
    AND?: Enumerable<BeneficiaryScalarWhereInput>
    OR?: Enumerable<BeneficiaryScalarWhereInput>
    NOT?: Enumerable<BeneficiaryScalarWhereInput>
    id?: StringFilter | string
    type?: EnumBeneficiaryTypeFilter | BeneficiaryType
    personId?: StringNullableFilter | string | null
    companyId?: StringNullableFilter | string | null
    coordinatorId?: StringFilter | string
    countryCode?: StringFilter | string
    cityId?: StringFilter | string
    description?: StringNullableFilter | string | null
    publicData?: JsonNullableFilter
    privateData?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    coordinatorRelation?: EnumPersonRelationFilter | PersonRelation
  }

  export type InfoRequestUpsertWithWhereUniqueWithoutPersonInput = {
    where: InfoRequestWhereUniqueInput
    update: XOR<InfoRequestUpdateWithoutPersonInput, InfoRequestUncheckedUpdateWithoutPersonInput>
    create: XOR<InfoRequestCreateWithoutPersonInput, InfoRequestUncheckedCreateWithoutPersonInput>
  }

  export type InfoRequestUpdateWithWhereUniqueWithoutPersonInput = {
    where: InfoRequestWhereUniqueInput
    data: XOR<InfoRequestUpdateWithoutPersonInput, InfoRequestUncheckedUpdateWithoutPersonInput>
  }

  export type InfoRequestUpdateManyWithWhereWithoutPersonInput = {
    where: InfoRequestScalarWhereInput
    data: XOR<InfoRequestUpdateManyMutationInput, InfoRequestUncheckedUpdateManyWithoutInfoRequestsInput>
  }

  export type InfoRequestScalarWhereInput = {
    AND?: Enumerable<InfoRequestScalarWhereInput>
    OR?: Enumerable<InfoRequestScalarWhereInput>
    NOT?: Enumerable<InfoRequestScalarWhereInput>
    id?: StringFilter | string
    personId?: StringFilter | string
    message?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CoordinatorUpsertWithWhereUniqueWithoutPersonInput = {
    where: CoordinatorWhereUniqueInput
    update: XOR<CoordinatorUpdateWithoutPersonInput, CoordinatorUncheckedUpdateWithoutPersonInput>
    create: XOR<CoordinatorCreateWithoutPersonInput, CoordinatorUncheckedCreateWithoutPersonInput>
  }

  export type CoordinatorUpdateWithWhereUniqueWithoutPersonInput = {
    where: CoordinatorWhereUniqueInput
    data: XOR<CoordinatorUpdateWithoutPersonInput, CoordinatorUncheckedUpdateWithoutPersonInput>
  }

  export type CoordinatorUpdateManyWithWhereWithoutPersonInput = {
    where: CoordinatorScalarWhereInput
    data: XOR<CoordinatorUpdateManyMutationInput, CoordinatorUncheckedUpdateManyWithoutCoordinatorsInput>
  }

  export type CoordinatorScalarWhereInput = {
    AND?: Enumerable<CoordinatorScalarWhereInput>
    OR?: Enumerable<CoordinatorScalarWhereInput>
    NOT?: Enumerable<CoordinatorScalarWhereInput>
    id?: StringFilter | string
    personId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type RecurringDonationUpsertWithWhereUniqueWithoutPersonInput = {
    where: RecurringDonationWhereUniqueInput
    update: XOR<RecurringDonationUpdateWithoutPersonInput, RecurringDonationUncheckedUpdateWithoutPersonInput>
    create: XOR<RecurringDonationCreateWithoutPersonInput, RecurringDonationUncheckedCreateWithoutPersonInput>
  }

  export type RecurringDonationUpdateWithWhereUniqueWithoutPersonInput = {
    where: RecurringDonationWhereUniqueInput
    data: XOR<RecurringDonationUpdateWithoutPersonInput, RecurringDonationUncheckedUpdateWithoutPersonInput>
  }

  export type RecurringDonationUpdateManyWithWhereWithoutPersonInput = {
    where: RecurringDonationScalarWhereInput
    data: XOR<RecurringDonationUpdateManyMutationInput, RecurringDonationUncheckedUpdateManyWithoutRecurringDonationsInput>
  }

  export type RecurringDonationScalarWhereInput = {
    AND?: Enumerable<RecurringDonationScalarWhereInput>
    OR?: Enumerable<RecurringDonationScalarWhereInput>
    NOT?: Enumerable<RecurringDonationScalarWhereInput>
    id?: StringFilter | string
    status?: EnumRecurringDonationStatusFilter | RecurringDonationStatus
    vaultId?: StringFilter | string
    personId?: StringFilter | string
    currency?: EnumCurrencyFilter | Currency
    amount?: IntFilter | number
    extSubscriptionId?: StringFilter | string
    extCustomerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type BeneficiaryCreateWithoutCompanyInput = {
    id?: string
    type: BeneficiaryType
    countryCode: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
    city: CityCreateNestedOneWithoutBeneficiariesInput
    coordinator: CoordinatorCreateNestedOneWithoutBeneficiariesInput
    person?: PersonCreateNestedOneWithoutBeneficiariesInput
    campaigns?: CampaignCreateNestedManyWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateWithoutCompanyInput = {
    id?: string
    type: BeneficiaryType
    personId?: string | null
    coordinatorId: string
    countryCode: string
    cityId: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
    campaigns?: CampaignUncheckedCreateNestedManyWithoutBeneficiariesInput
  }

  export type BeneficiaryCreateOrConnectWithoutCompanyInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutCompanyInput, BeneficiaryUncheckedCreateWithoutCompanyInput>
  }

  export type BeneficiaryCreateManyCompanyInputEnvelope = {
    data: Enumerable<BeneficiaryCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type BeneficiaryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: BeneficiaryWhereUniqueInput
    update: XOR<BeneficiaryUpdateWithoutCompanyInput, BeneficiaryUncheckedUpdateWithoutCompanyInput>
    create: XOR<BeneficiaryCreateWithoutCompanyInput, BeneficiaryUncheckedCreateWithoutCompanyInput>
  }

  export type BeneficiaryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: BeneficiaryWhereUniqueInput
    data: XOR<BeneficiaryUpdateWithoutCompanyInput, BeneficiaryUncheckedUpdateWithoutCompanyInput>
  }

  export type BeneficiaryUpdateManyWithWhereWithoutCompanyInput = {
    where: BeneficiaryScalarWhereInput
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyWithoutBeneficiariesInput>
  }

  export type PersonCreateWithoutCoordinatorsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationCreateNestedManyWithoutPersonInput
    expenses?: ExpenseCreateNestedManyWithoutApprovedByInput
    documents?: DocumentCreateNestedManyWithoutOwnerInput
    transfers?: TransferCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutCoordinatorsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationUncheckedCreateNestedManyWithoutPersonInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutApprovedByInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterUncheckedCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorUncheckedCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutCoordinatorsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutCoordinatorsInput, PersonUncheckedCreateWithoutCoordinatorsInput>
  }

  export type BeneficiaryCreateWithoutCoordinatorInput = {
    id?: string
    type: BeneficiaryType
    countryCode: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
    city: CityCreateNestedOneWithoutBeneficiariesInput
    person?: PersonCreateNestedOneWithoutBeneficiariesInput
    company?: CompanyCreateNestedOneWithoutBeneficiariesInput
    campaigns?: CampaignCreateNestedManyWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateWithoutCoordinatorInput = {
    id?: string
    type: BeneficiaryType
    personId?: string | null
    companyId?: string | null
    countryCode: string
    cityId: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
    campaigns?: CampaignUncheckedCreateNestedManyWithoutBeneficiariesInput
  }

  export type BeneficiaryCreateOrConnectWithoutCoordinatorInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutCoordinatorInput, BeneficiaryUncheckedCreateWithoutCoordinatorInput>
  }

  export type BeneficiaryCreateManyCoordinatorInputEnvelope = {
    data: Enumerable<BeneficiaryCreateManyCoordinatorInput>
    skipDuplicates?: boolean
  }

  export type PersonUpsertWithoutCoordinatorsInput = {
    update: XOR<PersonUpdateWithoutCoordinatorsInput, PersonUncheckedUpdateWithoutCoordinatorsInput>
    create: XOR<PersonCreateWithoutCoordinatorsInput, PersonUncheckedCreateWithoutCoordinatorsInput>
  }

  export type PersonUpdateWithoutCoordinatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUpdateManyWithoutPersonInput
    expenses?: ExpenseUpdateManyWithoutApprovedByInput
    documents?: DocumentUpdateManyWithoutOwnerInput
    transfers?: TransferUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUpdateManyWithoutApprovedByInput
    supporters?: SupporterUpdateManyWithoutPersonInput
    benefactors?: BenefactorUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutCoordinatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUncheckedUpdateManyWithoutPersonInput
    expenses?: ExpenseUncheckedUpdateManyWithoutApprovedByInput
    documents?: DocumentUncheckedUpdateManyWithoutOwnerInput
    transfers?: TransferUncheckedUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedUpdateManyWithoutApprovedByInput
    supporters?: SupporterUncheckedUpdateManyWithoutPersonInput
    benefactors?: BenefactorUncheckedUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutPersonInput
  }

  export type BeneficiaryUpsertWithWhereUniqueWithoutCoordinatorInput = {
    where: BeneficiaryWhereUniqueInput
    update: XOR<BeneficiaryUpdateWithoutCoordinatorInput, BeneficiaryUncheckedUpdateWithoutCoordinatorInput>
    create: XOR<BeneficiaryCreateWithoutCoordinatorInput, BeneficiaryUncheckedCreateWithoutCoordinatorInput>
  }

  export type BeneficiaryUpdateWithWhereUniqueWithoutCoordinatorInput = {
    where: BeneficiaryWhereUniqueInput
    data: XOR<BeneficiaryUpdateWithoutCoordinatorInput, BeneficiaryUncheckedUpdateWithoutCoordinatorInput>
  }

  export type BeneficiaryUpdateManyWithWhereWithoutCoordinatorInput = {
    where: BeneficiaryScalarWhereInput
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyWithoutBeneficiariesInput>
  }

  export type PersonCreateWithoutBenefactorsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationCreateNestedManyWithoutPersonInput
    expenses?: ExpenseCreateNestedManyWithoutApprovedByInput
    documents?: DocumentCreateNestedManyWithoutOwnerInput
    transfers?: TransferCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutBenefactorsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationUncheckedCreateNestedManyWithoutPersonInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutApprovedByInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterUncheckedCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutBenefactorsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutBenefactorsInput, PersonUncheckedCreateWithoutBenefactorsInput>
  }

  export type PersonUpsertWithoutBenefactorsInput = {
    update: XOR<PersonUpdateWithoutBenefactorsInput, PersonUncheckedUpdateWithoutBenefactorsInput>
    create: XOR<PersonCreateWithoutBenefactorsInput, PersonUncheckedCreateWithoutBenefactorsInput>
  }

  export type PersonUpdateWithoutBenefactorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUpdateManyWithoutPersonInput
    expenses?: ExpenseUpdateManyWithoutApprovedByInput
    documents?: DocumentUpdateManyWithoutOwnerInput
    transfers?: TransferUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUpdateManyWithoutApprovedByInput
    supporters?: SupporterUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutBenefactorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUncheckedUpdateManyWithoutPersonInput
    expenses?: ExpenseUncheckedUpdateManyWithoutApprovedByInput
    documents?: DocumentUncheckedUpdateManyWithoutOwnerInput
    transfers?: TransferUncheckedUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedUpdateManyWithoutApprovedByInput
    supporters?: SupporterUncheckedUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutPersonInput
  }

  export type CityCreateWithoutBeneficiariesInput = {
    id?: string
    name: string
    postalCode: number
    countryCode: CountryCreateNestedOneWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutBeneficiariesInput = {
    id?: string
    name: string
    postalCode: number
    countryId: string
  }

  export type CityCreateOrConnectWithoutBeneficiariesInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutBeneficiariesInput, CityUncheckedCreateWithoutBeneficiariesInput>
  }

  export type CoordinatorCreateWithoutBeneficiariesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    person: PersonCreateNestedOneWithoutCoordinatorsInput
  }

  export type CoordinatorUncheckedCreateWithoutBeneficiariesInput = {
    id?: string
    personId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CoordinatorCreateOrConnectWithoutBeneficiariesInput = {
    where: CoordinatorWhereUniqueInput
    create: XOR<CoordinatorCreateWithoutBeneficiariesInput, CoordinatorUncheckedCreateWithoutBeneficiariesInput>
  }

  export type PersonCreateWithoutBeneficiariesInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationCreateNestedManyWithoutPersonInput
    expenses?: ExpenseCreateNestedManyWithoutApprovedByInput
    documents?: DocumentCreateNestedManyWithoutOwnerInput
    transfers?: TransferCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalCreateNestedManyWithoutApprovedByInput
    infoRequests?: InfoRequestCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutBeneficiariesInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationUncheckedCreateNestedManyWithoutPersonInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutApprovedByInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterUncheckedCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorUncheckedCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutApprovedByInput
    infoRequests?: InfoRequestUncheckedCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutBeneficiariesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutBeneficiariesInput, PersonUncheckedCreateWithoutBeneficiariesInput>
  }

  export type CompanyCreateWithoutBeneficiariesInput = {
    id?: string
    companyName: string
    companyNumber: string
    legalPersonName?: string | null
    countryCode?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CompanyUncheckedCreateWithoutBeneficiariesInput = {
    id?: string
    companyName: string
    companyNumber: string
    legalPersonName?: string | null
    countryCode?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CompanyCreateOrConnectWithoutBeneficiariesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutBeneficiariesInput, CompanyUncheckedCreateWithoutBeneficiariesInput>
  }

  export type CampaignCreateWithoutBeneficiariesInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutCampaignsInput
    campaignTypes: CampaignTypeCreateNestedOneWithoutCampaignsInput
    vaults?: VaultCreateNestedManyWithoutCampaignInput
    incomingTransfers?: TransferCreateNestedManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferCreateNestedManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedCreateWithoutBeneficiariesInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    campaignTypeId: string
    approvedById?: string | null
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    vaults?: VaultUncheckedCreateNestedManyWithoutCampaignInput
    incomingTransfers?: TransferUncheckedCreateNestedManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUncheckedCreateNestedManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignCreateOrConnectWithoutBeneficiariesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutBeneficiariesInput, CampaignUncheckedCreateWithoutBeneficiariesInput>
  }

  export type CampaignCreateManyBeneficiariesInputEnvelope = {
    data: Enumerable<CampaignCreateManyBeneficiariesInput>
    skipDuplicates?: boolean
  }

  export type CityUpsertWithoutBeneficiariesInput = {
    update: XOR<CityUpdateWithoutBeneficiariesInput, CityUncheckedUpdateWithoutBeneficiariesInput>
    create: XOR<CityCreateWithoutBeneficiariesInput, CityUncheckedCreateWithoutBeneficiariesInput>
  }

  export type CityUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: IntFieldUpdateOperationsInput | number
    countryCode?: CountryUpdateOneRequiredWithoutCitiesInput
  }

  export type CityUncheckedUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: IntFieldUpdateOperationsInput | number
    countryId?: StringFieldUpdateOperationsInput | string
  }

  export type CoordinatorUpsertWithoutBeneficiariesInput = {
    update: XOR<CoordinatorUpdateWithoutBeneficiariesInput, CoordinatorUncheckedUpdateWithoutBeneficiariesInput>
    create: XOR<CoordinatorCreateWithoutBeneficiariesInput, CoordinatorUncheckedCreateWithoutBeneficiariesInput>
  }

  export type CoordinatorUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneRequiredWithoutCoordinatorsInput
  }

  export type CoordinatorUncheckedUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonUpsertWithoutBeneficiariesInput = {
    update: XOR<PersonUpdateWithoutBeneficiariesInput, PersonUncheckedUpdateWithoutBeneficiariesInput>
    create: XOR<PersonCreateWithoutBeneficiariesInput, PersonUncheckedCreateWithoutBeneficiariesInput>
  }

  export type PersonUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUpdateManyWithoutPersonInput
    expenses?: ExpenseUpdateManyWithoutApprovedByInput
    documents?: DocumentUpdateManyWithoutOwnerInput
    transfers?: TransferUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUpdateManyWithoutApprovedByInput
    supporters?: SupporterUpdateManyWithoutPersonInput
    benefactors?: BenefactorUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUpdateManyWithoutApprovedByInput
    infoRequests?: InfoRequestUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUncheckedUpdateManyWithoutPersonInput
    expenses?: ExpenseUncheckedUpdateManyWithoutApprovedByInput
    documents?: DocumentUncheckedUpdateManyWithoutOwnerInput
    transfers?: TransferUncheckedUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedUpdateManyWithoutApprovedByInput
    supporters?: SupporterUncheckedUpdateManyWithoutPersonInput
    benefactors?: BenefactorUncheckedUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutApprovedByInput
    infoRequests?: InfoRequestUncheckedUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutPersonInput
  }

  export type CompanyUpsertWithoutBeneficiariesInput = {
    update: XOR<CompanyUpdateWithoutBeneficiariesInput, CompanyUncheckedUpdateWithoutBeneficiariesInput>
    create: XOR<CompanyCreateWithoutBeneficiariesInput, CompanyUncheckedCreateWithoutBeneficiariesInput>
  }

  export type CompanyUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyNumber?: StringFieldUpdateOperationsInput | string
    legalPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUncheckedUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyNumber?: StringFieldUpdateOperationsInput | string
    legalPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignUpsertWithWhereUniqueWithoutBeneficiariesInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutBeneficiariesInput, CampaignUncheckedUpdateWithoutBeneficiariesInput>
    create: XOR<CampaignCreateWithoutBeneficiariesInput, CampaignUncheckedCreateWithoutBeneficiariesInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutBeneficiariesInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutBeneficiariesInput, CampaignUncheckedUpdateWithoutBeneficiariesInput>
  }

  export type CampaignUpdateManyWithWhereWithoutBeneficiariesInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type CampaignTypeCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parent?: CampaignTypeCreateNestedOneWithoutChildrenInput
    campaigns?: CampaignCreateNestedManyWithoutCampaignTypesInput
  }

  export type CampaignTypeUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCampaignTypesInput
  }

  export type CampaignTypeCreateOrConnectWithoutChildrenInput = {
    where: CampaignTypeWhereUniqueInput
    create: XOR<CampaignTypeCreateWithoutChildrenInput, CampaignTypeUncheckedCreateWithoutChildrenInput>
  }

  export type CampaignTypeCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    children?: CampaignTypeCreateNestedManyWithoutParentInput
    campaigns?: CampaignCreateNestedManyWithoutCampaignTypesInput
  }

  export type CampaignTypeUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    children?: CampaignTypeUncheckedCreateNestedManyWithoutParentInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCampaignTypesInput
  }

  export type CampaignTypeCreateOrConnectWithoutParentInput = {
    where: CampaignTypeWhereUniqueInput
    create: XOR<CampaignTypeCreateWithoutParentInput, CampaignTypeUncheckedCreateWithoutParentInput>
  }

  export type CampaignTypeCreateManyParentInputEnvelope = {
    data: Enumerable<CampaignTypeCreateManyParentInput>
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutCampaignTypesInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutCampaignsInput
    beneficiaries: BeneficiaryCreateNestedOneWithoutCampaignsInput
    vaults?: VaultCreateNestedManyWithoutCampaignInput
    incomingTransfers?: TransferCreateNestedManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferCreateNestedManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCampaignTypesInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    beneficiaryId: string
    approvedById?: string | null
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    vaults?: VaultUncheckedCreateNestedManyWithoutCampaignInput
    incomingTransfers?: TransferUncheckedCreateNestedManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUncheckedCreateNestedManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCampaignTypesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaignTypesInput, CampaignUncheckedCreateWithoutCampaignTypesInput>
  }

  export type CampaignCreateManyCampaignTypesInputEnvelope = {
    data: Enumerable<CampaignCreateManyCampaignTypesInput>
    skipDuplicates?: boolean
  }

  export type CampaignTypeUpsertWithoutChildrenInput = {
    update: XOR<CampaignTypeUpdateWithoutChildrenInput, CampaignTypeUncheckedUpdateWithoutChildrenInput>
    create: XOR<CampaignTypeCreateWithoutChildrenInput, CampaignTypeUncheckedCreateWithoutChildrenInput>
  }

  export type CampaignTypeUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: CampaignTypeUpdateOneWithoutChildrenInput
    campaigns?: CampaignUpdateManyWithoutCampaignTypesInput
  }

  export type CampaignTypeUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutCampaignTypesInput
  }

  export type CampaignTypeUpsertWithWhereUniqueWithoutParentInput = {
    where: CampaignTypeWhereUniqueInput
    update: XOR<CampaignTypeUpdateWithoutParentInput, CampaignTypeUncheckedUpdateWithoutParentInput>
    create: XOR<CampaignTypeCreateWithoutParentInput, CampaignTypeUncheckedCreateWithoutParentInput>
  }

  export type CampaignTypeUpdateWithWhereUniqueWithoutParentInput = {
    where: CampaignTypeWhereUniqueInput
    data: XOR<CampaignTypeUpdateWithoutParentInput, CampaignTypeUncheckedUpdateWithoutParentInput>
  }

  export type CampaignTypeUpdateManyWithWhereWithoutParentInput = {
    where: CampaignTypeScalarWhereInput
    data: XOR<CampaignTypeUpdateManyMutationInput, CampaignTypeUncheckedUpdateManyWithoutChildrenInput>
  }

  export type CampaignTypeScalarWhereInput = {
    AND?: Enumerable<CampaignTypeScalarWhereInput>
    OR?: Enumerable<CampaignTypeScalarWhereInput>
    NOT?: Enumerable<CampaignTypeScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    description?: StringNullableFilter | string | null
    parentId?: StringNullableFilter | string | null
  }

  export type CampaignUpsertWithWhereUniqueWithoutCampaignTypesInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutCampaignTypesInput, CampaignUncheckedUpdateWithoutCampaignTypesInput>
    create: XOR<CampaignCreateWithoutCampaignTypesInput, CampaignUncheckedCreateWithoutCampaignTypesInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutCampaignTypesInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutCampaignTypesInput, CampaignUncheckedUpdateWithoutCampaignTypesInput>
  }

  export type CampaignUpdateManyWithWhereWithoutCampaignTypesInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type PersonCreateWithoutCampaignsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationCreateNestedManyWithoutPersonInput
    expenses?: ExpenseCreateNestedManyWithoutApprovedByInput
    documents?: DocumentCreateNestedManyWithoutOwnerInput
    transfers?: TransferCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutCampaignsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationUncheckedCreateNestedManyWithoutPersonInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutApprovedByInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterUncheckedCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorUncheckedCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutCampaignsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutCampaignsInput, PersonUncheckedCreateWithoutCampaignsInput>
  }

  export type BeneficiaryCreateWithoutCampaignsInput = {
    id?: string
    type: BeneficiaryType
    countryCode: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
    city: CityCreateNestedOneWithoutBeneficiariesInput
    coordinator: CoordinatorCreateNestedOneWithoutBeneficiariesInput
    person?: PersonCreateNestedOneWithoutBeneficiariesInput
    company?: CompanyCreateNestedOneWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateWithoutCampaignsInput = {
    id?: string
    type: BeneficiaryType
    personId?: string | null
    companyId?: string | null
    coordinatorId: string
    countryCode: string
    cityId: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
  }

  export type BeneficiaryCreateOrConnectWithoutCampaignsInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutCampaignsInput, BeneficiaryUncheckedCreateWithoutCampaignsInput>
  }

  export type CampaignTypeCreateWithoutCampaignsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parent?: CampaignTypeCreateNestedOneWithoutChildrenInput
    children?: CampaignTypeCreateNestedManyWithoutParentInput
  }

  export type CampaignTypeUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    children?: CampaignTypeUncheckedCreateNestedManyWithoutParentInput
  }

  export type CampaignTypeCreateOrConnectWithoutCampaignsInput = {
    where: CampaignTypeWhereUniqueInput
    create: XOR<CampaignTypeCreateWithoutCampaignsInput, CampaignTypeUncheckedCreateWithoutCampaignsInput>
  }

  export type VaultCreateWithoutCampaignInput = {
    id?: string
    currency?: Currency
    amount?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    expenses?: ExpenseCreateNestedManyWithoutVaultInput
    sourceTransfers?: TransferCreateNestedManyWithoutSourceVaultInput
    targetTransfers?: TransferCreateNestedManyWithoutTargetVaultInput
    donations?: DonationCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalCreateNestedManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultUncheckedCreateWithoutCampaignInput = {
    id?: string
    currency?: Currency
    amount?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVaultInput
    sourceTransfers?: TransferUncheckedCreateNestedManyWithoutSourceVaultInput
    targetTransfers?: TransferUncheckedCreateNestedManyWithoutTargetVaultInput
    donations?: DonationUncheckedCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedCreateNestedManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultCreateOrConnectWithoutCampaignInput = {
    where: VaultWhereUniqueInput
    create: XOR<VaultCreateWithoutCampaignInput, VaultUncheckedCreateWithoutCampaignInput>
  }

  export type VaultCreateManyCampaignInputEnvelope = {
    data: Enumerable<VaultCreateManyCampaignInput>
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutTargetCampaignInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutTransfersInput
    sourceVault: VaultCreateNestedOneWithoutSourceTransfersInput
    sourceCampaign: CampaignCreateNestedOneWithoutOutgoingTransfersInput
    targetVault: VaultCreateNestedOneWithoutTargetTransfersInput
  }

  export type TransferUncheckedCreateWithoutTargetCampaignInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    targetVaultId: string
    approvedById?: string | null
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TransferCreateOrConnectWithoutTargetCampaignInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutTargetCampaignInput, TransferUncheckedCreateWithoutTargetCampaignInput>
  }

  export type TransferCreateManyTargetCampaignInputEnvelope = {
    data: Enumerable<TransferCreateManyTargetCampaignInput>
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutSourceCampaignInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutTransfersInput
    sourceVault: VaultCreateNestedOneWithoutSourceTransfersInput
    targetVault: VaultCreateNestedOneWithoutTargetTransfersInput
    targetCampaign: CampaignCreateNestedOneWithoutIncomingTransfersInput
  }

  export type TransferUncheckedCreateWithoutSourceCampaignInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    targetVaultId: string
    targetCampaignId: string
    approvedById?: string | null
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TransferCreateOrConnectWithoutSourceCampaignInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutSourceCampaignInput, TransferUncheckedCreateWithoutSourceCampaignInput>
  }

  export type TransferCreateManySourceCampaignInputEnvelope = {
    data: Enumerable<TransferCreateManySourceCampaignInput>
    skipDuplicates?: boolean
  }

  export type WithdrawalCreateWithoutSourceCampaignInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutWithdrawalsInput
    sourceVault: VaultCreateNestedOneWithoutWithdrawsInput
    bankAccount: BankAccountCreateNestedOneWithoutWithdrawsInput
  }

  export type WithdrawalUncheckedCreateWithoutSourceCampaignInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    bankAccountId: string
    documentId?: string | null
    approvedById?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalCreateOrConnectWithoutSourceCampaignInput = {
    where: WithdrawalWhereUniqueInput
    create: XOR<WithdrawalCreateWithoutSourceCampaignInput, WithdrawalUncheckedCreateWithoutSourceCampaignInput>
  }

  export type WithdrawalCreateManySourceCampaignInputEnvelope = {
    data: Enumerable<WithdrawalCreateManySourceCampaignInput>
    skipDuplicates?: boolean
  }

  export type PersonUpsertWithoutCampaignsInput = {
    update: XOR<PersonUpdateWithoutCampaignsInput, PersonUncheckedUpdateWithoutCampaignsInput>
    create: XOR<PersonCreateWithoutCampaignsInput, PersonUncheckedCreateWithoutCampaignsInput>
  }

  export type PersonUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUpdateManyWithoutPersonInput
    expenses?: ExpenseUpdateManyWithoutApprovedByInput
    documents?: DocumentUpdateManyWithoutOwnerInput
    transfers?: TransferUpdateManyWithoutApprovedByInput
    supporters?: SupporterUpdateManyWithoutPersonInput
    benefactors?: BenefactorUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUncheckedUpdateManyWithoutPersonInput
    expenses?: ExpenseUncheckedUpdateManyWithoutApprovedByInput
    documents?: DocumentUncheckedUpdateManyWithoutOwnerInput
    transfers?: TransferUncheckedUpdateManyWithoutApprovedByInput
    supporters?: SupporterUncheckedUpdateManyWithoutPersonInput
    benefactors?: BenefactorUncheckedUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutPersonInput
  }

  export type BeneficiaryUpsertWithoutCampaignsInput = {
    update: XOR<BeneficiaryUpdateWithoutCampaignsInput, BeneficiaryUncheckedUpdateWithoutCampaignsInput>
    create: XOR<BeneficiaryCreateWithoutCampaignsInput, BeneficiaryUncheckedCreateWithoutCampaignsInput>
  }

  export type BeneficiaryUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    countryCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
    city?: CityUpdateOneRequiredWithoutBeneficiariesInput
    coordinator?: CoordinatorUpdateOneRequiredWithoutBeneficiariesInput
    person?: PersonUpdateOneWithoutBeneficiariesInput
    company?: CompanyUpdateOneWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorId?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
  }

  export type CampaignTypeUpsertWithoutCampaignsInput = {
    update: XOR<CampaignTypeUpdateWithoutCampaignsInput, CampaignTypeUncheckedUpdateWithoutCampaignsInput>
    create: XOR<CampaignTypeCreateWithoutCampaignsInput, CampaignTypeUncheckedCreateWithoutCampaignsInput>
  }

  export type CampaignTypeUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: CampaignTypeUpdateOneWithoutChildrenInput
    children?: CampaignTypeUpdateManyWithoutParentInput
  }

  export type CampaignTypeUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CampaignTypeUncheckedUpdateManyWithoutParentInput
  }

  export type VaultUpsertWithWhereUniqueWithoutCampaignInput = {
    where: VaultWhereUniqueInput
    update: XOR<VaultUpdateWithoutCampaignInput, VaultUncheckedUpdateWithoutCampaignInput>
    create: XOR<VaultCreateWithoutCampaignInput, VaultUncheckedCreateWithoutCampaignInput>
  }

  export type VaultUpdateWithWhereUniqueWithoutCampaignInput = {
    where: VaultWhereUniqueInput
    data: XOR<VaultUpdateWithoutCampaignInput, VaultUncheckedUpdateWithoutCampaignInput>
  }

  export type VaultUpdateManyWithWhereWithoutCampaignInput = {
    where: VaultScalarWhereInput
    data: XOR<VaultUpdateManyMutationInput, VaultUncheckedUpdateManyWithoutVaultsInput>
  }

  export type VaultScalarWhereInput = {
    AND?: Enumerable<VaultScalarWhereInput>
    OR?: Enumerable<VaultScalarWhereInput>
    NOT?: Enumerable<VaultScalarWhereInput>
    id?: StringFilter | string
    currency?: EnumCurrencyFilter | Currency
    amount?: IntFilter | number
    campaignId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type TransferUpsertWithWhereUniqueWithoutTargetCampaignInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutTargetCampaignInput, TransferUncheckedUpdateWithoutTargetCampaignInput>
    create: XOR<TransferCreateWithoutTargetCampaignInput, TransferUncheckedCreateWithoutTargetCampaignInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutTargetCampaignInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutTargetCampaignInput, TransferUncheckedUpdateWithoutTargetCampaignInput>
  }

  export type TransferUpdateManyWithWhereWithoutTargetCampaignInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutIncomingTransfersInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutSourceCampaignInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutSourceCampaignInput, TransferUncheckedUpdateWithoutSourceCampaignInput>
    create: XOR<TransferCreateWithoutSourceCampaignInput, TransferUncheckedCreateWithoutSourceCampaignInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutSourceCampaignInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutSourceCampaignInput, TransferUncheckedUpdateWithoutSourceCampaignInput>
  }

  export type TransferUpdateManyWithWhereWithoutSourceCampaignInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutOutgoingTransfersInput>
  }

  export type WithdrawalUpsertWithWhereUniqueWithoutSourceCampaignInput = {
    where: WithdrawalWhereUniqueInput
    update: XOR<WithdrawalUpdateWithoutSourceCampaignInput, WithdrawalUncheckedUpdateWithoutSourceCampaignInput>
    create: XOR<WithdrawalCreateWithoutSourceCampaignInput, WithdrawalUncheckedCreateWithoutSourceCampaignInput>
  }

  export type WithdrawalUpdateWithWhereUniqueWithoutSourceCampaignInput = {
    where: WithdrawalWhereUniqueInput
    data: XOR<WithdrawalUpdateWithoutSourceCampaignInput, WithdrawalUncheckedUpdateWithoutSourceCampaignInput>
  }

  export type WithdrawalUpdateManyWithWhereWithoutSourceCampaignInput = {
    where: WithdrawalScalarWhereInput
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyWithoutWithdrawalsInput>
  }

  export type PersonCreateWithoutInfoRequestsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationCreateNestedManyWithoutPersonInput
    expenses?: ExpenseCreateNestedManyWithoutApprovedByInput
    documents?: DocumentCreateNestedManyWithoutOwnerInput
    transfers?: TransferCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutInfoRequestsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationUncheckedCreateNestedManyWithoutPersonInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutApprovedByInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterUncheckedCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorUncheckedCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutInfoRequestsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutInfoRequestsInput, PersonUncheckedCreateWithoutInfoRequestsInput>
  }

  export type PersonUpsertWithoutInfoRequestsInput = {
    update: XOR<PersonUpdateWithoutInfoRequestsInput, PersonUncheckedUpdateWithoutInfoRequestsInput>
    create: XOR<PersonCreateWithoutInfoRequestsInput, PersonUncheckedCreateWithoutInfoRequestsInput>
  }

  export type PersonUpdateWithoutInfoRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUpdateManyWithoutPersonInput
    expenses?: ExpenseUpdateManyWithoutApprovedByInput
    documents?: DocumentUpdateManyWithoutOwnerInput
    transfers?: TransferUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUpdateManyWithoutApprovedByInput
    supporters?: SupporterUpdateManyWithoutPersonInput
    benefactors?: BenefactorUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutInfoRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUncheckedUpdateManyWithoutPersonInput
    expenses?: ExpenseUncheckedUpdateManyWithoutApprovedByInput
    documents?: DocumentUncheckedUpdateManyWithoutOwnerInput
    transfers?: TransferUncheckedUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedUpdateManyWithoutApprovedByInput
    supporters?: SupporterUncheckedUpdateManyWithoutPersonInput
    benefactors?: BenefactorUncheckedUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutPersonInput
  }

  export type PersonCreateWithoutSupportersInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationCreateNestedManyWithoutPersonInput
    expenses?: ExpenseCreateNestedManyWithoutApprovedByInput
    documents?: DocumentCreateNestedManyWithoutOwnerInput
    transfers?: TransferCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignCreateNestedManyWithoutApprovedByInput
    benefactors?: BenefactorCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutSupportersInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationUncheckedCreateNestedManyWithoutPersonInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutApprovedByInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutApprovedByInput
    benefactors?: BenefactorUncheckedCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutSupportersInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutSupportersInput, PersonUncheckedCreateWithoutSupportersInput>
  }

  export type PersonUpsertWithoutSupportersInput = {
    update: XOR<PersonUpdateWithoutSupportersInput, PersonUncheckedUpdateWithoutSupportersInput>
    create: XOR<PersonCreateWithoutSupportersInput, PersonUncheckedCreateWithoutSupportersInput>
  }

  export type PersonUpdateWithoutSupportersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUpdateManyWithoutPersonInput
    expenses?: ExpenseUpdateManyWithoutApprovedByInput
    documents?: DocumentUpdateManyWithoutOwnerInput
    transfers?: TransferUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUpdateManyWithoutApprovedByInput
    benefactors?: BenefactorUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutSupportersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUncheckedUpdateManyWithoutPersonInput
    expenses?: ExpenseUncheckedUpdateManyWithoutApprovedByInput
    documents?: DocumentUncheckedUpdateManyWithoutOwnerInput
    transfers?: TransferUncheckedUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedUpdateManyWithoutApprovedByInput
    benefactors?: BenefactorUncheckedUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutPersonInput
  }

  export type CountryCreateWithoutCitiesInput = {
    id?: string
    name: string
    countryCode: string
  }

  export type CountryUncheckedCreateWithoutCitiesInput = {
    id?: string
    name: string
    countryCode: string
  }

  export type CountryCreateOrConnectWithoutCitiesInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
  }

  export type BeneficiaryCreateWithoutCityInput = {
    id?: string
    type: BeneficiaryType
    countryCode: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
    coordinator: CoordinatorCreateNestedOneWithoutBeneficiariesInput
    person?: PersonCreateNestedOneWithoutBeneficiariesInput
    company?: CompanyCreateNestedOneWithoutBeneficiariesInput
    campaigns?: CampaignCreateNestedManyWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedCreateWithoutCityInput = {
    id?: string
    type: BeneficiaryType
    personId?: string | null
    companyId?: string | null
    coordinatorId: string
    countryCode: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
    campaigns?: CampaignUncheckedCreateNestedManyWithoutBeneficiariesInput
  }

  export type BeneficiaryCreateOrConnectWithoutCityInput = {
    where: BeneficiaryWhereUniqueInput
    create: XOR<BeneficiaryCreateWithoutCityInput, BeneficiaryUncheckedCreateWithoutCityInput>
  }

  export type BeneficiaryCreateManyCityInputEnvelope = {
    data: Enumerable<BeneficiaryCreateManyCityInput>
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutCitiesInput = {
    update: XOR<CountryUpdateWithoutCitiesInput, CountryUncheckedUpdateWithoutCitiesInput>
    create: XOR<CountryCreateWithoutCitiesInput, CountryUncheckedCreateWithoutCitiesInput>
  }

  export type CountryUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
  }

  export type CountryUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
  }

  export type BeneficiaryUpsertWithWhereUniqueWithoutCityInput = {
    where: BeneficiaryWhereUniqueInput
    update: XOR<BeneficiaryUpdateWithoutCityInput, BeneficiaryUncheckedUpdateWithoutCityInput>
    create: XOR<BeneficiaryCreateWithoutCityInput, BeneficiaryUncheckedCreateWithoutCityInput>
  }

  export type BeneficiaryUpdateWithWhereUniqueWithoutCityInput = {
    where: BeneficiaryWhereUniqueInput
    data: XOR<BeneficiaryUpdateWithoutCityInput, BeneficiaryUncheckedUpdateWithoutCityInput>
  }

  export type BeneficiaryUpdateManyWithWhereWithoutCityInput = {
    where: BeneficiaryScalarWhereInput
    data: XOR<BeneficiaryUpdateManyMutationInput, BeneficiaryUncheckedUpdateManyWithoutBeneficiariesInput>
  }

  export type CityCreateWithoutCountryCodeInput = {
    id?: string
    name: string
    postalCode: number
    beneficiaries?: BeneficiaryCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutCountryCodeInput = {
    id?: string
    name: string
    postalCode: number
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutCountryCodeInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutCountryCodeInput, CityUncheckedCreateWithoutCountryCodeInput>
  }

  export type CityCreateManyCountryCodeInputEnvelope = {
    data: Enumerable<CityCreateManyCountryCodeInput>
    skipDuplicates?: boolean
  }

  export type CityUpsertWithWhereUniqueWithoutCountryCodeInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutCountryCodeInput, CityUncheckedUpdateWithoutCountryCodeInput>
    create: XOR<CityCreateWithoutCountryCodeInput, CityUncheckedCreateWithoutCountryCodeInput>
  }

  export type CityUpdateWithWhereUniqueWithoutCountryCodeInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutCountryCodeInput, CityUncheckedUpdateWithoutCountryCodeInput>
  }

  export type CityUpdateManyWithWhereWithoutCountryCodeInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCitiesInput>
  }

  export type CityScalarWhereInput = {
    AND?: Enumerable<CityScalarWhereInput>
    OR?: Enumerable<CityScalarWhereInput>
    NOT?: Enumerable<CityScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    postalCode?: IntFilter | number
    countryId?: StringFilter | string
  }

  export type CampaignCreateWithoutVaultsInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutCampaignsInput
    beneficiaries: BeneficiaryCreateNestedOneWithoutCampaignsInput
    campaignTypes: CampaignTypeCreateNestedOneWithoutCampaignsInput
    incomingTransfers?: TransferCreateNestedManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferCreateNestedManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedCreateWithoutVaultsInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    beneficiaryId: string
    campaignTypeId: string
    approvedById?: string | null
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    incomingTransfers?: TransferUncheckedCreateNestedManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUncheckedCreateNestedManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignCreateOrConnectWithoutVaultsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutVaultsInput, CampaignUncheckedCreateWithoutVaultsInput>
  }

  export type ExpenseCreateWithoutVaultInput = {
    id?: string
    type: ExpenseType
    currency?: Currency
    amount?: number
    description?: string | null
    approvedBy?: PersonCreateNestedOneWithoutExpensesInput
    document?: DocumentCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutVaultInput = {
    id?: string
    type: ExpenseType
    currency?: Currency
    amount?: number
    description?: string | null
    documentId?: string | null
    approvedById?: string | null
  }

  export type ExpenseCreateOrConnectWithoutVaultInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutVaultInput, ExpenseUncheckedCreateWithoutVaultInput>
  }

  export type ExpenseCreateManyVaultInputEnvelope = {
    data: Enumerable<ExpenseCreateManyVaultInput>
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutSourceVaultInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutTransfersInput
    sourceCampaign: CampaignCreateNestedOneWithoutOutgoingTransfersInput
    targetVault: VaultCreateNestedOneWithoutTargetTransfersInput
    targetCampaign: CampaignCreateNestedOneWithoutIncomingTransfersInput
  }

  export type TransferUncheckedCreateWithoutSourceVaultInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    sourceCampaignId: string
    targetVaultId: string
    targetCampaignId: string
    approvedById?: string | null
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TransferCreateOrConnectWithoutSourceVaultInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutSourceVaultInput, TransferUncheckedCreateWithoutSourceVaultInput>
  }

  export type TransferCreateManySourceVaultInputEnvelope = {
    data: Enumerable<TransferCreateManySourceVaultInput>
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutTargetVaultInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutTransfersInput
    sourceVault: VaultCreateNestedOneWithoutSourceTransfersInput
    sourceCampaign: CampaignCreateNestedOneWithoutOutgoingTransfersInput
    targetCampaign: CampaignCreateNestedOneWithoutIncomingTransfersInput
  }

  export type TransferUncheckedCreateWithoutTargetVaultInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    targetCampaignId: string
    approvedById?: string | null
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TransferCreateOrConnectWithoutTargetVaultInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutTargetVaultInput, TransferUncheckedCreateWithoutTargetVaultInput>
  }

  export type TransferCreateManyTargetVaultInputEnvelope = {
    data: Enumerable<TransferCreateManyTargetVaultInput>
    skipDuplicates?: boolean
  }

  export type DonationCreateWithoutTargetVaultInput = {
    id?: string
    type: DonationType
    status?: DonationStatus
    provider?: PaymentProvider
    currency?: Currency
    amount?: number
    extCustomerId: string
    extPaymentIntentId: string
    extPaymentMethodId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    person?: PersonCreateNestedOneWithoutDonationInput
  }

  export type DonationUncheckedCreateWithoutTargetVaultInput = {
    id?: string
    type: DonationType
    status?: DonationStatus
    provider?: PaymentProvider
    personId?: string | null
    currency?: Currency
    amount?: number
    extCustomerId: string
    extPaymentIntentId: string
    extPaymentMethodId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type DonationCreateOrConnectWithoutTargetVaultInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutTargetVaultInput, DonationUncheckedCreateWithoutTargetVaultInput>
  }

  export type DonationCreateManyTargetVaultInputEnvelope = {
    data: Enumerable<DonationCreateManyTargetVaultInput>
    skipDuplicates?: boolean
  }

  export type WithdrawalCreateWithoutSourceVaultInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutWithdrawalsInput
    sourceCampaign: CampaignCreateNestedOneWithoutWithdrawalsInput
    bankAccount: BankAccountCreateNestedOneWithoutWithdrawsInput
  }

  export type WithdrawalUncheckedCreateWithoutSourceVaultInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    sourceCampaignId: string
    bankAccountId: string
    documentId?: string | null
    approvedById?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalCreateOrConnectWithoutSourceVaultInput = {
    where: WithdrawalWhereUniqueInput
    create: XOR<WithdrawalCreateWithoutSourceVaultInput, WithdrawalUncheckedCreateWithoutSourceVaultInput>
  }

  export type WithdrawalCreateManySourceVaultInputEnvelope = {
    data: Enumerable<WithdrawalCreateManySourceVaultInput>
    skipDuplicates?: boolean
  }

  export type RecurringDonationCreateWithoutSourceVaultInput = {
    id?: string
    status: RecurringDonationStatus
    currency?: Currency
    amount?: number
    extSubscriptionId: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    person: PersonCreateNestedOneWithoutRecurringDonationsInput
  }

  export type RecurringDonationUncheckedCreateWithoutSourceVaultInput = {
    id?: string
    status: RecurringDonationStatus
    personId: string
    currency?: Currency
    amount?: number
    extSubscriptionId: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RecurringDonationCreateOrConnectWithoutSourceVaultInput = {
    where: RecurringDonationWhereUniqueInput
    create: XOR<RecurringDonationCreateWithoutSourceVaultInput, RecurringDonationUncheckedCreateWithoutSourceVaultInput>
  }

  export type RecurringDonationCreateManySourceVaultInputEnvelope = {
    data: Enumerable<RecurringDonationCreateManySourceVaultInput>
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithoutVaultsInput = {
    update: XOR<CampaignUpdateWithoutVaultsInput, CampaignUncheckedUpdateWithoutVaultsInput>
    create: XOR<CampaignCreateWithoutVaultsInput, CampaignUncheckedCreateWithoutVaultsInput>
  }

  export type CampaignUpdateWithoutVaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutCampaignsInput
    beneficiaries?: BeneficiaryUpdateOneRequiredWithoutCampaignsInput
    campaignTypes?: CampaignTypeUpdateOneRequiredWithoutCampaignsInput
    incomingTransfers?: TransferUpdateManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUpdateManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUpdateManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedUpdateWithoutVaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    beneficiaryId?: StringFieldUpdateOperationsInput | string
    campaignTypeId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incomingTransfers?: TransferUncheckedUpdateManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUncheckedUpdateManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutSourceCampaignInput
  }

  export type ExpenseUpsertWithWhereUniqueWithoutVaultInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutVaultInput, ExpenseUncheckedUpdateWithoutVaultInput>
    create: XOR<ExpenseCreateWithoutVaultInput, ExpenseUncheckedCreateWithoutVaultInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutVaultInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutVaultInput, ExpenseUncheckedUpdateWithoutVaultInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutVaultInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutExpensesInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutSourceVaultInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutSourceVaultInput, TransferUncheckedUpdateWithoutSourceVaultInput>
    create: XOR<TransferCreateWithoutSourceVaultInput, TransferUncheckedCreateWithoutSourceVaultInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutSourceVaultInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutSourceVaultInput, TransferUncheckedUpdateWithoutSourceVaultInput>
  }

  export type TransferUpdateManyWithWhereWithoutSourceVaultInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutSourceTransfersInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutTargetVaultInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutTargetVaultInput, TransferUncheckedUpdateWithoutTargetVaultInput>
    create: XOR<TransferCreateWithoutTargetVaultInput, TransferUncheckedCreateWithoutTargetVaultInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutTargetVaultInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutTargetVaultInput, TransferUncheckedUpdateWithoutTargetVaultInput>
  }

  export type TransferUpdateManyWithWhereWithoutTargetVaultInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutTargetTransfersInput>
  }

  export type DonationUpsertWithWhereUniqueWithoutTargetVaultInput = {
    where: DonationWhereUniqueInput
    update: XOR<DonationUpdateWithoutTargetVaultInput, DonationUncheckedUpdateWithoutTargetVaultInput>
    create: XOR<DonationCreateWithoutTargetVaultInput, DonationUncheckedCreateWithoutTargetVaultInput>
  }

  export type DonationUpdateWithWhereUniqueWithoutTargetVaultInput = {
    where: DonationWhereUniqueInput
    data: XOR<DonationUpdateWithoutTargetVaultInput, DonationUncheckedUpdateWithoutTargetVaultInput>
  }

  export type DonationUpdateManyWithWhereWithoutTargetVaultInput = {
    where: DonationScalarWhereInput
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyWithoutDonationsInput>
  }

  export type WithdrawalUpsertWithWhereUniqueWithoutSourceVaultInput = {
    where: WithdrawalWhereUniqueInput
    update: XOR<WithdrawalUpdateWithoutSourceVaultInput, WithdrawalUncheckedUpdateWithoutSourceVaultInput>
    create: XOR<WithdrawalCreateWithoutSourceVaultInput, WithdrawalUncheckedCreateWithoutSourceVaultInput>
  }

  export type WithdrawalUpdateWithWhereUniqueWithoutSourceVaultInput = {
    where: WithdrawalWhereUniqueInput
    data: XOR<WithdrawalUpdateWithoutSourceVaultInput, WithdrawalUncheckedUpdateWithoutSourceVaultInput>
  }

  export type WithdrawalUpdateManyWithWhereWithoutSourceVaultInput = {
    where: WithdrawalScalarWhereInput
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyWithoutWithdrawsInput>
  }

  export type RecurringDonationUpsertWithWhereUniqueWithoutSourceVaultInput = {
    where: RecurringDonationWhereUniqueInput
    update: XOR<RecurringDonationUpdateWithoutSourceVaultInput, RecurringDonationUncheckedUpdateWithoutSourceVaultInput>
    create: XOR<RecurringDonationCreateWithoutSourceVaultInput, RecurringDonationUncheckedCreateWithoutSourceVaultInput>
  }

  export type RecurringDonationUpdateWithWhereUniqueWithoutSourceVaultInput = {
    where: RecurringDonationWhereUniqueInput
    data: XOR<RecurringDonationUpdateWithoutSourceVaultInput, RecurringDonationUncheckedUpdateWithoutSourceVaultInput>
  }

  export type RecurringDonationUpdateManyWithWhereWithoutSourceVaultInput = {
    where: RecurringDonationScalarWhereInput
    data: XOR<RecurringDonationUpdateManyMutationInput, RecurringDonationUncheckedUpdateManyWithoutRecurringDonationsInput>
  }

  export type VaultCreateWithoutDonationsInput = {
    id?: string
    currency?: Currency
    amount?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutVaultsInput
    expenses?: ExpenseCreateNestedManyWithoutVaultInput
    sourceTransfers?: TransferCreateNestedManyWithoutSourceVaultInput
    targetTransfers?: TransferCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalCreateNestedManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultUncheckedCreateWithoutDonationsInput = {
    id?: string
    currency?: Currency
    amount?: number
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVaultInput
    sourceTransfers?: TransferUncheckedCreateNestedManyWithoutSourceVaultInput
    targetTransfers?: TransferUncheckedCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedCreateNestedManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultCreateOrConnectWithoutDonationsInput = {
    where: VaultWhereUniqueInput
    create: XOR<VaultCreateWithoutDonationsInput, VaultUncheckedCreateWithoutDonationsInput>
  }

  export type PersonCreateWithoutDonationInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    expenses?: ExpenseCreateNestedManyWithoutApprovedByInput
    documents?: DocumentCreateNestedManyWithoutOwnerInput
    transfers?: TransferCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutDonationInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutApprovedByInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterUncheckedCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorUncheckedCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutDonationInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutDonationInput, PersonUncheckedCreateWithoutDonationInput>
  }

  export type VaultUpsertWithoutDonationsInput = {
    update: XOR<VaultUpdateWithoutDonationsInput, VaultUncheckedUpdateWithoutDonationsInput>
    create: XOR<VaultCreateWithoutDonationsInput, VaultUncheckedCreateWithoutDonationsInput>
  }

  export type VaultUpdateWithoutDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutVaultsInput
    expenses?: ExpenseUpdateManyWithoutVaultInput
    sourceTransfers?: TransferUpdateManyWithoutSourceVaultInput
    targetTransfers?: TransferUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUpdateManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUpdateManyWithoutSourceVaultInput
  }

  export type VaultUncheckedUpdateWithoutDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutVaultInput
    sourceTransfers?: TransferUncheckedUpdateManyWithoutSourceVaultInput
    targetTransfers?: TransferUncheckedUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedUpdateManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutSourceVaultInput
  }

  export type PersonUpsertWithoutDonationInput = {
    update: XOR<PersonUpdateWithoutDonationInput, PersonUncheckedUpdateWithoutDonationInput>
    create: XOR<PersonCreateWithoutDonationInput, PersonUncheckedCreateWithoutDonationInput>
  }

  export type PersonUpdateWithoutDonationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutApprovedByInput
    documents?: DocumentUpdateManyWithoutOwnerInput
    transfers?: TransferUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUpdateManyWithoutApprovedByInput
    supporters?: SupporterUpdateManyWithoutPersonInput
    benefactors?: BenefactorUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutDonationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutApprovedByInput
    documents?: DocumentUncheckedUpdateManyWithoutOwnerInput
    transfers?: TransferUncheckedUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedUpdateManyWithoutApprovedByInput
    supporters?: SupporterUncheckedUpdateManyWithoutPersonInput
    benefactors?: BenefactorUncheckedUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutPersonInput
  }

  export type VaultCreateWithoutRecurringDonationsInput = {
    id?: string
    currency?: Currency
    amount?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutVaultsInput
    expenses?: ExpenseCreateNestedManyWithoutVaultInput
    sourceTransfers?: TransferCreateNestedManyWithoutSourceVaultInput
    targetTransfers?: TransferCreateNestedManyWithoutTargetVaultInput
    donations?: DonationCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultUncheckedCreateWithoutRecurringDonationsInput = {
    id?: string
    currency?: Currency
    amount?: number
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVaultInput
    sourceTransfers?: TransferUncheckedCreateNestedManyWithoutSourceVaultInput
    targetTransfers?: TransferUncheckedCreateNestedManyWithoutTargetVaultInput
    donations?: DonationUncheckedCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultCreateOrConnectWithoutRecurringDonationsInput = {
    where: VaultWhereUniqueInput
    create: XOR<VaultCreateWithoutRecurringDonationsInput, VaultUncheckedCreateWithoutRecurringDonationsInput>
  }

  export type PersonCreateWithoutRecurringDonationsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationCreateNestedManyWithoutPersonInput
    expenses?: ExpenseCreateNestedManyWithoutApprovedByInput
    documents?: DocumentCreateNestedManyWithoutOwnerInput
    transfers?: TransferCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutRecurringDonationsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationUncheckedCreateNestedManyWithoutPersonInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutApprovedByInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterUncheckedCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorUncheckedCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutRecurringDonationsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutRecurringDonationsInput, PersonUncheckedCreateWithoutRecurringDonationsInput>
  }

  export type VaultUpsertWithoutRecurringDonationsInput = {
    update: XOR<VaultUpdateWithoutRecurringDonationsInput, VaultUncheckedUpdateWithoutRecurringDonationsInput>
    create: XOR<VaultCreateWithoutRecurringDonationsInput, VaultUncheckedCreateWithoutRecurringDonationsInput>
  }

  export type VaultUpdateWithoutRecurringDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutVaultsInput
    expenses?: ExpenseUpdateManyWithoutVaultInput
    sourceTransfers?: TransferUpdateManyWithoutSourceVaultInput
    targetTransfers?: TransferUpdateManyWithoutTargetVaultInput
    donations?: DonationUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUpdateManyWithoutSourceVaultInput
  }

  export type VaultUncheckedUpdateWithoutRecurringDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutVaultInput
    sourceTransfers?: TransferUncheckedUpdateManyWithoutSourceVaultInput
    targetTransfers?: TransferUncheckedUpdateManyWithoutTargetVaultInput
    donations?: DonationUncheckedUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedUpdateManyWithoutSourceVaultInput
  }

  export type PersonUpsertWithoutRecurringDonationsInput = {
    update: XOR<PersonUpdateWithoutRecurringDonationsInput, PersonUncheckedUpdateWithoutRecurringDonationsInput>
    create: XOR<PersonCreateWithoutRecurringDonationsInput, PersonUncheckedCreateWithoutRecurringDonationsInput>
  }

  export type PersonUpdateWithoutRecurringDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUpdateManyWithoutPersonInput
    expenses?: ExpenseUpdateManyWithoutApprovedByInput
    documents?: DocumentUpdateManyWithoutOwnerInput
    transfers?: TransferUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUpdateManyWithoutApprovedByInput
    supporters?: SupporterUpdateManyWithoutPersonInput
    benefactors?: BenefactorUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutRecurringDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUncheckedUpdateManyWithoutPersonInput
    expenses?: ExpenseUncheckedUpdateManyWithoutApprovedByInput
    documents?: DocumentUncheckedUpdateManyWithoutOwnerInput
    transfers?: TransferUncheckedUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedUpdateManyWithoutApprovedByInput
    supporters?: SupporterUncheckedUpdateManyWithoutPersonInput
    benefactors?: BenefactorUncheckedUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedUpdateManyWithoutPersonInput
  }

  export type PersonCreateWithoutTransfersInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationCreateNestedManyWithoutPersonInput
    expenses?: ExpenseCreateNestedManyWithoutApprovedByInput
    documents?: DocumentCreateNestedManyWithoutOwnerInput
    campaigns?: CampaignCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutTransfersInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationUncheckedCreateNestedManyWithoutPersonInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutApprovedByInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterUncheckedCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorUncheckedCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutTransfersInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutTransfersInput, PersonUncheckedCreateWithoutTransfersInput>
  }

  export type VaultCreateWithoutSourceTransfersInput = {
    id?: string
    currency?: Currency
    amount?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutVaultsInput
    expenses?: ExpenseCreateNestedManyWithoutVaultInput
    targetTransfers?: TransferCreateNestedManyWithoutTargetVaultInput
    donations?: DonationCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalCreateNestedManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultUncheckedCreateWithoutSourceTransfersInput = {
    id?: string
    currency?: Currency
    amount?: number
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVaultInput
    targetTransfers?: TransferUncheckedCreateNestedManyWithoutTargetVaultInput
    donations?: DonationUncheckedCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedCreateNestedManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultCreateOrConnectWithoutSourceTransfersInput = {
    where: VaultWhereUniqueInput
    create: XOR<VaultCreateWithoutSourceTransfersInput, VaultUncheckedCreateWithoutSourceTransfersInput>
  }

  export type CampaignCreateWithoutOutgoingTransfersInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutCampaignsInput
    beneficiaries: BeneficiaryCreateNestedOneWithoutCampaignsInput
    campaignTypes: CampaignTypeCreateNestedOneWithoutCampaignsInput
    vaults?: VaultCreateNestedManyWithoutCampaignInput
    incomingTransfers?: TransferCreateNestedManyWithoutTargetCampaignInput
    withdrawals?: WithdrawalCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedCreateWithoutOutgoingTransfersInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    beneficiaryId: string
    campaignTypeId: string
    approvedById?: string | null
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    vaults?: VaultUncheckedCreateNestedManyWithoutCampaignInput
    incomingTransfers?: TransferUncheckedCreateNestedManyWithoutTargetCampaignInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignCreateOrConnectWithoutOutgoingTransfersInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutOutgoingTransfersInput, CampaignUncheckedCreateWithoutOutgoingTransfersInput>
  }

  export type VaultCreateWithoutTargetTransfersInput = {
    id?: string
    currency?: Currency
    amount?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutVaultsInput
    expenses?: ExpenseCreateNestedManyWithoutVaultInput
    sourceTransfers?: TransferCreateNestedManyWithoutSourceVaultInput
    donations?: DonationCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalCreateNestedManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultUncheckedCreateWithoutTargetTransfersInput = {
    id?: string
    currency?: Currency
    amount?: number
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVaultInput
    sourceTransfers?: TransferUncheckedCreateNestedManyWithoutSourceVaultInput
    donations?: DonationUncheckedCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedCreateNestedManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultCreateOrConnectWithoutTargetTransfersInput = {
    where: VaultWhereUniqueInput
    create: XOR<VaultCreateWithoutTargetTransfersInput, VaultUncheckedCreateWithoutTargetTransfersInput>
  }

  export type CampaignCreateWithoutIncomingTransfersInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutCampaignsInput
    beneficiaries: BeneficiaryCreateNestedOneWithoutCampaignsInput
    campaignTypes: CampaignTypeCreateNestedOneWithoutCampaignsInput
    vaults?: VaultCreateNestedManyWithoutCampaignInput
    outgoingTransfers?: TransferCreateNestedManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedCreateWithoutIncomingTransfersInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    beneficiaryId: string
    campaignTypeId: string
    approvedById?: string | null
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    vaults?: VaultUncheckedCreateNestedManyWithoutCampaignInput
    outgoingTransfers?: TransferUncheckedCreateNestedManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignCreateOrConnectWithoutIncomingTransfersInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutIncomingTransfersInput, CampaignUncheckedCreateWithoutIncomingTransfersInput>
  }

  export type PersonUpsertWithoutTransfersInput = {
    update: XOR<PersonUpdateWithoutTransfersInput, PersonUncheckedUpdateWithoutTransfersInput>
    create: XOR<PersonCreateWithoutTransfersInput, PersonUncheckedCreateWithoutTransfersInput>
  }

  export type PersonUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUpdateManyWithoutPersonInput
    expenses?: ExpenseUpdateManyWithoutApprovedByInput
    documents?: DocumentUpdateManyWithoutOwnerInput
    campaigns?: CampaignUpdateManyWithoutApprovedByInput
    supporters?: SupporterUpdateManyWithoutPersonInput
    benefactors?: BenefactorUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUncheckedUpdateManyWithoutPersonInput
    expenses?: ExpenseUncheckedUpdateManyWithoutApprovedByInput
    documents?: DocumentUncheckedUpdateManyWithoutOwnerInput
    campaigns?: CampaignUncheckedUpdateManyWithoutApprovedByInput
    supporters?: SupporterUncheckedUpdateManyWithoutPersonInput
    benefactors?: BenefactorUncheckedUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutPersonInput
  }

  export type VaultUpsertWithoutSourceTransfersInput = {
    update: XOR<VaultUpdateWithoutSourceTransfersInput, VaultUncheckedUpdateWithoutSourceTransfersInput>
    create: XOR<VaultCreateWithoutSourceTransfersInput, VaultUncheckedCreateWithoutSourceTransfersInput>
  }

  export type VaultUpdateWithoutSourceTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutVaultsInput
    expenses?: ExpenseUpdateManyWithoutVaultInput
    targetTransfers?: TransferUpdateManyWithoutTargetVaultInput
    donations?: DonationUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUpdateManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUpdateManyWithoutSourceVaultInput
  }

  export type VaultUncheckedUpdateWithoutSourceTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutVaultInput
    targetTransfers?: TransferUncheckedUpdateManyWithoutTargetVaultInput
    donations?: DonationUncheckedUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedUpdateManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutSourceVaultInput
  }

  export type CampaignUpsertWithoutOutgoingTransfersInput = {
    update: XOR<CampaignUpdateWithoutOutgoingTransfersInput, CampaignUncheckedUpdateWithoutOutgoingTransfersInput>
    create: XOR<CampaignCreateWithoutOutgoingTransfersInput, CampaignUncheckedCreateWithoutOutgoingTransfersInput>
  }

  export type CampaignUpdateWithoutOutgoingTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutCampaignsInput
    beneficiaries?: BeneficiaryUpdateOneRequiredWithoutCampaignsInput
    campaignTypes?: CampaignTypeUpdateOneRequiredWithoutCampaignsInput
    vaults?: VaultUpdateManyWithoutCampaignInput
    incomingTransfers?: TransferUpdateManyWithoutTargetCampaignInput
    withdrawals?: WithdrawalUpdateManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedUpdateWithoutOutgoingTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    beneficiaryId?: StringFieldUpdateOperationsInput | string
    campaignTypeId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vaults?: VaultUncheckedUpdateManyWithoutCampaignInput
    incomingTransfers?: TransferUncheckedUpdateManyWithoutTargetCampaignInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutSourceCampaignInput
  }

  export type VaultUpsertWithoutTargetTransfersInput = {
    update: XOR<VaultUpdateWithoutTargetTransfersInput, VaultUncheckedUpdateWithoutTargetTransfersInput>
    create: XOR<VaultCreateWithoutTargetTransfersInput, VaultUncheckedCreateWithoutTargetTransfersInput>
  }

  export type VaultUpdateWithoutTargetTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutVaultsInput
    expenses?: ExpenseUpdateManyWithoutVaultInput
    sourceTransfers?: TransferUpdateManyWithoutSourceVaultInput
    donations?: DonationUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUpdateManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUpdateManyWithoutSourceVaultInput
  }

  export type VaultUncheckedUpdateWithoutTargetTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutVaultInput
    sourceTransfers?: TransferUncheckedUpdateManyWithoutSourceVaultInput
    donations?: DonationUncheckedUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedUpdateManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutSourceVaultInput
  }

  export type CampaignUpsertWithoutIncomingTransfersInput = {
    update: XOR<CampaignUpdateWithoutIncomingTransfersInput, CampaignUncheckedUpdateWithoutIncomingTransfersInput>
    create: XOR<CampaignCreateWithoutIncomingTransfersInput, CampaignUncheckedCreateWithoutIncomingTransfersInput>
  }

  export type CampaignUpdateWithoutIncomingTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutCampaignsInput
    beneficiaries?: BeneficiaryUpdateOneRequiredWithoutCampaignsInput
    campaignTypes?: CampaignTypeUpdateOneRequiredWithoutCampaignsInput
    vaults?: VaultUpdateManyWithoutCampaignInput
    outgoingTransfers?: TransferUpdateManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUpdateManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedUpdateWithoutIncomingTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    beneficiaryId?: StringFieldUpdateOperationsInput | string
    campaignTypeId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vaults?: VaultUncheckedUpdateManyWithoutCampaignInput
    outgoingTransfers?: TransferUncheckedUpdateManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutSourceCampaignInput
  }

  export type PersonCreateWithoutWithdrawalsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationCreateNestedManyWithoutPersonInput
    expenses?: ExpenseCreateNestedManyWithoutApprovedByInput
    documents?: DocumentCreateNestedManyWithoutOwnerInput
    transfers?: TransferCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorCreateNestedManyWithoutPersonInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutWithdrawalsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationUncheckedCreateNestedManyWithoutPersonInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutApprovedByInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterUncheckedCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorUncheckedCreateNestedManyWithoutPersonInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutWithdrawalsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutWithdrawalsInput, PersonUncheckedCreateWithoutWithdrawalsInput>
  }

  export type VaultCreateWithoutWithdrawsInput = {
    id?: string
    currency?: Currency
    amount?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutVaultsInput
    expenses?: ExpenseCreateNestedManyWithoutVaultInput
    sourceTransfers?: TransferCreateNestedManyWithoutSourceVaultInput
    targetTransfers?: TransferCreateNestedManyWithoutTargetVaultInput
    donations?: DonationCreateNestedManyWithoutTargetVaultInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultUncheckedCreateWithoutWithdrawsInput = {
    id?: string
    currency?: Currency
    amount?: number
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutVaultInput
    sourceTransfers?: TransferUncheckedCreateNestedManyWithoutSourceVaultInput
    targetTransfers?: TransferUncheckedCreateNestedManyWithoutTargetVaultInput
    donations?: DonationUncheckedCreateNestedManyWithoutTargetVaultInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultCreateOrConnectWithoutWithdrawsInput = {
    where: VaultWhereUniqueInput
    create: XOR<VaultCreateWithoutWithdrawsInput, VaultUncheckedCreateWithoutWithdrawsInput>
  }

  export type CampaignCreateWithoutWithdrawalsInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutCampaignsInput
    beneficiaries: BeneficiaryCreateNestedOneWithoutCampaignsInput
    campaignTypes: CampaignTypeCreateNestedOneWithoutCampaignsInput
    vaults?: VaultCreateNestedManyWithoutCampaignInput
    incomingTransfers?: TransferCreateNestedManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedCreateWithoutWithdrawalsInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    beneficiaryId: string
    campaignTypeId: string
    approvedById?: string | null
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    vaults?: VaultUncheckedCreateNestedManyWithoutCampaignInput
    incomingTransfers?: TransferUncheckedCreateNestedManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUncheckedCreateNestedManyWithoutSourceCampaignInput
  }

  export type CampaignCreateOrConnectWithoutWithdrawalsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutWithdrawalsInput, CampaignUncheckedCreateWithoutWithdrawalsInput>
  }

  export type BankAccountCreateWithoutWithdrawsInput = {
    id?: string
    status?: BankAccountStatus
    ibanNumber: string
    accountHolderName: string
    accountHolderType: AccountHolderType
    bankName?: string | null
    bankIdCode?: string | null
    fingerprint?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BankAccountUncheckedCreateWithoutWithdrawsInput = {
    id?: string
    status?: BankAccountStatus
    ibanNumber: string
    accountHolderName: string
    accountHolderType: AccountHolderType
    bankName?: string | null
    bankIdCode?: string | null
    fingerprint?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BankAccountCreateOrConnectWithoutWithdrawsInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutWithdrawsInput, BankAccountUncheckedCreateWithoutWithdrawsInput>
  }

  export type PersonUpsertWithoutWithdrawalsInput = {
    update: XOR<PersonUpdateWithoutWithdrawalsInput, PersonUncheckedUpdateWithoutWithdrawalsInput>
    create: XOR<PersonCreateWithoutWithdrawalsInput, PersonUncheckedCreateWithoutWithdrawalsInput>
  }

  export type PersonUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUpdateManyWithoutPersonInput
    expenses?: ExpenseUpdateManyWithoutApprovedByInput
    documents?: DocumentUpdateManyWithoutOwnerInput
    transfers?: TransferUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUpdateManyWithoutApprovedByInput
    supporters?: SupporterUpdateManyWithoutPersonInput
    benefactors?: BenefactorUpdateManyWithoutPersonInput
    beneficiaries?: BeneficiaryUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUncheckedUpdateManyWithoutPersonInput
    expenses?: ExpenseUncheckedUpdateManyWithoutApprovedByInput
    documents?: DocumentUncheckedUpdateManyWithoutOwnerInput
    transfers?: TransferUncheckedUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedUpdateManyWithoutApprovedByInput
    supporters?: SupporterUncheckedUpdateManyWithoutPersonInput
    benefactors?: BenefactorUncheckedUpdateManyWithoutPersonInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutPersonInput
  }

  export type VaultUpsertWithoutWithdrawsInput = {
    update: XOR<VaultUpdateWithoutWithdrawsInput, VaultUncheckedUpdateWithoutWithdrawsInput>
    create: XOR<VaultCreateWithoutWithdrawsInput, VaultUncheckedCreateWithoutWithdrawsInput>
  }

  export type VaultUpdateWithoutWithdrawsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutVaultsInput
    expenses?: ExpenseUpdateManyWithoutVaultInput
    sourceTransfers?: TransferUpdateManyWithoutSourceVaultInput
    targetTransfers?: TransferUpdateManyWithoutTargetVaultInput
    donations?: DonationUpdateManyWithoutTargetVaultInput
    recurringDonations?: RecurringDonationUpdateManyWithoutSourceVaultInput
  }

  export type VaultUncheckedUpdateWithoutWithdrawsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutVaultInput
    sourceTransfers?: TransferUncheckedUpdateManyWithoutSourceVaultInput
    targetTransfers?: TransferUncheckedUpdateManyWithoutTargetVaultInput
    donations?: DonationUncheckedUpdateManyWithoutTargetVaultInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutSourceVaultInput
  }

  export type CampaignUpsertWithoutWithdrawalsInput = {
    update: XOR<CampaignUpdateWithoutWithdrawalsInput, CampaignUncheckedUpdateWithoutWithdrawalsInput>
    create: XOR<CampaignCreateWithoutWithdrawalsInput, CampaignUncheckedCreateWithoutWithdrawalsInput>
  }

  export type CampaignUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutCampaignsInput
    beneficiaries?: BeneficiaryUpdateOneRequiredWithoutCampaignsInput
    campaignTypes?: CampaignTypeUpdateOneRequiredWithoutCampaignsInput
    vaults?: VaultUpdateManyWithoutCampaignInput
    incomingTransfers?: TransferUpdateManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUpdateManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedUpdateWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    beneficiaryId?: StringFieldUpdateOperationsInput | string
    campaignTypeId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vaults?: VaultUncheckedUpdateManyWithoutCampaignInput
    incomingTransfers?: TransferUncheckedUpdateManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUncheckedUpdateManyWithoutSourceCampaignInput
  }

  export type BankAccountUpsertWithoutWithdrawsInput = {
    update: XOR<BankAccountUpdateWithoutWithdrawsInput, BankAccountUncheckedUpdateWithoutWithdrawsInput>
    create: XOR<BankAccountCreateWithoutWithdrawsInput, BankAccountUncheckedCreateWithoutWithdrawsInput>
  }

  export type BankAccountUpdateWithoutWithdrawsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBankAccountStatusFieldUpdateOperationsInput | BankAccountStatus
    ibanNumber?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    accountHolderType?: EnumAccountHolderTypeFieldUpdateOperationsInput | AccountHolderType
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankIdCode?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BankAccountUncheckedUpdateWithoutWithdrawsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBankAccountStatusFieldUpdateOperationsInput | BankAccountStatus
    ibanNumber?: StringFieldUpdateOperationsInput | string
    accountHolderName?: StringFieldUpdateOperationsInput | string
    accountHolderType?: EnumAccountHolderTypeFieldUpdateOperationsInput | AccountHolderType
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankIdCode?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalCreateWithoutBankAccountInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    approvedBy?: PersonCreateNestedOneWithoutWithdrawalsInput
    sourceVault: VaultCreateNestedOneWithoutWithdrawsInput
    sourceCampaign: CampaignCreateNestedOneWithoutWithdrawalsInput
  }

  export type WithdrawalUncheckedCreateWithoutBankAccountInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    documentId?: string | null
    approvedById?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalCreateOrConnectWithoutBankAccountInput = {
    where: WithdrawalWhereUniqueInput
    create: XOR<WithdrawalCreateWithoutBankAccountInput, WithdrawalUncheckedCreateWithoutBankAccountInput>
  }

  export type WithdrawalCreateManyBankAccountInputEnvelope = {
    data: Enumerable<WithdrawalCreateManyBankAccountInput>
    skipDuplicates?: boolean
  }

  export type WithdrawalUpsertWithWhereUniqueWithoutBankAccountInput = {
    where: WithdrawalWhereUniqueInput
    update: XOR<WithdrawalUpdateWithoutBankAccountInput, WithdrawalUncheckedUpdateWithoutBankAccountInput>
    create: XOR<WithdrawalCreateWithoutBankAccountInput, WithdrawalUncheckedCreateWithoutBankAccountInput>
  }

  export type WithdrawalUpdateWithWhereUniqueWithoutBankAccountInput = {
    where: WithdrawalWhereUniqueInput
    data: XOR<WithdrawalUpdateWithoutBankAccountInput, WithdrawalUncheckedUpdateWithoutBankAccountInput>
  }

  export type WithdrawalUpdateManyWithWhereWithoutBankAccountInput = {
    where: WithdrawalScalarWhereInput
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyWithoutWithdrawsInput>
  }

  export type VaultCreateWithoutExpensesInput = {
    id?: string
    currency?: Currency
    amount?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutVaultsInput
    sourceTransfers?: TransferCreateNestedManyWithoutSourceVaultInput
    targetTransfers?: TransferCreateNestedManyWithoutTargetVaultInput
    donations?: DonationCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalCreateNestedManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultUncheckedCreateWithoutExpensesInput = {
    id?: string
    currency?: Currency
    amount?: number
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    sourceTransfers?: TransferUncheckedCreateNestedManyWithoutSourceVaultInput
    targetTransfers?: TransferUncheckedCreateNestedManyWithoutTargetVaultInput
    donations?: DonationUncheckedCreateNestedManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedCreateNestedManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutSourceVaultInput
  }

  export type VaultCreateOrConnectWithoutExpensesInput = {
    where: VaultWhereUniqueInput
    create: XOR<VaultCreateWithoutExpensesInput, VaultUncheckedCreateWithoutExpensesInput>
  }

  export type PersonCreateWithoutExpensesInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationCreateNestedManyWithoutPersonInput
    documents?: DocumentCreateNestedManyWithoutOwnerInput
    transfers?: TransferCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutExpensesInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationUncheckedCreateNestedManyWithoutPersonInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOwnerInput
    transfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterUncheckedCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorUncheckedCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutExpensesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutExpensesInput, PersonUncheckedCreateWithoutExpensesInput>
  }

  export type DocumentCreateWithoutExpensesInput = {
    id?: string
    type: DocumentType
    name: string
    filename: string
    filetype?: string | null
    description?: string | null
    sourceUrl: string
    owner: PersonCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutExpensesInput = {
    id?: string
    type: DocumentType
    name: string
    filename: string
    filetype?: string | null
    description?: string | null
    sourceUrl: string
    ownerId: string
  }

  export type DocumentCreateOrConnectWithoutExpensesInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutExpensesInput, DocumentUncheckedCreateWithoutExpensesInput>
  }

  export type VaultUpsertWithoutExpensesInput = {
    update: XOR<VaultUpdateWithoutExpensesInput, VaultUncheckedUpdateWithoutExpensesInput>
    create: XOR<VaultCreateWithoutExpensesInput, VaultUncheckedCreateWithoutExpensesInput>
  }

  export type VaultUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutVaultsInput
    sourceTransfers?: TransferUpdateManyWithoutSourceVaultInput
    targetTransfers?: TransferUpdateManyWithoutTargetVaultInput
    donations?: DonationUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUpdateManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUpdateManyWithoutSourceVaultInput
  }

  export type VaultUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceTransfers?: TransferUncheckedUpdateManyWithoutSourceVaultInput
    targetTransfers?: TransferUncheckedUpdateManyWithoutTargetVaultInput
    donations?: DonationUncheckedUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedUpdateManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutSourceVaultInput
  }

  export type PersonUpsertWithoutExpensesInput = {
    update: XOR<PersonUpdateWithoutExpensesInput, PersonUncheckedUpdateWithoutExpensesInput>
    create: XOR<PersonCreateWithoutExpensesInput, PersonUncheckedCreateWithoutExpensesInput>
  }

  export type PersonUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUpdateManyWithoutPersonInput
    documents?: DocumentUpdateManyWithoutOwnerInput
    transfers?: TransferUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUpdateManyWithoutApprovedByInput
    supporters?: SupporterUpdateManyWithoutPersonInput
    benefactors?: BenefactorUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUncheckedUpdateManyWithoutPersonInput
    documents?: DocumentUncheckedUpdateManyWithoutOwnerInput
    transfers?: TransferUncheckedUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedUpdateManyWithoutApprovedByInput
    supporters?: SupporterUncheckedUpdateManyWithoutPersonInput
    benefactors?: BenefactorUncheckedUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutPersonInput
  }

  export type DocumentUpsertWithoutExpensesInput = {
    update: XOR<DocumentUpdateWithoutExpensesInput, DocumentUncheckedUpdateWithoutExpensesInput>
    create: XOR<DocumentCreateWithoutExpensesInput, DocumentUncheckedCreateWithoutExpensesInput>
  }

  export type DocumentUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    filetype?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: StringFieldUpdateOperationsInput | string
    owner?: PersonUpdateOneRequiredWithoutDocumentsInput
  }

  export type DocumentUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    filetype?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonCreateWithoutDocumentsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationCreateNestedManyWithoutPersonInput
    expenses?: ExpenseCreateNestedManyWithoutApprovedByInput
    transfers?: TransferCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutDocumentsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    emailConfirmed?: boolean | null
    phone?: string | null
    company?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    newsletter?: boolean | null
    address?: string | null
    birthday?: Date | string | null
    personalNumber?: string | null
    keycloakId?: string | null
    stripeCustomerId?: string | null
    Donation?: DonationUncheckedCreateNestedManyWithoutPersonInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutApprovedByInput
    transfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutApprovedByInput
    supporters?: SupporterUncheckedCreateNestedManyWithoutPersonInput
    benefactors?: BenefactorUncheckedCreateNestedManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedCreateNestedManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedCreateNestedManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedCreateNestedManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedCreateNestedManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutDocumentsInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutDocumentsInput, PersonUncheckedCreateWithoutDocumentsInput>
  }

  export type ExpenseCreateWithoutDocumentInput = {
    id?: string
    type: ExpenseType
    currency?: Currency
    amount?: number
    description?: string | null
    vault: VaultCreateNestedOneWithoutExpensesInput
    approvedBy?: PersonCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutDocumentInput = {
    id?: string
    type: ExpenseType
    currency?: Currency
    amount?: number
    description?: string | null
    vaultId: string
    approvedById?: string | null
  }

  export type ExpenseCreateOrConnectWithoutDocumentInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutDocumentInput, ExpenseUncheckedCreateWithoutDocumentInput>
  }

  export type ExpenseCreateManyDocumentInputEnvelope = {
    data: Enumerable<ExpenseCreateManyDocumentInput>
    skipDuplicates?: boolean
  }

  export type PersonUpsertWithoutDocumentsInput = {
    update: XOR<PersonUpdateWithoutDocumentsInput, PersonUncheckedUpdateWithoutDocumentsInput>
    create: XOR<PersonCreateWithoutDocumentsInput, PersonUncheckedCreateWithoutDocumentsInput>
  }

  export type PersonUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUpdateManyWithoutPersonInput
    expenses?: ExpenseUpdateManyWithoutApprovedByInput
    transfers?: TransferUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUpdateManyWithoutApprovedByInput
    supporters?: SupporterUpdateManyWithoutPersonInput
    benefactors?: BenefactorUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUpdateManyWithoutPersonInput
  }

  export type PersonUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    Donation?: DonationUncheckedUpdateManyWithoutPersonInput
    expenses?: ExpenseUncheckedUpdateManyWithoutApprovedByInput
    transfers?: TransferUncheckedUpdateManyWithoutApprovedByInput
    campaigns?: CampaignUncheckedUpdateManyWithoutApprovedByInput
    supporters?: SupporterUncheckedUpdateManyWithoutPersonInput
    benefactors?: BenefactorUncheckedUpdateManyWithoutPersonInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutApprovedByInput
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutPersonInput
    infoRequests?: InfoRequestUncheckedUpdateManyWithoutPersonInput
    coordinators?: CoordinatorUncheckedUpdateManyWithoutPersonInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutPersonInput
  }

  export type ExpenseUpsertWithWhereUniqueWithoutDocumentInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutDocumentInput, ExpenseUncheckedUpdateWithoutDocumentInput>
    create: XOR<ExpenseCreateWithoutDocumentInput, ExpenseUncheckedCreateWithoutDocumentInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutDocumentInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutDocumentInput, ExpenseUncheckedUpdateWithoutDocumentInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutDocumentInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutExpensesInput>
  }

  export type DonationCreateManyPersonInput = {
    id?: string
    type: DonationType
    status?: DonationStatus
    provider?: PaymentProvider
    currency?: Currency
    amount?: number
    targetVaultId: string
    extCustomerId: string
    extPaymentIntentId: string
    extPaymentMethodId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ExpenseCreateManyApprovedByInput = {
    id?: string
    type: ExpenseType
    currency?: Currency
    amount?: number
    description?: string | null
    vaultId: string
    documentId?: string | null
  }

  export type DocumentCreateManyOwnerInput = {
    id?: string
    type: DocumentType
    name: string
    filename: string
    filetype?: string | null
    description?: string | null
    sourceUrl: string
  }

  export type TransferCreateManyApprovedByInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    targetVaultId: string
    targetCampaignId: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CampaignCreateManyApprovedByInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    beneficiaryId: string
    campaignTypeId: string
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type SupporterCreateManyPersonInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    comment?: string | null
    associationMember?: boolean
    benefactorCampaign?: boolean
    benefactorPlatform?: boolean
    companyOtherText?: string | null
    companySponsor?: boolean
    companyVolunteer?: boolean
    partnerBussiness?: boolean
    partnerNpo?: boolean
    partnerOtherText?: string | null
    roleAssociationMember?: boolean
    roleBenefactor?: boolean
    roleCompany?: boolean
    rolePartner?: boolean
    roleVolunteer?: boolean
    volunteerBackend?: boolean
    volunteerDesigner?: boolean
    volunteerDevOps?: boolean
    volunteerFinancesAndAccounts?: boolean
    volunteerFrontend?: boolean
    volunteerLawyer?: boolean
    volunteerMarketing?: boolean
    volunteerProjectManager?: boolean
    volunteerQa?: boolean
    volunteerSecurity?: boolean
  }

  export type BenefactorCreateManyPersonInput = {
    id?: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalCreateManyApprovedByInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    bankAccountId: string
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type BeneficiaryCreateManyPersonInput = {
    id?: string
    type: BeneficiaryType
    companyId?: string | null
    coordinatorId: string
    countryCode: string
    cityId: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
  }

  export type InfoRequestCreateManyPersonInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type CoordinatorCreateManyPersonInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RecurringDonationCreateManyPersonInput = {
    id?: string
    status: RecurringDonationStatus
    vaultId: string
    currency?: Currency
    amount?: number
    extSubscriptionId: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type DonationUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDonationTypeFieldUpdateOperationsInput | DonationType
    status?: EnumDonationStatusFieldUpdateOperationsInput | DonationStatus
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | PaymentProvider
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extCustomerId?: StringFieldUpdateOperationsInput | string
    extPaymentIntentId?: StringFieldUpdateOperationsInput | string
    extPaymentMethodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetVault?: VaultUpdateOneRequiredWithoutDonationsInput
  }

  export type DonationUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDonationTypeFieldUpdateOperationsInput | DonationType
    status?: EnumDonationStatusFieldUpdateOperationsInput | DonationStatus
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | PaymentProvider
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    targetVaultId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: StringFieldUpdateOperationsInput | string
    extPaymentIntentId?: StringFieldUpdateOperationsInput | string
    extPaymentMethodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DonationUncheckedUpdateManyWithoutDonationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDonationTypeFieldUpdateOperationsInput | DonationType
    status?: EnumDonationStatusFieldUpdateOperationsInput | DonationStatus
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | PaymentProvider
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    targetVaultId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: StringFieldUpdateOperationsInput | string
    extPaymentIntentId?: StringFieldUpdateOperationsInput | string
    extPaymentMethodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExpenseUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | ExpenseType
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vault?: VaultUpdateOneRequiredWithoutExpensesInput
    document?: DocumentUpdateOneWithoutExpensesInput
  }

  export type ExpenseUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | ExpenseType
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vaultId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUncheckedUpdateManyWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | ExpenseType
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vaultId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    filetype?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: StringFieldUpdateOperationsInput | string
    expenses?: ExpenseUpdateManyWithoutDocumentInput
  }

  export type DocumentUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    filetype?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: StringFieldUpdateOperationsInput | string
    expenses?: ExpenseUncheckedUpdateManyWithoutDocumentInput
  }

  export type DocumentUncheckedUpdateManyWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    filetype?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: StringFieldUpdateOperationsInput | string
  }

  export type TransferUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceVault?: VaultUpdateOneRequiredWithoutSourceTransfersInput
    sourceCampaign?: CampaignUpdateOneRequiredWithoutOutgoingTransfersInput
    targetVault?: VaultUpdateOneRequiredWithoutTargetTransfersInput
    targetCampaign?: CampaignUpdateOneRequiredWithoutIncomingTransfersInput
  }

  export type TransferUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: StringFieldUpdateOperationsInput | string
    targetCampaignId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUncheckedUpdateManyWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: StringFieldUpdateOperationsInput | string
    targetCampaignId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficiaries?: BeneficiaryUpdateOneRequiredWithoutCampaignsInput
    campaignTypes?: CampaignTypeUpdateOneRequiredWithoutCampaignsInput
    vaults?: VaultUpdateManyWithoutCampaignInput
    incomingTransfers?: TransferUpdateManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUpdateManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUpdateManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    beneficiaryId?: StringFieldUpdateOperationsInput | string
    campaignTypeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vaults?: VaultUncheckedUpdateManyWithoutCampaignInput
    incomingTransfers?: TransferUncheckedUpdateManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUncheckedUpdateManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedUpdateManyWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    beneficiaryId?: StringFieldUpdateOperationsInput | string
    campaignTypeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupporterUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    associationMember?: BoolFieldUpdateOperationsInput | boolean
    benefactorCampaign?: BoolFieldUpdateOperationsInput | boolean
    benefactorPlatform?: BoolFieldUpdateOperationsInput | boolean
    companyOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    companySponsor?: BoolFieldUpdateOperationsInput | boolean
    companyVolunteer?: BoolFieldUpdateOperationsInput | boolean
    partnerBussiness?: BoolFieldUpdateOperationsInput | boolean
    partnerNpo?: BoolFieldUpdateOperationsInput | boolean
    partnerOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    roleAssociationMember?: BoolFieldUpdateOperationsInput | boolean
    roleBenefactor?: BoolFieldUpdateOperationsInput | boolean
    roleCompany?: BoolFieldUpdateOperationsInput | boolean
    rolePartner?: BoolFieldUpdateOperationsInput | boolean
    roleVolunteer?: BoolFieldUpdateOperationsInput | boolean
    volunteerBackend?: BoolFieldUpdateOperationsInput | boolean
    volunteerDesigner?: BoolFieldUpdateOperationsInput | boolean
    volunteerDevOps?: BoolFieldUpdateOperationsInput | boolean
    volunteerFinancesAndAccounts?: BoolFieldUpdateOperationsInput | boolean
    volunteerFrontend?: BoolFieldUpdateOperationsInput | boolean
    volunteerLawyer?: BoolFieldUpdateOperationsInput | boolean
    volunteerMarketing?: BoolFieldUpdateOperationsInput | boolean
    volunteerProjectManager?: BoolFieldUpdateOperationsInput | boolean
    volunteerQa?: BoolFieldUpdateOperationsInput | boolean
    volunteerSecurity?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SupporterUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    associationMember?: BoolFieldUpdateOperationsInput | boolean
    benefactorCampaign?: BoolFieldUpdateOperationsInput | boolean
    benefactorPlatform?: BoolFieldUpdateOperationsInput | boolean
    companyOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    companySponsor?: BoolFieldUpdateOperationsInput | boolean
    companyVolunteer?: BoolFieldUpdateOperationsInput | boolean
    partnerBussiness?: BoolFieldUpdateOperationsInput | boolean
    partnerNpo?: BoolFieldUpdateOperationsInput | boolean
    partnerOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    roleAssociationMember?: BoolFieldUpdateOperationsInput | boolean
    roleBenefactor?: BoolFieldUpdateOperationsInput | boolean
    roleCompany?: BoolFieldUpdateOperationsInput | boolean
    rolePartner?: BoolFieldUpdateOperationsInput | boolean
    roleVolunteer?: BoolFieldUpdateOperationsInput | boolean
    volunteerBackend?: BoolFieldUpdateOperationsInput | boolean
    volunteerDesigner?: BoolFieldUpdateOperationsInput | boolean
    volunteerDevOps?: BoolFieldUpdateOperationsInput | boolean
    volunteerFinancesAndAccounts?: BoolFieldUpdateOperationsInput | boolean
    volunteerFrontend?: BoolFieldUpdateOperationsInput | boolean
    volunteerLawyer?: BoolFieldUpdateOperationsInput | boolean
    volunteerMarketing?: BoolFieldUpdateOperationsInput | boolean
    volunteerProjectManager?: BoolFieldUpdateOperationsInput | boolean
    volunteerQa?: BoolFieldUpdateOperationsInput | boolean
    volunteerSecurity?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SupporterUncheckedUpdateManyWithoutSupportersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    associationMember?: BoolFieldUpdateOperationsInput | boolean
    benefactorCampaign?: BoolFieldUpdateOperationsInput | boolean
    benefactorPlatform?: BoolFieldUpdateOperationsInput | boolean
    companyOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    companySponsor?: BoolFieldUpdateOperationsInput | boolean
    companyVolunteer?: BoolFieldUpdateOperationsInput | boolean
    partnerBussiness?: BoolFieldUpdateOperationsInput | boolean
    partnerNpo?: BoolFieldUpdateOperationsInput | boolean
    partnerOtherText?: NullableStringFieldUpdateOperationsInput | string | null
    roleAssociationMember?: BoolFieldUpdateOperationsInput | boolean
    roleBenefactor?: BoolFieldUpdateOperationsInput | boolean
    roleCompany?: BoolFieldUpdateOperationsInput | boolean
    rolePartner?: BoolFieldUpdateOperationsInput | boolean
    roleVolunteer?: BoolFieldUpdateOperationsInput | boolean
    volunteerBackend?: BoolFieldUpdateOperationsInput | boolean
    volunteerDesigner?: BoolFieldUpdateOperationsInput | boolean
    volunteerDevOps?: BoolFieldUpdateOperationsInput | boolean
    volunteerFinancesAndAccounts?: BoolFieldUpdateOperationsInput | boolean
    volunteerFrontend?: BoolFieldUpdateOperationsInput | boolean
    volunteerLawyer?: BoolFieldUpdateOperationsInput | boolean
    volunteerMarketing?: BoolFieldUpdateOperationsInput | boolean
    volunteerProjectManager?: BoolFieldUpdateOperationsInput | boolean
    volunteerQa?: BoolFieldUpdateOperationsInput | boolean
    volunteerSecurity?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BenefactorUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BenefactorUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BenefactorUncheckedUpdateManyWithoutBenefactorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceVault?: VaultUpdateOneRequiredWithoutWithdrawsInput
    sourceCampaign?: CampaignUpdateOneRequiredWithoutWithdrawalsInput
    bankAccount?: BankAccountUpdateOneRequiredWithoutWithdrawsInput
  }

  export type WithdrawalUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalUncheckedUpdateManyWithoutWithdrawalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BeneficiaryUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    countryCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
    city?: CityUpdateOneRequiredWithoutBeneficiariesInput
    coordinator?: CoordinatorUpdateOneRequiredWithoutBeneficiariesInput
    company?: CompanyUpdateOneWithoutBeneficiariesInput
    campaigns?: CampaignUpdateManyWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorId?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
    campaigns?: CampaignUncheckedUpdateManyWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedUpdateManyWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorId?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
  }

  export type InfoRequestUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InfoRequestUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InfoRequestUncheckedUpdateManyWithoutInfoRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CoordinatorUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficiaries?: BeneficiaryUpdateManyWithoutCoordinatorInput
  }

  export type CoordinatorUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCoordinatorInput
  }

  export type CoordinatorUncheckedUpdateManyWithoutCoordinatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecurringDonationUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRecurringDonationStatusFieldUpdateOperationsInput | RecurringDonationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extSubscriptionId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceVault?: VaultUpdateOneRequiredWithoutRecurringDonationsInput
  }

  export type RecurringDonationUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRecurringDonationStatusFieldUpdateOperationsInput | RecurringDonationStatus
    vaultId?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extSubscriptionId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecurringDonationUncheckedUpdateManyWithoutRecurringDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRecurringDonationStatusFieldUpdateOperationsInput | RecurringDonationStatus
    vaultId?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extSubscriptionId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BeneficiaryCreateManyCompanyInput = {
    id?: string
    type: BeneficiaryType
    personId?: string | null
    coordinatorId: string
    countryCode: string
    cityId: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
  }

  export type BeneficiaryUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    countryCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
    city?: CityUpdateOneRequiredWithoutBeneficiariesInput
    coordinator?: CoordinatorUpdateOneRequiredWithoutBeneficiariesInput
    person?: PersonUpdateOneWithoutBeneficiariesInput
    campaigns?: CampaignUpdateManyWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorId?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
    campaigns?: CampaignUncheckedUpdateManyWithoutBeneficiariesInput
  }

  export type BeneficiaryCreateManyCoordinatorInput = {
    id?: string
    type: BeneficiaryType
    personId?: string | null
    companyId?: string | null
    countryCode: string
    cityId: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
  }

  export type BeneficiaryUpdateWithoutCoordinatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    countryCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
    city?: CityUpdateOneRequiredWithoutBeneficiariesInput
    person?: PersonUpdateOneWithoutBeneficiariesInput
    company?: CompanyUpdateOneWithoutBeneficiariesInput
    campaigns?: CampaignUpdateManyWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedUpdateWithoutCoordinatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
    campaigns?: CampaignUncheckedUpdateManyWithoutBeneficiariesInput
  }

  export type CampaignCreateManyBeneficiariesInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    campaignTypeId: string
    approvedById?: string | null
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type CampaignUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutCampaignsInput
    campaignTypes?: CampaignTypeUpdateOneRequiredWithoutCampaignsInput
    vaults?: VaultUpdateManyWithoutCampaignInput
    incomingTransfers?: TransferUpdateManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUpdateManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUpdateManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedUpdateWithoutBeneficiariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    campaignTypeId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vaults?: VaultUncheckedUpdateManyWithoutCampaignInput
    incomingTransfers?: TransferUncheckedUpdateManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUncheckedUpdateManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutSourceCampaignInput
  }

  export type CampaignTypeCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
  }

  export type CampaignCreateManyCampaignTypesInput = {
    id?: string
    state?: CampaignState
    slug: string
    title: string
    essence: string
    coordinatorId: string
    beneficiaryId: string
    approvedById?: string | null
    description?: string | null
    targetAmount?: number | null
    currency?: Currency
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type CampaignTypeUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CampaignTypeUpdateManyWithoutParentInput
    campaigns?: CampaignUpdateManyWithoutCampaignTypesInput
  }

  export type CampaignTypeUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CampaignTypeUncheckedUpdateManyWithoutParentInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCampaignTypesInput
  }

  export type CampaignTypeUncheckedUpdateManyWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignUpdateWithoutCampaignTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutCampaignsInput
    beneficiaries?: BeneficiaryUpdateOneRequiredWithoutCampaignsInput
    vaults?: VaultUpdateManyWithoutCampaignInput
    incomingTransfers?: TransferUpdateManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUpdateManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUpdateManyWithoutSourceCampaignInput
  }

  export type CampaignUncheckedUpdateWithoutCampaignTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: EnumCampaignStateFieldUpdateOperationsInput | CampaignState
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    essence?: StringFieldUpdateOperationsInput | string
    coordinatorId?: StringFieldUpdateOperationsInput | string
    beneficiaryId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetAmount?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vaults?: VaultUncheckedUpdateManyWithoutCampaignInput
    incomingTransfers?: TransferUncheckedUpdateManyWithoutTargetCampaignInput
    outgoingTransfers?: TransferUncheckedUpdateManyWithoutSourceCampaignInput
    withdrawals?: WithdrawalUncheckedUpdateManyWithoutSourceCampaignInput
  }

  export type VaultCreateManyCampaignInput = {
    id?: string
    currency?: Currency
    amount?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TransferCreateManyTargetCampaignInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    targetVaultId: string
    approvedById?: string | null
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TransferCreateManySourceCampaignInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    targetVaultId: string
    targetCampaignId: string
    approvedById?: string | null
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalCreateManySourceCampaignInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    bankAccountId: string
    documentId?: string | null
    approvedById?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type VaultUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expenses?: ExpenseUpdateManyWithoutVaultInput
    sourceTransfers?: TransferUpdateManyWithoutSourceVaultInput
    targetTransfers?: TransferUpdateManyWithoutTargetVaultInput
    donations?: DonationUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUpdateManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUpdateManyWithoutSourceVaultInput
  }

  export type VaultUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutVaultInput
    sourceTransfers?: TransferUncheckedUpdateManyWithoutSourceVaultInput
    targetTransfers?: TransferUncheckedUpdateManyWithoutTargetVaultInput
    donations?: DonationUncheckedUpdateManyWithoutTargetVaultInput
    withdraws?: WithdrawalUncheckedUpdateManyWithoutSourceVaultInput
    recurringDonations?: RecurringDonationUncheckedUpdateManyWithoutSourceVaultInput
  }

  export type VaultUncheckedUpdateManyWithoutVaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUpdateWithoutTargetCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutTransfersInput
    sourceVault?: VaultUpdateOneRequiredWithoutSourceTransfersInput
    sourceCampaign?: CampaignUpdateOneRequiredWithoutOutgoingTransfersInput
    targetVault?: VaultUpdateOneRequiredWithoutTargetTransfersInput
  }

  export type TransferUncheckedUpdateWithoutTargetCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUncheckedUpdateManyWithoutIncomingTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUpdateWithoutSourceCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutTransfersInput
    sourceVault?: VaultUpdateOneRequiredWithoutSourceTransfersInput
    targetVault?: VaultUpdateOneRequiredWithoutTargetTransfersInput
    targetCampaign?: CampaignUpdateOneRequiredWithoutIncomingTransfersInput
  }

  export type TransferUncheckedUpdateWithoutSourceCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: StringFieldUpdateOperationsInput | string
    targetCampaignId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUncheckedUpdateManyWithoutOutgoingTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: StringFieldUpdateOperationsInput | string
    targetCampaignId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalUpdateWithoutSourceCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutWithdrawalsInput
    sourceVault?: VaultUpdateOneRequiredWithoutWithdrawsInput
    bankAccount?: BankAccountUpdateOneRequiredWithoutWithdrawsInput
  }

  export type WithdrawalUncheckedUpdateWithoutSourceCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BeneficiaryCreateManyCityInput = {
    id?: string
    type: BeneficiaryType
    personId?: string | null
    companyId?: string | null
    coordinatorId: string
    countryCode: string
    description?: string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    coordinatorRelation?: PersonRelation
  }

  export type BeneficiaryUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    countryCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
    coordinator?: CoordinatorUpdateOneRequiredWithoutBeneficiariesInput
    person?: PersonUpdateOneWithoutBeneficiariesInput
    company?: CompanyUpdateOneWithoutBeneficiariesInput
    campaigns?: CampaignUpdateManyWithoutBeneficiariesInput
  }

  export type BeneficiaryUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBeneficiaryTypeFieldUpdateOperationsInput | BeneficiaryType
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatorId?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicData?: NullableJsonNullValueInput | InputJsonValue
    privateData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coordinatorRelation?: EnumPersonRelationFieldUpdateOperationsInput | PersonRelation
    campaigns?: CampaignUncheckedUpdateManyWithoutBeneficiariesInput
  }

  export type CityCreateManyCountryCodeInput = {
    id?: string
    name: string
    postalCode: number
  }

  export type CityUpdateWithoutCountryCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: IntFieldUpdateOperationsInput | number
    beneficiaries?: BeneficiaryUpdateManyWithoutCityInput
  }

  export type CityUncheckedUpdateWithoutCountryCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: IntFieldUpdateOperationsInput | number
    beneficiaries?: BeneficiaryUncheckedUpdateManyWithoutCityInput
  }

  export type CityUncheckedUpdateManyWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    postalCode?: IntFieldUpdateOperationsInput | number
  }

  export type ExpenseCreateManyVaultInput = {
    id?: string
    type: ExpenseType
    currency?: Currency
    amount?: number
    description?: string | null
    documentId?: string | null
    approvedById?: string | null
  }

  export type TransferCreateManySourceVaultInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    sourceCampaignId: string
    targetVaultId: string
    targetCampaignId: string
    approvedById?: string | null
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TransferCreateManyTargetVaultInput = {
    id?: string
    status?: TransferStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    targetCampaignId: string
    approvedById?: string | null
    documentId?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type DonationCreateManyTargetVaultInput = {
    id?: string
    type: DonationType
    status?: DonationStatus
    provider?: PaymentProvider
    personId?: string | null
    currency?: Currency
    amount?: number
    extCustomerId: string
    extPaymentIntentId: string
    extPaymentMethodId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalCreateManySourceVaultInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    sourceCampaignId: string
    bankAccountId: string
    documentId?: string | null
    approvedById?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RecurringDonationCreateManySourceVaultInput = {
    id?: string
    status: RecurringDonationStatus
    personId: string
    currency?: Currency
    amount?: number
    extSubscriptionId: string
    extCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ExpenseUpdateWithoutVaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | ExpenseType
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: PersonUpdateOneWithoutExpensesInput
    document?: DocumentUpdateOneWithoutExpensesInput
  }

  export type ExpenseUncheckedUpdateWithoutVaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | ExpenseType
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransferUpdateWithoutSourceVaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutTransfersInput
    sourceCampaign?: CampaignUpdateOneRequiredWithoutOutgoingTransfersInput
    targetVault?: VaultUpdateOneRequiredWithoutTargetTransfersInput
    targetCampaign?: CampaignUpdateOneRequiredWithoutIncomingTransfersInput
  }

  export type TransferUncheckedUpdateWithoutSourceVaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: StringFieldUpdateOperationsInput | string
    targetCampaignId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUncheckedUpdateManyWithoutSourceTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: StringFieldUpdateOperationsInput | string
    targetCampaignId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUpdateWithoutTargetVaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutTransfersInput
    sourceVault?: VaultUpdateOneRequiredWithoutSourceTransfersInput
    sourceCampaign?: CampaignUpdateOneRequiredWithoutOutgoingTransfersInput
    targetCampaign?: CampaignUpdateOneRequiredWithoutIncomingTransfersInput
  }

  export type TransferUncheckedUpdateWithoutTargetVaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    targetCampaignId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUncheckedUpdateManyWithoutTargetTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | TransferStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    targetCampaignId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DonationUpdateWithoutTargetVaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDonationTypeFieldUpdateOperationsInput | DonationType
    status?: EnumDonationStatusFieldUpdateOperationsInput | DonationStatus
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | PaymentProvider
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extCustomerId?: StringFieldUpdateOperationsInput | string
    extPaymentIntentId?: StringFieldUpdateOperationsInput | string
    extPaymentMethodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneWithoutDonationInput
  }

  export type DonationUncheckedUpdateWithoutTargetVaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDonationTypeFieldUpdateOperationsInput | DonationType
    status?: EnumDonationStatusFieldUpdateOperationsInput | DonationStatus
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | PaymentProvider
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extCustomerId?: StringFieldUpdateOperationsInput | string
    extPaymentIntentId?: StringFieldUpdateOperationsInput | string
    extPaymentMethodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DonationUncheckedUpdateManyWithoutDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDonationTypeFieldUpdateOperationsInput | DonationType
    status?: EnumDonationStatusFieldUpdateOperationsInput | DonationStatus
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | PaymentProvider
    personId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extCustomerId?: StringFieldUpdateOperationsInput | string
    extPaymentIntentId?: StringFieldUpdateOperationsInput | string
    extPaymentMethodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalUpdateWithoutSourceVaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutWithdrawalsInput
    sourceCampaign?: CampaignUpdateOneRequiredWithoutWithdrawalsInput
    bankAccount?: BankAccountUpdateOneRequiredWithoutWithdrawsInput
  }

  export type WithdrawalUncheckedUpdateWithoutSourceVaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalUncheckedUpdateManyWithoutWithdrawsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecurringDonationUpdateWithoutSourceVaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRecurringDonationStatusFieldUpdateOperationsInput | RecurringDonationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extSubscriptionId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    person?: PersonUpdateOneRequiredWithoutRecurringDonationsInput
  }

  export type RecurringDonationUncheckedUpdateWithoutSourceVaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRecurringDonationStatusFieldUpdateOperationsInput | RecurringDonationStatus
    personId?: StringFieldUpdateOperationsInput | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    extSubscriptionId?: StringFieldUpdateOperationsInput | string
    extCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalCreateManyBankAccountInput = {
    id?: string
    status?: WithdrawStatus
    currency: Currency
    amount?: number
    reason: string
    sourceVaultId: string
    sourceCampaignId: string
    documentId?: string | null
    approvedById?: string | null
    targetDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalUpdateWithoutBankAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: PersonUpdateOneWithoutWithdrawalsInput
    sourceVault?: VaultUpdateOneRequiredWithoutWithdrawsInput
    sourceCampaign?: CampaignUpdateOneRequiredWithoutWithdrawalsInput
  }

  export type WithdrawalUncheckedUpdateWithoutBankAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWithdrawStatusFieldUpdateOperationsInput | WithdrawStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    sourceCampaignId?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExpenseCreateManyDocumentInput = {
    id?: string
    type: ExpenseType
    currency?: Currency
    amount?: number
    description?: string | null
    vaultId: string
    approvedById?: string | null
  }

  export type ExpenseUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | ExpenseType
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vault?: VaultUpdateOneRequiredWithoutExpensesInput
    approvedBy?: PersonUpdateOneWithoutExpensesInput
  }

  export type ExpenseUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumExpenseTypeFieldUpdateOperationsInput | ExpenseType
    currency?: EnumCurrencyFieldUpdateOperationsInput | Currency
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vaultId?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}
